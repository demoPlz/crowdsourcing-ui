<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Collection Monitor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f8fafc;
            height: 100vh;
            overflow: hidden;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            gap: 20px;
            padding: 20px;
        }
        
        .top-section {
            display: flex;
            gap: 20px;
        }
        
        .camera-section {
            flex: 3;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            padding: 20px;
        }
        
        .status-control-column {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .status-section {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .control-section {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .main-content {
            display: flex;
            flex: 1;
            gap: 20px;
            min-height: 0;
        }
        
        .left-panel {
            flex: 2;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            padding: 20px;
            display: flex;
            flex-direction: column;
        }
        
        .right-panel {
            flex: 1;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .panel-header {
            border-bottom: 2px solid #e2e8f0;
            padding-bottom: 16px;
            margin-bottom: 20px;
        }
        
        .panel-header h2 {
            color: #1e293b;
            font-size: 24px;
            font-weight: 600;
        }
        
        .camera-views {
            width: 100%;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 12px;
            height: 400px;
        }
        
        .camera-view {
            background: #f1f5f9;
            border-radius: 4px;
            border: 1px solid #e2e8f0;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            transition: all 0.2s ease;
        }
        
        .camera-view:hover {
            border-color: #3b82f6;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.15);
        }
        
        .camera-image {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 3px;
        }

        .camera-view {              /* only positioning context, doesn't change layout */
            position: relative;
        }

        .camera-layer {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 3px;     /* matches .camera-image */
            display: none;          /* Use display instead of opacity for instant swap */
        }

        .camera-layer.is-visible {
            display: block;
        }
        
        .camera-placeholder {
            color: #64748b;
            font-size: 10px;
            text-align: center;
            padding: 8px;
        }
        
        .status-card {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 16px;
        }
        
        .status-card h3 {
            color: #1e293b;
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 12px;
        }
        
        .status-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #e2e8f0;
        }
        
        .status-item:last-child {
            border-bottom: none;
        }
        
        .status-label {
            color: #64748b;
            font-size: 14px;
        }
        
        .status-value {
            color: #1e293b;
            font-weight: 500;
            font-size: 14px;
        }
        
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }
        
        .status-indicator.connected {
            background: #10b981;
            box-shadow: 0 0 8px rgba(16, 185, 129, 0.4);
        }
        
        .status-indicator.disconnected {
            background: #ef4444;
            box-shadow: 0 0 8px rgba(239, 68, 68, 0.4);
        }
        
        .status-indicator.warning {
            background: #f59e0b;
            box-shadow: 0 0 8px rgba(245, 158, 11, 0.4);
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #1d4ed8);
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        
        .robot-state {
            padding: 12px;
            border-radius: 6px;
            font-weight: 500;
            text-align: center;
            margin: 8px 0;
        }
        
        .robot-state.moving {
            background: #fef3c7;
            color: #92400e;
            border: 1px solid #fcd34d;
        }
        
        .robot-state.stationary {
            background: #d1fae5;
            color: #065f46;
            border: 1px solid #6ee7b7;
        }
        
        .robot-state.async-collection {
            background: #e0e7ff;
            color: #3730a3;
            border: 1px solid #a5b4fc;
            animation: pulse 2s infinite;
        }
        
        .robot-state.resetting {
            background: #fef3c7;
            color: #92400e;
            border: 1px solid #fcd34d;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .error-message {
            background: #fef2f2;
            border: 1px solid #fecaca;
            color: #dc2626;
            padding: 12px;
            border-radius: 6px;
            font-size: 14px;
            text-align: center;
        }
        
        .control-buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .control-button {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 12px 16px;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .control-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 16px rgba(0,0,0,0.15);
        }
        
        .control-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .control-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .control-button.loading {
            opacity: 0.7;
            cursor: wait;
        }
        
        .fast-forward-btn {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            color: white;
        }
        
        .fast-forward-btn:hover {
            background: linear-gradient(135deg, #2563eb, #1e40af);
        }
        
        .rerecord-btn {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: white;
        }
        
        .rerecord-btn:hover {
            background: linear-gradient(135deg, #e3a008, #c2701a);
        }
        
        .stop-btn {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
        }
        
        .stop-btn:hover {
            background: linear-gradient(135deg, #dc2626, #b91c1c);
        }
        
        .control-icon {
            font-size: 20px;
        }
        
        /* Episode Charts Styles */
        .episode-charts-container {
            max-height: calc(100vh - 200px);
            overflow-y: auto;
            padding-right: 8px;
        }
        
        .episode-chart {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
            transition: all 0.2s ease;
        }
        
        .episode-chart:hover {
            border-color: #3b82f6;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.15);
        }
        
        .episode-chart.current {
            border-color: #10b981;
            background: #f0fdf4;
            box-shadow: 0 2px 8px rgba(16, 185, 129, 0.15);
        }
        
        .episode-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .episode-title {
            font-weight: 600;
            font-size: 14px;
            color: #1e293b;
        }
        
        .episode-stats {
            font-size: 12px;
            color: #64748b;
        }
        
        .chart-container {
            position: relative;
            height: 80px;
            background: white;
            border-radius: 4px;
            border: 1px solid #e2e8f0;
            overflow: hidden;
        }
        
        .chart-bars {
            display: flex;
            height: calc(100% - 26px);
            align-items: end;
            padding: 0px 8px 16px 8px;
            gap: 1px;
            overflow-x: auto;
            overflow-y: hidden;
            width: calc(100% - 40px);
            position: absolute;
            top: 10px;
            left: 32px;
            scrollbar-width: thin;
        }
        
        .state-bar-container {
            flex: 1;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: end;
            position: relative;
            min-width: 2px;
            max-width: 20px;
        }
        
        .state-bar {
            background: linear-gradient(180deg, #10b981, #059669);
            border-radius: 2px 2px 0 0;
            transition: height 0.3s ease;
            position: relative;
            min-height: 2px;
            width: 100%;
        }
        
        .state-bar.empty {
            background: #e2e8f0;
            height: 100% !important;
        }
        
        .state-bar.important-complete {
            background: linear-gradient(180deg, #dc2626, #991b1b) !important;
        }
        
        .state-bar.important-incomplete {
            background: linear-gradient(180deg, #f87171, #dc2626) !important;
        }
        
        .state-bar.regular-complete {
            background: linear-gradient(180deg, #2563eb, #1d4ed8) !important;
        }
        
        .state-bar.regular-incomplete {
            background: linear-gradient(180deg, #60a5fa, #2563eb) !important;
        }
        
        .state-bar-label {
            position: absolute;
            bottom: -16px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: #64748b;
            white-space: nowrap;
        }
        
        .chart-y-axis {
            position: absolute;
            left: 0;
            top: 10px;
            bottom: 16px;
            width: 32px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 0px 4px 0px 4px;
            background: rgba(248, 250, 252, 0.9);
            border-right: 1px solid #e2e8f0;
        }
        
        .y-axis-label {
            font-size: 10px;
            color: #64748b;
            text-align: center;
        }
        
        .chart-x-axis {
            position: absolute;
            bottom: 0;
            left: 32px;
            right: 8px;
            height: 16px;
            display: flex;
            align-items: center;
            padding: 0 8px;
            background: rgba(248, 250, 252, 0.9);
            border-top: 1px solid #e2e8f0;
            font-size: 10px;
            color: #64748b;
        }
        
        /* Scrollbar styling for chart bars */
        .chart-bars::-webkit-scrollbar {
            height: 4px;
        }
        
        .chart-bars::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 2px;
        }
        
        .chart-bars::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 2px;
        }
        
        .chart-bars::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }
        
        /* Scrollbar styling */
        .episode-charts-container::-webkit-scrollbar {
            width: 6px;
        }
        
        .episode-charts-container::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 3px;
        }
        
        .episode-charts-container::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 3px;
        }
        
        .episode-charts-container::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Top Section: Camera Views and Status/Control Column -->
        <div class="top-section">
            <!-- Camera Views -->
            <div class="camera-section">
                <div class="camera-views">
                    <div class="camera-view" id="camera-front">
                        <div class="camera-placeholder">No image</div>
                    </div>
                    <div class="camera-view" id="camera-left">
                        <div class="camera-placeholder">No image</div>
                    </div>
                    <div class="camera-view" id="camera-right">
                        <div class="camera-placeholder">No image</div>
                    </div>
                    <div class="camera-view" id="camera-perspective">
                        <div class="camera-placeholder">No image</div>
                    </div>
                    <div class="camera-view" id="camera-obs_main">
                        <div class="camera-placeholder">No image</div>
                    </div>
                    <div class="camera-view" id="camera-obs_wrist">
                        <div class="camera-placeholder">No image</div>
                    </div>
                </div>
            </div>
            
            <!-- Status and Control Column -->
            <div class="status-control-column">
                <!-- System Status -->
                <div class="status-section">
                    <!-- Connection Status -->
                    <div class="status-card">
                        <div class="status-item">
                            <span class="status-label">Backend Server</span>
                            <span class="status-value" id="server-status">
                                <span class="status-indicator disconnected"></span>
                                Checking...
                            </span>
                        </div>
                    </div>
                    
                    <!-- Robot Status -->
                    <div class="status-card">
                        <div class="robot-state stationary" id="robot-state">
                            üõë Robot Status Unknown
                        </div>
                        <div class="status-item">
                            <span class="status-label">Current State ID</span>
                            <span class="status-value" id="current-state-id">--</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">State Type</span>
                            <span class="status-value" id="state-type">--</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">Responses</span>
                            <span class="status-value" id="state-responses">--</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">Pending States</span>
                            <span class="status-value" id="pending-states-count">--</span>
                        </div>
                    </div>
                </div>
                
                <!-- Control Panel -->
                <div class="control-section">
                    <div class="control-buttons">
                        <button class="control-button fast-forward-btn" id="fast-forward-btn">
                            <span class="control-icon">‚è©</span>
                            Next Episode
                        </button>
                        
                        <button class="control-button rerecord-btn" id="rerecord-btn">
                            <span class="control-icon">üîÑ</span>
                            Re-record Episode
                        </button>
                        
                        <button class="control-button stop-btn" id="stop-btn">
                            <span class="control-icon">‚èπÔ∏è</span>
                            Stop Recording
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Main Content Area -->
        <div class="main-content">
            <!-- Episode Progress Charts (full width) -->
            <div class="left-panel" style="flex: 1;">
                <div class="episode-charts-container" id="episode-charts-container">
                    <!-- Episode charts will be dynamically added here -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // Simple API Configuration - use appropriate proxy based on environment
        async function getCurrentCloudflaredUrl() {
            try {
                // For production (Netlify), always use the function proxy to avoid CORS issues
                if (location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
                    return '/.netlify/functions/api';
                }
                
                // For local development, try to get the actual cloudflared URL from Netlify function
                // This only works if running netlify dev, otherwise fallback to hardcoded URL
                try {
                    const response = await fetch('/.netlify/functions/get-backend-url');
                    if (response.ok) {
                        const data = await response.json();
                        return data.backend_url;
                    }
                } catch (netlifyError) {
                    // Netlify functions not available (running on pure Vite dev server)
                    console.log('Netlify functions not available, using fallback Tailscale URL');
                }
                
                // Fallback to hardcoded Tailscale URL for local development
                return 'https://ztclab-1.tail503d36.ts.net';
            } catch (error) {
                console.error('Error getting backend URL:', error);
                // Fallback based on environment
                if (location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
                    return '/.netlify/functions/api'; // Use proxy for production
                }
                return 'https://reconstruction-parker-put-push.trycloudflare.com'; // Direct for local dev
            }
        }

        // Initialize API_BASE_URL - will be set dynamically
        let API_BASE_URL = '/.netlify/functions/api'; // Default to proxy

        // Set API_BASE_URL dynamically based on environment
        async function initializeApiUrl() {
            if (location.hostname === 'localhost' || location.hostname === '127.0.0.1') {
                if (location.port === '5173' || location.port === '5174') {
                    // Running on Vite dev server - get direct cloudflared URL
                    API_BASE_URL = await getCurrentCloudflaredUrl();
                    console.log('[DEBUG] Monitor using direct cloudflared URL for Vite dev server:', API_BASE_URL);
                } else {
                    // Running on production build locally
                    API_BASE_URL = 'http://127.0.0.1:9000';
                }
            } else {
                // Running on deployed Netlify - use function proxy to avoid CORS
                API_BASE_URL = '/.netlify/functions/api';
                console.log('[DEBUG] Monitor using Netlify function proxy for production:', API_BASE_URL);
            }
        }

        // Configuration

        // === Performance knobs ===
        const DEBUG = false;               // flip to true if you want console logs
        const CAMERA_POLL_MS = 250;        // ~4 FPS for camera previews
        const INFO_POLL_MS   = 1000;       // 1 Hz for episode/state metadata

        let latestStateInFlight = false;
        let pendingInfoInFlight = false;

        // Track per-camera last update to avoid churn
        const lastCamUpdate = { front: 0, left: 0, right: 0, perspective: 0, obs_main: 0, obs_wrist: 0 };
        // Double-buffer state per camera (created on first frame)
        const cameraBuffers = {};          // cameraName -> { imgs: [img0, img1], active: 0/1, lastSrc: '', initialized: bool }
        const camSwapInFlight = {};        // cameraName -> boolean (prevents overlapping swaps)

        let autoRefreshInterval = null;
        
        // DOM elements
        const serverStatus = document.getElementById('server-status');
        const robotState = document.getElementById('robot-state');
        const currentStateId = document.getElementById('current-state-id');
        const stateType = document.getElementById('state-type');
        const stateResponses = document.getElementById('state-responses');
        const pendingStatesCount = document.getElementById('pending-states-count');
        
        // Control button elements
        const fastForwardBtn = document.getElementById('fast-forward-btn');
        const rerecordBtn = document.getElementById('rerecord-btn');
        const stopBtn = document.getElementById('stop-btn');
        
        // Camera view elements
        const cameraViews = {
            front: document.getElementById('camera-front'),
            left: document.getElementById('camera-left'),
            right: document.getElementById('camera-right'),
            perspective: document.getElementById('camera-perspective'),
            obs_main: document.getElementById('camera-obs_main'),
            obs_wrist: document.getElementById('camera-obs_wrist')
        };
        
        // Episode charts management
        const episodeChartsContainer = document.getElementById('episode-charts-container');
        let episodes = []; // Array of episode data
        let REQUIRED_RESPONSES_PER_STATE = 1; // Will be updated from API
        let REQUIRED_RESPONSES_PER_IMPORTANT_STATE = 10; // Will be updated from API

        // Track user scroll state to prevent auto-scroll interference
        let userIsScrolling = false;
        let scrollTimeout = null;

        // Remove episodes that the backend no longer reports (they've been fully completed and pruned)
        function pruneMissingEpisodes(presentIds) {
            const present = new Set(presentIds);
            for (let i = episodes.length - 1; i >= 0; i--) {
                const ep = episodes[i];
                if (!present.has(ep.id)) {
                    const el = document.getElementById(`episode-${ep.id}`);
                    if (el) el.remove();
                    episodes.splice(i, 1);
                }
            }
            updateCurrentEpisodeIndicator();
        }
        
        // Update server status indicator
        function updateServerStatus(connected) {
            const indicator = serverStatus.querySelector('.status-indicator');
            if (connected) {
                indicator.className = 'status-indicator connected';
                serverStatus.innerHTML = '<span class="status-indicator connected"></span>Connected';
            } else {
                indicator.className = 'status-indicator disconnected';
                serverStatus.innerHTML = '<span class="status-indicator disconnected"></span>Disconnected';
            }
        }

        function ensureCameraBuffers(cameraName) {
            const container = cameraViews[cameraName];
            if (!container) return null;

            let state = cameraBuffers[cameraName];
            if (!state) {
                // Create two stacked <img> layers; start hidden (opacity 0).
                const img0 = document.createElement('img');
                img0.className = 'camera-image camera-layer';
                img0.alt = `${cameraName} camera 0`;

                const img1 = document.createElement('img');
                img1.className = 'camera-image camera-layer';
                img1.alt = `${cameraName} camera 1`;

                container.appendChild(img0);
                container.appendChild(img1);

                state = cameraBuffers[cameraName] = {
                    imgs: [img0, img1],
                    active: 0,
                    lastSrc: '',
                    initialized: false
                };
            }
            return state;
        }
        
        // Update camera view
        async function updateCameraView(cameraName, imageDataUrl) {
            const container = cameraViews[cameraName];
            if (!container) return;

            // If no image: show (or keep) placeholder and hide buffers
            if (!imageDataUrl || !imageDataUrl.startsWith('data:image/')) {
                const state = cameraBuffers[cameraName];
                if (state) {
                    state.imgs[0].classList.remove('is-visible');
                    state.imgs[1].classList.remove('is-visible');
                    state.initialized = false;
                    state.lastSrc = '';
                }
                if (!container.querySelector('.camera-placeholder')) {
                    const ph = document.createElement('div');
                    ph.className = 'camera-placeholder';
                    ph.textContent = 'No image';
                    container.appendChild(ph);
                }
                return;
            }

            // Throttle a bit to avoid redundant churn
            const now = performance.now();
            if (now - (lastCamUpdate[cameraName] || 0) < CAMERA_POLL_MS * 0.9) return;

            const state = ensureCameraBuffers(cameraName);
            if (!state) return;

            // If the incoming frame is byte-identical to the last one, skip
            if (imageDataUrl === state.lastSrc) return;

            // Avoid overlapping decodes/swaps for this camera
            if (camSwapInFlight[cameraName]) return;
            camSwapInFlight[cameraName] = true;

            const backIndex = 1 - state.active;
            const backImg   = state.imgs[backIndex];

            try {
                backImg.decoding = 'async';
                backImg.src = imageDataUrl;

                // Wait until the new frame is fully decoded before we show it
                if (typeof backImg.decode === 'function') {
                    await backImg.decode().catch(() => {});
                } else {
                    await new Promise(resolve =>
                        backImg.complete ? resolve() : (backImg.onload = () => resolve())
                    );
                }

                // First successful frame: remove placeholder if present
                if (!state.initialized) {
                    const ph = container.querySelector('.camera-placeholder');
                    if (ph) ph.remove();
                    state.initialized = true;
                }

                // Atomic swap: hide old image and show new one instantly
                // This eliminates any flickering or empty frames
                state.imgs[state.active].classList.remove('is-visible');
                backImg.classList.add('is-visible');
                state.active = backIndex;
                
                state.lastSrc = imageDataUrl;
                lastCamUpdate[cameraName] = now;
            } finally {
                camSwapInFlight[cameraName] = false;
            }
        }

        
        // Update robot state
        function updateRobotState(isMoving, isResetting, resetCountdown, isAsyncCollection) {
            if (isResetting) {
                robotState.className = 'robot-state resetting';
                const countdownText = resetCountdown > 0 ? ` (${Math.ceil(resetCountdown)}s)` : '';
                robotState.textContent = `üîÑ Resetting Environment${countdownText}`;
            } else if (isAsyncCollection) {
                robotState.className = 'robot-state async-collection';
                robotState.textContent = 'üîÑ Asynchronous Data Collection';
            } else if (isMoving) {
                robotState.className = 'robot-state moving';
                robotState.textContent = 'üèÉ Robot Moving';
            } else {
                robotState.className = 'robot-state stationary';
                robotState.textContent = 'üõë Robot Stationary';
            }
        }
        
        // Update control buttons based on reset state
        function updateControlButtons(isResetting) {
            if (isResetting) {
                // Change "Next Episode" to "Start Episode" during reset
                fastForwardBtn.innerHTML = '<span class="control-icon">‚ñ∂Ô∏è</span>Start Episode';
                fastForwardBtn.title = 'Skip remaining reset time and start episode immediately';
            } else {
                // Normal "Next Episode" button
                fastForwardBtn.innerHTML = '<span class="control-icon">‚è©</span>Next Episode';
                fastForwardBtn.title = 'Finish current episode and move to next';
            }
        }
        
        // Update joint positions display
        function updateJointPositions(joints) {
            // Function removed - joint positions panel no longer exists
        }
        
        // Episode Chart Management - Episodes are now managed by the backend
        
        function createEpisodeChartElement(episode) {
            const episodeDiv = document.createElement('div');
            episodeDiv.className = 'episode-chart';
            episodeDiv.id = `episode-${episode.id}`;
            
            if (episode.isCurrentServing) {
                episodeDiv.classList.add('current');
            }
            
            episodeDiv.innerHTML = `
                <div class="episode-header">
                    <div class="episode-title">Episode ${episode.id}</div>
                    <div class="episode-stats" id="episode-${episode.id}-stats">
                        ${Object.keys(episode.states).length} states, 0 responses
                    </div>
                </div>
                <div class="chart-container">
                    <div class="chart-y-axis">
                        <div class="y-axis-label">${REQUIRED_RESPONSES_PER_IMPORTANT_STATE}</div>
                        <div class="y-axis-label">${Math.floor(REQUIRED_RESPONSES_PER_IMPORTANT_STATE / 2)}</div>
                        <div class="y-axis-label">0</div>
                    </div>
                    <div class="chart-bars" id="episode-${episode.id}-bars"></div>
                    <div class="chart-x-axis">State IDs</div>
                </div>
            `;
            
            episodeChartsContainer.appendChild(episodeDiv);
            // After episodeChartsContainer.appendChild(episodeDiv);
            const bars = document.getElementById(`episode-${episode.id}-bars`);
            const stats = document.getElementById(`episode-${episode.id}-stats`);

            // Cache DOM references & a per-episode bar map
            episode.barsContainer = bars;
            episode.statsElement  = stats;
            episode.barEls        = {};   // stateId -> <div.state-bar-container>
            episode.responsesTotal = 0;   // keep running totals without O(N) recomputation
            episode.importantCount = 0;
            episode.regularCount   = 0;
        }
        
        function updateEpisodeChart(episodeId, stateId, responsesReceived, isImportant, forceRefresh = false) {
            // Find the episode object you created earlier
            const episode = episodes.find(ep => ep.id === episodeId);
            if (!episode || !episode.barsContainer) return;

            // Force refresh is used only to refresh stats; keep it cheap
            if (forceRefresh) {
                // Update stats text from cached episode.state entries
                const values = Object.values(episode.states || {});
                let totalResponses = 0, important = 0, regular = 0;
                for (const v of values) {
                    totalResponses += v.responses || 0;
                    if (v.isImportant) important++; else regular++;
                }
                episode.responsesTotal = totalResponses;
                episode.importantCount = important;
                episode.regularCount   = regular;
                if (episode.statsElement) {
                    episode.statsElement.textContent =
                        `${values.length} states (üî¥${important} üîµ${regular}), ${totalResponses} responses`;
                }
                return;
            }

            // Initialize storage for states if missing
            if (!episode.states) episode.states = {};

            // Short-circuit if nothing changed
            const prev = episode.states[stateId];
            if (prev && prev.responses === responsesReceived && prev.isImportant === !!isImportant) {
                return;
            }

            // Maintain running totals cheaply
            if (prev) {
                episode.responsesTotal -= prev.responses || 0;
                if (prev.isImportant) episode.importantCount--; else episode.regularCount--;
            }
            episode.responsesTotal += (responsesReceived || 0);
            if (isImportant) episode.importantCount++; else episode.regularCount++;

            // Cache the new state record
            episode.states[stateId] = {
                responses: responsesReceived || 0,
                isImportant: !!isImportant
            };

            // Upsert the bar DOM node for this state
            let barContainer = episode.barEls[stateId];
            if (!barContainer) {
                barContainer = document.createElement('div');
                barContainer.className = 'state-bar-container';
                barContainer.style.flex = 'none';
                barContainer.style.width = '3px'; // fixed narrow column, lets container scroll horizontally

                const bar = document.createElement('div');
                bar.className = 'state-bar';
                barContainer.appendChild(bar);

                // Keep bars sorted by stateId with cheap insertion
                barContainer.dataset.stateId = String(stateId);
                const kids = episode.barsContainer.children;
                let inserted = false;
                for (let i = kids.length - 1; i >= 0; i--) {
                    const cur = parseInt(kids[i].dataset.stateId, 10);
                    if (cur <= stateId) {
                        episode.barsContainer.insertBefore(barContainer, kids[i].nextSibling);
                        inserted = true;
                        break;
                    }
                }
                if (!inserted) episode.barsContainer.insertBefore(barContainer, episode.barsContainer.firstChild);

                episode.barEls[stateId] = barContainer;
            }

            const bar = barContainer.firstChild;
            const required = isImportant ? REQUIRED_RESPONSES_PER_IMPORTANT_STATE : REQUIRED_RESPONSES_PER_STATE;

            // Reset classes then set state‚Äëspecific styles
            bar.className = 'state-bar';

            if ((responsesReceived || 0) === 0) {
                bar.classList.add('empty');
                bar.style.height = '100%';  // empty bars are full height but gray
            } else {
                const pct = Math.min((responsesReceived / Math.max(1, required)) * 100, 100);
                bar.style.height = `${pct}%`;
                if (isImportant) {
                    bar.classList.add(responsesReceived >= required ? 'important-complete' : 'important-incomplete');
                } else {
                    bar.classList.add(responsesReceived >= required ? 'regular-complete' : 'regular-incomplete');
                }
            }

            // Tooltip
            const pct = Math.min((responsesReceived / Math.max(1, required)) * 100, 100);
            barContainer.title = `State ${stateId}: ${responsesReceived}/${required} (${pct.toFixed(1)}%, ${isImportant ? 'Important' : 'Regular'})`;

            // Update stats (cheap; uses cached running totals)
            if (episode.statsElement) {
                const count = Object.keys(episode.states).length;
                episode.statsElement.textContent =
                    `${count} states (üî¥${episode.importantCount} üîµ${episode.regularCount}), ${episode.responsesTotal} responses`;
            }
        }
        
        function updateCurrentEpisodeIndicator() {
            const current = episodes.find(ep => ep.isCurrentServing);
            document.querySelectorAll('.episode-chart').forEach(chart => chart.classList.remove('current'));
            if (current) {
                const el = document.getElementById(`episode-${current.id}`);
                if (el) {
                    el.classList.add('current');
                    // Only auto-scroll if user is not manually scrolling
                    if (!userIsScrolling) {
                        el.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }
                }
            }
        }
        
        function processMonitoringData(data) {
            if (data.required_responses_per_state) {
                REQUIRED_RESPONSES_PER_STATE = data.required_responses_per_state;
            }
            if (data.required_responses_per_important_state) {
                REQUIRED_RESPONSES_PER_IMPORTANT_STATE = data.required_responses_per_important_state;
            }

            if (!data.episodes) return;

            // Remove episodes the backend pruned
            pruneMissingEpisodes(Object.keys(data.episodes));

            for (const [episodeId, episodeData] of Object.entries(data.episodes)) {
                let episodeIndex = episodes.findIndex(ep => ep.id === episodeId);
                if (episodeIndex === -1) {
                    const newEpisode = {
                        index: episodes.length,
                        id: episodeId,
                        states: {},
                        maxStates: 0,
                        isComplete: episodeData.is_completed || false,
                        isCurrentServing: episodeData.is_current_serving || false
                    };
                    episodes.push(newEpisode);
                    createEpisodeChartElement(newEpisode);
                    episodeIndex = newEpisode.index;
                }

                const episode = episodes[episodeIndex];
                episode.isComplete = episodeData.is_completed || false;
                episode.isCurrentServing = episodeData.is_current_serving || false;

                // Upsert state bars incrementally
                if (episodeData.states) {
                    for (const [sidStr, info] of Object.entries(episodeData.states)) {
                        const sid = parseInt(sidStr, 10);
                        updateEpisodeChart(episodeId, sid, info.responses_received || 0, info.is_important || false);
                    }
                }

                // Update header badges
                const episodeElement = document.getElementById(`episode-${episodeId}`);
                if (episodeElement) {
                    const titleElement = episodeElement.querySelector('.episode-title');
                    if (titleElement) {
                        let title = `Episode ${episodeId}`;
                        if (episode.isCurrentServing) title += ' (Current)';
                        if (episode.isComplete)       title += ' (Complete)';
                        titleElement.textContent = title;
                    }
                    episodeElement.classList.toggle('current',  episode.isCurrentServing);
                    episodeElement.classList.toggle('complete', episode.isComplete);
                }
            }

            updateCurrentEpisodeIndicator();
        }
        
        // Fetch latest state from monitoring endpoint
        async function fetchLatestState() {
            try {
                console.log('Fetching latest state from:', `${API_BASE_URL}/api/monitor/latest-state`);
                    const response = await fetch(`${API_BASE_URL}/api/monitor/latest-state`, {
                        headers: {
                            'Accept': 'application/json'
                        }
                    });                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('Received monitoring data:', data);
                
                // Update server status
                updateServerStatus(true);
                
                if (data.status === 'success') {
                    // Update camera views
                    if (data.views) {
                        for (const [cameraName, imageDataUrl] of Object.entries(data.views)) {
                            updateCameraView(cameraName, imageDataUrl);
                        }
                    }
                    
                    // Update status information
                    currentStateId.textContent = data.state_id || '--';
                    
                    // Update state type and response information
                    if (data.is_important !== undefined) {
                        stateType.textContent = data.is_important ? 'üî¥ Important' : 'üîµ Regular';
                        const required = data.is_important ? REQUIRED_RESPONSES_PER_IMPORTANT_STATE : REQUIRED_RESPONSES_PER_STATE;
                        const received = data.responses_received || 0;
                        stateResponses.textContent = `${received}/${required}`;
                    } else {
                        stateType.textContent = '--';
                        stateResponses.textContent = '--';
                    }
                    
                    // Update robot state
                    updateRobotState(data.robot_moving, data.is_resetting, data.reset_countdown, data.is_async_collection);
                    
                    // Update control button based on reset state
                    updateControlButtons(data.is_resetting);
                    
                    // Update pending states count
                    if (data.total_pending_states !== undefined) {
                        pendingStatesCount.textContent = data.total_pending_states;
                    } else {
                        pendingStatesCount.textContent = '--';
                    }
                    
                } else if (data.status === 'no_states' || data.status === 'no_pending_states') {
                    // No pending states, but we may be in RESET; still render robot/reset UI.
                    currentStateId.textContent = 'No states';
                    stateType.textContent = '--';
                    stateResponses.textContent = '--';
                    pendingStatesCount.textContent = '0';

                    // Show reset / async / motion state even when there are no states.
                    updateRobotState(
                        data.robot_moving,
                        data.is_resetting,
                        data.reset_countdown,
                        data.is_async_collection
                    );
                    // Flip "Next Episode" ‚Üî "Start Episode" based on reset flag.
                    updateControlButtons(data.is_resetting);

                    // Keep showing the latest camera snapshots if provided.
                    if (data.views) {
                        for (const [cameraName, imageDataUrl] of Object.entries(data.views)) {
                            updateCameraView(cameraName, imageDataUrl);
                        }
                    }
                }

            } catch (error) {
                console.error('Error fetching latest state:', error);
                updateServerStatus(false);
            }
        }
        
        // Fetch pending states info for episode tracking
        async function fetchPendingStatesInfo() {
            try {
                const response = await fetch(`${API_BASE_URL}/api/pending-states-info`, {
                    headers: {
                        'Accept': 'application/json'
                    }
                });
                if (response.ok) {
                    const data = await response.json();
                    processMonitoringData(data);
                    
                    // Update the pending states count in the DOM
                    if (pendingStatesCount) {
                        pendingStatesCount.textContent = data.total_pending || 0;
                    }
                }
            } catch (error) {
                console.error('Error fetching pending states info:', error);
            }
        }
        
        // Auto-refresh function (always enabled at 30 FPS)
        function startAutoRefresh() {
            stopAutoRefresh(); // clear any old timers

            autoRefreshInterval = {
                cameras: setInterval(() => {
                    if (!latestStateInFlight) {
                        latestStateInFlight = true;
                        fetchLatestState().finally(() => latestStateInFlight = false);
                    }
                }, CAMERA_POLL_MS),

                info: setInterval(() => {
                    if (!pendingInfoInFlight) {
                        pendingInfoInFlight = true;
                        fetchPendingStatesInfo().finally(() => pendingInfoInFlight = false);
                    }
                }, INFO_POLL_MS)
            };

            if (DEBUG) console.log(`Auto-refresh started (cams ${Math.round(1000/CAMERA_POLL_MS)} FPS, info ${Math.round(1000/INFO_POLL_MS)} Hz)`);
        }

        function stopAutoRefresh() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval.cameras);
                clearInterval(autoRefreshInterval.info);
                autoRefreshInterval = null;
                if (DEBUG) console.log('Auto-refresh stopped');
            }
        }
        
        // Control button handlers
        async function handleFastForward() {
            const buttonText = fastForwardBtn.textContent;
            const isStartEpisode = buttonText.includes('Start Episode');
            
            console.log(isStartEpisode ? 'Start Episode button clicked' : 'Next Episode button clicked');
            const button = fastForwardBtn;
            button.classList.add('loading');
            button.disabled = true;
            
            try {
                const endpoint = isStartEpisode ? '/api/control/start-episode' : '/api/control/next-episode';
                const response = await fetch(`${API_BASE_URL}${endpoint}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                const result = await response.json();
                if (result.status === 'success') {
                    const action = isStartEpisode ? 'episode start' : 'next episode';
                    console.log(`‚úÖ ${action} triggered successfully`);
                    
                    // The new episode will be automatically detected on the next data fetch
                    // No need to manually create episode charts since backend manages episodes
                    
                } else {
                    const action = isStartEpisode ? 'start episode' : 'trigger next episode';
                    console.error(`‚ùå Failed to ${action}:`, result.message);
                }
            } catch (error) {
                const action = isStartEpisode ? 'starting episode' : 'triggering next episode';
                console.error(`‚ùå Error ${action}:`, error);
            } finally {
                button.classList.remove('loading');
                button.disabled = false;
            }
        }
        
        async function handleRerecord() {
            console.log('Re-record button clicked');
            const button = rerecordBtn;
            button.classList.add('loading');
            button.disabled = true;
            
            try {
                const response = await fetch(`${API_BASE_URL}/api/control/rerecord`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                const result = await response.json();
                if (result.status === 'success') {
                    console.log('‚úÖ Re-record episode triggered successfully');
                } else {
                    console.error('‚ùå Failed to trigger re-record:', result.message);
                }
            } catch (error) {
                console.error('‚ùå Error triggering re-record:', error);
            } finally {
                button.classList.remove('loading');
                button.disabled = false;
            }
        }
        
        async function handleStop() {
            console.log('Stop button clicked');
            const button = stopBtn;
            button.classList.add('loading');
            button.disabled = true;
            
            try {
                const response = await fetch(`${API_BASE_URL}/api/control/stop`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                const result = await response.json();
                if (result.status === 'success') {
                    console.log('‚úÖ Stop recording triggered successfully');
                } else {
                    console.error('‚ùå Failed to trigger stop:', result.message);
                }
            } catch (error) {
                console.error('‚ùå Error triggering stop:', error);
            } finally {
                button.classList.remove('loading');
                button.disabled = false;
            }
        }
        
        // Event listeners
        fastForwardBtn.addEventListener('click', handleFastForward);
        rerecordBtn.addEventListener('click', handleRerecord);
        stopBtn.addEventListener('click', handleStop);
        
        // Initialize
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('Data Collection Monitor initialized');
            await initializeApiUrl(); // Initialize API URL first
            
            // Set up scroll detection for episode charts container
            episodeChartsContainer.addEventListener('scroll', function() {
                userIsScrolling = true;
                
                // Clear any existing timeout
                if (scrollTimeout) {
                    clearTimeout(scrollTimeout);
                }
                
                // Reset scroll state after user stops scrolling for 3 seconds
                scrollTimeout = setTimeout(() => {
                    userIsScrolling = false;
                }, 3000);
            });
            
            // Initial fetch of episode data with force refresh
            await fetchPendingStatesInfo(); // Initial episode data fetch
            fetchLatestState(); // Initial fetch for latest state info
            
            startAutoRefresh(); // Start auto-refresh immediately
            
            // Additional force refresh after a short delay to ensure everything is loaded
            setTimeout(async () => {
                console.log('üîÑ Force refreshing charts after page load...');
                await fetchPendingStatesInfo(); // Force another refresh
            }, 500);
        });
        
        // Handle page visibility changes to pause/resume auto-refresh
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                console.log('Page hidden, pausing auto-refresh');
                stopAutoRefresh();
            } else {
                console.log('Page visible, resuming auto-refresh');
                startAutoRefresh();
            }
        });
    </script>
</body>
</html>
