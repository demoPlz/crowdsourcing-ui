<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Collection Monitor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f8fafc;
            height: 100vh;
            overflow: hidden;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            gap: 20px;
            padding: 20px;
        }
        
        .top-section {
            display: flex;
            gap: 20px;
        }
        
        .camera-section {
            flex: 3;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            padding: 20px;
        }
        
        .status-control-column {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .status-section {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .control-section {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .main-content {
            display: flex;
            flex: 1;
            gap: 20px;
            min-height: 0;
        }
        
        .left-panel {
            flex: 2;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            padding: 20px;
            display: flex;
            flex-direction: column;
        }
        
        .right-panel {
            flex: 1;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .panel-header {
            border-bottom: 2px solid #e2e8f0;
            padding-bottom: 16px;
            margin-bottom: 20px;
        }
        
        .panel-header h2 {
            color: #1e293b;
            font-size: 24px;
            font-weight: 600;
        }
        
        .camera-views {
            width: 100%;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 12px;
            height: 400px;
        }
        
        .camera-view {
            background: #f1f5f9;
            border-radius: 4px;
            border: 1px solid #e2e8f0;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            transition: all 0.2s ease;
        }
        
        .camera-view:hover {
            border-color: #3b82f6;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.15);
        }
        
        .camera-image {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 3px;
        }
        
        .camera-placeholder {
            color: #64748b;
            font-size: 10px;
            text-align: center;
            padding: 8px;
        }
        
        .status-card {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 16px;
        }
        
        .status-card h3 {
            color: #1e293b;
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 12px;
        }
        
        .status-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #e2e8f0;
        }
        
        .status-item:last-child {
            border-bottom: none;
        }
        
        .status-label {
            color: #64748b;
            font-size: 14px;
        }
        
        .status-value {
            color: #1e293b;
            font-weight: 500;
            font-size: 14px;
        }
        
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }
        
        .status-indicator.connected {
            background: #10b981;
            box-shadow: 0 0 8px rgba(16, 185, 129, 0.4);
        }
        
        .status-indicator.disconnected {
            background: #ef4444;
            box-shadow: 0 0 8px rgba(239, 68, 68, 0.4);
        }
        
        .status-indicator.warning {
            background: #f59e0b;
            box-shadow: 0 0 8px rgba(245, 158, 11, 0.4);
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #1d4ed8);
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        
        .robot-state {
            padding: 12px;
            border-radius: 6px;
            font-weight: 500;
            text-align: center;
            margin: 8px 0;
        }
        
        .robot-state.moving {
            background: #fef3c7;
            color: #92400e;
            border: 1px solid #fcd34d;
        }
        
        .robot-state.stationary {
            background: #d1fae5;
            color: #065f46;
            border: 1px solid #6ee7b7;
        }
        
        .robot-state.async-collection {
            background: #e0e7ff;
            color: #3730a3;
            border: 1px solid #a5b4fc;
            animation: pulse 2s infinite;
        }
        
        .robot-state.resetting {
            background: #fef3c7;
            color: #92400e;
            border: 1px solid #fcd34d;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .error-message {
            background: #fef2f2;
            border: 1px solid #fecaca;
            color: #dc2626;
            padding: 12px;
            border-radius: 6px;
            font-size: 14px;
            text-align: center;
        }
        
        .control-buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .control-button {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 12px 16px;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .control-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 16px rgba(0,0,0,0.15);
        }
        
        .control-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .control-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .control-button.loading {
            opacity: 0.7;
            cursor: wait;
        }
        
        .fast-forward-btn {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            color: white;
        }
        
        .fast-forward-btn:hover {
            background: linear-gradient(135deg, #2563eb, #1e40af);
        }
        
        .rerecord-btn {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: white;
        }
        
        .rerecord-btn:hover {
            background: linear-gradient(135deg, #e3a008, #c2701a);
        }
        
        .stop-btn {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
        }
        
        .stop-btn:hover {
            background: linear-gradient(135deg, #dc2626, #b91c1c);
        }
        
        .control-icon {
            font-size: 20px;
        }
        
        /* Episode Charts Styles */
        .episode-charts-container {
            max-height: calc(100vh - 200px);
            overflow-y: auto;
            padding-right: 8px;
        }
        
        .episode-chart {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
            transition: all 0.2s ease;
        }
        
        .episode-chart:hover {
            border-color: #3b82f6;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.15);
        }
        
        .episode-chart.current {
            border-color: #10b981;
            background: #f0fdf4;
            box-shadow: 0 2px 8px rgba(16, 185, 129, 0.15);
        }
        
        .episode-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .episode-title {
            font-weight: 600;
            font-size: 14px;
            color: #1e293b;
        }
        
        .episode-stats {
            font-size: 12px;
            color: #64748b;
        }
        
        .chart-container {
            position: relative;
            height: 80px;
            background: white;
            border-radius: 4px;
            border: 1px solid #e2e8f0;
            overflow: hidden;
        }
        
        .chart-bars {
            display: flex;
            height: calc(100% - 26px);
            align-items: end;
            padding: 0px 8px 16px 8px;
            gap: 1px;
            overflow-x: auto;
            overflow-y: hidden;
            width: calc(100% - 40px);
            position: absolute;
            top: 10px;
            left: 32px;
            scrollbar-width: thin;
        }
        
        .state-bar-container {
            flex: 1;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: end;
            position: relative;
            min-width: 2px;
            max-width: 20px;
        }
        
        .state-bar {
            background: linear-gradient(180deg, #10b981, #059669);
            border-radius: 2px 2px 0 0;
            transition: height 0.3s ease;
            position: relative;
            min-height: 2px;
            width: 100%;
        }
        
        .state-bar.empty {
            background: #e2e8f0;
            height: 100% !important;
        }
        
        .state-bar.important-complete {
            background: linear-gradient(180deg, #dc2626, #991b1b) !important;
        }
        
        .state-bar.important-incomplete {
            background: linear-gradient(180deg, #f87171, #dc2626) !important;
        }
        
        .state-bar.regular-complete {
            background: linear-gradient(180deg, #2563eb, #1d4ed8) !important;
        }
        
        .state-bar.regular-incomplete {
            background: linear-gradient(180deg, #60a5fa, #2563eb) !important;
        }
        
        .state-bar-label {
            position: absolute;
            bottom: -16px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: #64748b;
            white-space: nowrap;
        }
        
        .chart-y-axis {
            position: absolute;
            left: 0;
            top: 10px;
            bottom: 16px;
            width: 32px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 0px 4px 0px 4px;
            background: rgba(248, 250, 252, 0.9);
            border-right: 1px solid #e2e8f0;
        }
        
        .y-axis-label {
            font-size: 10px;
            color: #64748b;
            text-align: center;
        }
        
        .chart-x-axis {
            position: absolute;
            bottom: 0;
            left: 32px;
            right: 8px;
            height: 16px;
            display: flex;
            align-items: center;
            padding: 0 8px;
            background: rgba(248, 250, 252, 0.9);
            border-top: 1px solid #e2e8f0;
            font-size: 10px;
            color: #64748b;
        }
        
        /* Scrollbar styling for chart bars */
        .chart-bars::-webkit-scrollbar {
            height: 4px;
        }
        
        .chart-bars::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 2px;
        }
        
        .chart-bars::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 2px;
        }
        
        .chart-bars::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }
        
        /* Scrollbar styling */
        .episode-charts-container::-webkit-scrollbar {
            width: 6px;
        }
        
        .episode-charts-container::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 3px;
        }
        
        .episode-charts-container::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 3px;
        }
        
        .episode-charts-container::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Top Section: Camera Views and Status/Control Column -->
        <div class="top-section">
            <!-- Camera Views -->
            <div class="camera-section">
                <div class="camera-views">
                    <div class="camera-view" id="camera-front">
                        <div class="camera-placeholder">No image</div>
                    </div>
                    <div class="camera-view" id="camera-left">
                        <div class="camera-placeholder">No image</div>
                    </div>
                    <div class="camera-view" id="camera-right">
                        <div class="camera-placeholder">No image</div>
                    </div>
                    <div class="camera-view" id="camera-perspective">
                        <div class="camera-placeholder">No image</div>
                    </div>
                </div>
            </div>
            
            <!-- Status and Control Column -->
            <div class="status-control-column">
                <!-- System Status -->
                <div class="status-section">
                    <!-- Connection Status -->
                    <div class="status-card">
                        <div class="status-item">
                            <span class="status-label">Backend Server</span>
                            <span class="status-value" id="server-status">
                                <span class="status-indicator disconnected"></span>
                                Checking...
                            </span>
                        </div>
                    </div>
                    
                    <!-- Robot Status -->
                    <div class="status-card">
                        <div class="robot-state stationary" id="robot-state">
                            üõë Robot Status Unknown
                        </div>
                        <div class="status-item">
                            <span class="status-label">Current State ID</span>
                            <span class="status-value" id="current-state-id">--</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">State Type</span>
                            <span class="status-value" id="state-type">--</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">Responses</span>
                            <span class="status-value" id="state-responses">--</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">Pending States</span>
                            <span class="status-value" id="pending-states-count">--</span>
                        </div>
                    </div>
                </div>
                
                <!-- Control Panel -->
                <div class="control-section">
                    <div class="control-buttons">
                        <button class="control-button fast-forward-btn" id="fast-forward-btn">
                            <span class="control-icon">‚è©</span>
                            Next Episode
                        </button>
                        
                        <button class="control-button rerecord-btn" id="rerecord-btn">
                            <span class="control-icon">üîÑ</span>
                            Re-record Episode
                        </button>
                        
                        <button class="control-button stop-btn" id="stop-btn">
                            <span class="control-icon">‚èπÔ∏è</span>
                            Stop Recording
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Main Content Area -->
        <div class="main-content">
            <!-- Episode Progress Charts (full width) -->
            <div class="left-panel" style="flex: 1;">
                <div class="episode-charts-container" id="episode-charts-container">
                    <!-- Episode charts will be dynamically added here -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // Simple API Configuration - use appropriate proxy based on environment
        async function getCurrentCloudflaredUrl() {
            try {
                // For production (Netlify), always use the function proxy to avoid CORS issues
                if (location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
                    return '/.netlify/functions/api';
                }
                
                // For local development, try to get the actual cloudflared URL from Netlify function
                // This only works if running netlify dev, otherwise fallback to hardcoded URL
                try {
                    const response = await fetch('/.netlify/functions/get-backend-url');
                    if (response.ok) {
                        const data = await response.json();
                        return data.backend_url;
                    }
                } catch (netlifyError) {
                    // Netlify functions not available (running on pure Vite dev server)
                    console.log('Netlify functions not available, using fallback Tailscale URL');
                }
                
                // Fallback to hardcoded Tailscale URL for local development
                return 'https://ztclab-1.tail503d36.ts.net';
            } catch (error) {
                console.error('Error getting backend URL:', error);
                // Fallback based on environment
                if (location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
                    return '/.netlify/functions/api'; // Use proxy for production
                }
                return 'https://reconstruction-parker-put-push.trycloudflare.com'; // Direct for local dev
            }
        }

        // Initialize API_BASE_URL - will be set dynamically
        let API_BASE_URL = '/.netlify/functions/api'; // Default to proxy

        // Set API_BASE_URL dynamically based on environment
        async function initializeApiUrl() {
            if (location.hostname === 'localhost' || location.hostname === '127.0.0.1') {
                if (location.port === '5173' || location.port === '5174') {
                    // Running on Vite dev server - get direct cloudflared URL
                    API_BASE_URL = await getCurrentCloudflaredUrl();
                    console.log('[DEBUG] Monitor using direct cloudflared URL for Vite dev server:', API_BASE_URL);
                } else {
                    // Running on production build locally
                    API_BASE_URL = 'http://127.0.0.1:9000';
                }
            } else {
                // Running on deployed Netlify - use function proxy to avoid CORS
                API_BASE_URL = '/.netlify/functions/api';
                console.log('[DEBUG] Monitor using Netlify function proxy for production:', API_BASE_URL);
            }
        }

        // Configuration
        let autoRefreshInterval = null;
        
        // DOM elements
        const serverStatus = document.getElementById('server-status');
        const robotState = document.getElementById('robot-state');
        const currentStateId = document.getElementById('current-state-id');
        const stateType = document.getElementById('state-type');
        const stateResponses = document.getElementById('state-responses');
        const pendingStatesCount = document.getElementById('pending-states-count');
        
        // Control button elements
        const fastForwardBtn = document.getElementById('fast-forward-btn');
        const rerecordBtn = document.getElementById('rerecord-btn');
        const stopBtn = document.getElementById('stop-btn');
        
        // Camera view elements
        const cameraViews = {
            front: document.getElementById('camera-front'),
            left: document.getElementById('camera-left'),
            right: document.getElementById('camera-right'),
            perspective: document.getElementById('camera-perspective')
        };
        
        // Episode charts management
        const episodeChartsContainer = document.getElementById('episode-charts-container');
        let episodes = []; // Array of episode data
        let REQUIRED_RESPONSES_PER_STATE = 1; // Will be updated from API
        let REQUIRED_RESPONSES_PER_IMPORTANT_STATE = 10; // Will be updated from API

        // Remove episodes that the backend no longer reports (they've been fully completed and pruned)
        function pruneMissingEpisodes(presentIds) {
            const present = new Set(presentIds);
            // Filter the local array and remove corresponding DOM nodes
            episodes = episodes.filter(ep => {
                if (!present.has(ep.id)) {
                    const el = document.getElementById(`episode-${ep.id}`);
                    if (el) el.remove();
                    return false;
                }
                return true;
            });
            // After pruning, refresh the "current" marker
            updateCurrentEpisodeIndicator();
        }
        
        // Update server status indicator
        function updateServerStatus(connected) {
            const indicator = serverStatus.querySelector('.status-indicator');
            if (connected) {
                indicator.className = 'status-indicator connected';
                serverStatus.innerHTML = '<span class="status-indicator connected"></span>Connected';
            } else {
                indicator.className = 'status-indicator disconnected';
                serverStatus.innerHTML = '<span class="status-indicator disconnected"></span>Disconnected';
            }
        }
        
        // Update camera view
        function updateCameraView(cameraName, imageDataUrl) {
            const cameraView = cameraViews[cameraName];
            if (!cameraView) return;
            
            if (imageDataUrl && imageDataUrl.startsWith('data:image/')) {
                cameraView.innerHTML = `<img src="${imageDataUrl}" alt="${cameraName} camera" class="camera-image">`;
            } else {
                cameraView.innerHTML = '<div class="camera-placeholder">No image</div>';
            }
        }
        
        // Update robot state
        function updateRobotState(isMoving, isResetting, resetCountdown, isAsyncCollection) {
            if (isResetting) {
                robotState.className = 'robot-state resetting';
                const countdownText = resetCountdown > 0 ? ` (${Math.ceil(resetCountdown)}s)` : '';
                robotState.textContent = `üîÑ Resetting Environment${countdownText}`;
            } else if (isAsyncCollection) {
                robotState.className = 'robot-state async-collection';
                robotState.textContent = 'üîÑ Asynchronous Data Collection';
            } else if (isMoving) {
                robotState.className = 'robot-state moving';
                robotState.textContent = 'üèÉ Robot Moving';
            } else {
                robotState.className = 'robot-state stationary';
                robotState.textContent = 'üõë Robot Stationary';
            }
        }
        
        // Update control buttons based on reset state
        function updateControlButtons(isResetting) {
            if (isResetting) {
                // Change "Next Episode" to "Start Episode" during reset
                fastForwardBtn.innerHTML = '<span class="control-icon">‚ñ∂Ô∏è</span>Start Episode';
                fastForwardBtn.title = 'Skip remaining reset time and start episode immediately';
            } else {
                // Normal "Next Episode" button
                fastForwardBtn.innerHTML = '<span class="control-icon">‚è©</span>Next Episode';
                fastForwardBtn.title = 'Finish current episode and move to next';
            }
        }
        
        // Update joint positions display
        function updateJointPositions(joints) {
            // Function removed - joint positions panel no longer exists
        }
        
        // Episode Chart Management - Episodes are now managed by the backend
        
        function createEpisodeChartElement(episode) {
            const episodeDiv = document.createElement('div');
            episodeDiv.className = 'episode-chart';
            episodeDiv.id = `episode-${episode.id}`;
            
            if (episode.isCurrentServing) {
                episodeDiv.classList.add('current');
            }
            
            episodeDiv.innerHTML = `
                <div class="episode-header">
                    <div class="episode-title">Episode ${episode.id}</div>
                    <div class="episode-stats" id="episode-${episode.id}-stats">
                        ${Object.keys(episode.states).length} states, 0 responses
                    </div>
                </div>
                <div class="chart-container">
                    <div class="chart-y-axis">
                        <div class="y-axis-label">${REQUIRED_RESPONSES_PER_IMPORTANT_STATE}</div>
                        <div class="y-axis-label">${Math.floor(REQUIRED_RESPONSES_PER_IMPORTANT_STATE / 2)}</div>
                        <div class="y-axis-label">0</div>
                    </div>
                    <div class="chart-bars" id="episode-${episode.id}-bars"></div>
                    <div class="chart-x-axis">State IDs</div>
                </div>
            `;
            
            episodeChartsContainer.appendChild(episodeDiv);
        }
        
        function updateEpisodeChart(episodeId, stateId, responsesReceived, isImportant, forceRefresh = false) {
            // Find the episode by ID
            const episode = episodes.find(ep => ep.id === episodeId);
            if (!episode) return;
            
            // Update episode data with importance information (skip if force refresh)
            if (!forceRefresh && stateId !== null) {
                episode.states[stateId] = {
                    responses: responsesReceived,
                    isImportant: isImportant || false
                };
                episode.maxStates = Math.max(episode.maxStates, Object.keys(episode.states).length);
                
                const stateType = isImportant ? "IMPORTANT" : "regular";
                console.log(`üìä Updating chart for episode ${episodeId}, state ${stateId} (${stateType}), responses: ${responsesReceived}`);
            }
            
            // Get the bars container
            const barsContainer = document.getElementById(`episode-${episodeId}-bars`);
            if (!barsContainer) {
                console.warn(`üìä Bars container not found for episode ${episodeId}`);
                return;
            }
            
            // Clear existing bars
            barsContainer.innerHTML = '';
            
            // Create bars for all states in this episode
            const stateIds = Object.keys(episode.states).sort((a, b) => parseInt(a) - parseInt(b));
            
            if (stateIds.length === 0) {
                console.log(`üìä No states found for episode ${episodeId}`);
                return;
            }
            
            // Force container to have width if it's 0 (common on page load)
            if (barsContainer.clientWidth === 0) {
                barsContainer.style.width = '200px'; // Fallback width
            }
            
            // Calculate the optimal width for each bar based on available space
            const containerWidth = barsContainer.clientWidth || 200; // fallback width
            const padding = 16; // total horizontal padding
            const gapWidth = 1; // gap between bars
            const availableWidth = containerWidth - padding;
            const totalGapWidth = Math.max(0, (stateIds.length - 1) * gapWidth);
            const barWidth = Math.max(2, Math.min(20, (availableWidth - totalGapWidth) / stateIds.length));
            
            console.log(`üìä Creating ${stateIds.length} bars for episode ${episodeId}, container width: ${containerWidth}, bar width: ${barWidth}`);
            
            stateIds.forEach((stateId, index) => {
                const stateData = episode.states[stateId];
                const responses = stateData.responses;
                const isImportant = stateData.isImportant;
                const requiredResponses = isImportant ? REQUIRED_RESPONSES_PER_IMPORTANT_STATE : REQUIRED_RESPONSES_PER_STATE;
                
                const barContainer = document.createElement('div');
                barContainer.className = 'state-bar-container';
                barContainer.style.width = `${barWidth}px`;
                barContainer.style.flex = 'none'; // Override flex: 1 to use fixed width
                
                const bar = document.createElement('div');
                bar.className = 'state-bar';
                
                if (responses === 0) {
                    bar.classList.add('empty');
                    bar.style.height = '100%'; // Empty bars take full height but are grayed out
                } else {
                    // Calculate height based on percentage of required responses fulfilled
                    const completionPercent = Math.min((responses / requiredResponses) * 100, 100);
                    bar.style.height = `${completionPercent}%`;
                    
                    // Color code based on state type and completion
                    if (isImportant) {
                        if (responses >= requiredResponses) {
                            bar.style.background = 'linear-gradient(180deg, #dc2626, #991b1b)'; // Red - important complete
                        } else {
                            bar.style.background = 'linear-gradient(180deg, #f87171, #dc2626)'; // Light red - important incomplete
                        }
                    } else {
                        if (responses >= requiredResponses) {
                            bar.style.background = 'linear-gradient(180deg, #2563eb, #1d4ed8)'; // Blue - regular complete
                        } else {
                            bar.style.background = 'linear-gradient(180deg, #60a5fa, #2563eb)'; // Light blue - regular incomplete
                        }
                    }
                }
                
                // Add tooltip with percentage information
                const completionPercent = Math.min((responses / requiredResponses) * 100, 100);
                barContainer.title = `State ${stateId}: ${responses}/${requiredResponses} responses (${completionPercent.toFixed(1)}% complete, ${isImportant ? 'Important' : 'Regular'})`;
                
                barContainer.appendChild(bar);
                barsContainer.appendChild(barContainer);
            });
            
            // Update episode stats
            const statsElement = document.getElementById(`episode-${episodeId}-stats`);
            if (statsElement) {
                const totalResponses = Object.values(episode.states).reduce((sum, data) => sum + data.responses, 0);
                const stateCount = Object.keys(episode.states).length;
                const importantCount = Object.values(episode.states).filter(data => data.isImportant).length;
                const regularCount = stateCount - importantCount;
                statsElement.textContent = `${stateCount} states (üî¥${importantCount} üîµ${regularCount}), ${totalResponses} responses`;
            }
            
            // Check if episode is complete
            const allStatesComplete = Object.values(episode.states).every(data => {
                const requiredResponses = data.isImportant ? REQUIRED_RESPONSES_PER_IMPORTANT_STATE : REQUIRED_RESPONSES_PER_STATE;
                return data.responses >= requiredResponses;
            });
            if (allStatesComplete && stateIds.length > 0) {
                episode.isComplete = true;
                const episodeElement = document.getElementById(`episode-${episodeId}`);
                if (episodeElement) {
                    episodeElement.classList.add('complete');
                }
            }
        }
        
        function updateCurrentEpisodeIndicator() {
            // Remove current class from all episodes
            document.querySelectorAll('.episode-chart').forEach(chart => {
                chart.classList.remove('current');
            });
            
            // Find the current serving episode and add current class
            const currentEpisode = episodes.find(ep => ep.isCurrentServing);
            if (currentEpisode) {
                const currentChart = document.getElementById(`episode-${currentEpisode.id}`);
                if (currentChart) {
                    currentChart.classList.add('current');
                    // Scroll to current episode
                    currentChart.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            }
        }
        
        function processMonitoringData(data) {
            // Update response requirements from the data if available
            if (data.required_responses_per_state) {
                REQUIRED_RESPONSES_PER_STATE = data.required_responses_per_state;
            }
            if (data.required_responses_per_important_state) {
                REQUIRED_RESPONSES_PER_IMPORTANT_STATE = data.required_responses_per_important_state;
            }
            
            // Process episode-based data structure
            if (data.episodes) {
                console.log(`üìà Processing episodes data:`, data.episodes);

                // First, drop any episodes that the backend no longer reports (they're done)
                pruneMissingEpisodes(Object.keys(data.episodes));
                
                // Process each episode
                Object.entries(data.episodes).forEach(([episodeId, episodeData]) => {
                    let episodeIndex = episodes.findIndex(ep => ep.id === episodeId);
                    
                    // Create episode if it doesn't exist
                    if (episodeIndex === -1) {
                        const newEpisode = {
                            index: episodes.length,
                            id: episodeId,
                            states: {},
                            maxStates: 0,
                            isComplete: episodeData.is_completed || false,
                            isCurrentServing: episodeData.is_current_serving || false
                        };
                        episodes.push(newEpisode);
                        createEpisodeChartElement(newEpisode);
                        episodeIndex = newEpisode.index;
                    }
                    
                    const episode = episodes[episodeIndex];
                    
                    // Update episode properties
                    episode.isComplete = episodeData.is_completed || false;
                    episode.isCurrentServing = episodeData.is_current_serving || false;
                    
                    // Process states in this episode
                    if (episodeData.states) {
                        Object.entries(episodeData.states).forEach(([stateIdStr, stateInfo]) => {
                            const stateId = parseInt(stateIdStr);
                            const responsesReceived = stateInfo.responses_received || 0;
                            const isImportant = stateInfo.is_important || false;
                            
                            console.log(`üìä Processing state ${stateId} in episode ${episodeId} (responses: ${responsesReceived}, important: ${isImportant})`);
                            updateEpisodeChart(episodeId, stateId, responsesReceived, isImportant);
                        });
                    }
                    
                    // Update episode title to show current serving status
                    const episodeElement = document.getElementById(`episode-${episodeId}`);
                    if (episodeElement) {
                        const titleElement = episodeElement.querySelector('.episode-title');
                        if (titleElement) {
                            let title = `Episode ${episodeId}`;
                            if (episode.isCurrentServing) {
                                title += ' (Current)';
                            }
                            if (episode.isComplete) {
                                title += ' (Complete)';
                            }
                            titleElement.textContent = title;
                        }
                        
                        // Add visual indicator for current serving episode
                        if (episode.isCurrentServing) {
                            episodeElement.classList.add('current');
                        } else {
                            episodeElement.classList.remove('current');
                        }
                        
                        // Add visual indicator for completed episodes
                        if (episode.isComplete) {
                            episodeElement.classList.add('complete');
                        }
                    }
                });
                
                // Update current episode indicator
                updateCurrentEpisodeIndicator();
            } else {
                console.log(`‚ö†Ô∏è  No episodes data in response:`, data);
            }
        }
        
        // Fetch latest state from monitoring endpoint
        async function fetchLatestState() {
            try {
                console.log('Fetching latest state from:', `${API_BASE_URL}/api/monitor/latest-state`);
                    const response = await fetch(`${API_BASE_URL}/api/monitor/latest-state`, {
                        headers: {
                            'Accept': 'application/json'
                        }
                    });                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('Received monitoring data:', data);
                
                // Update server status
                updateServerStatus(true);
                
                if (data.status === 'success') {
                    // Update camera views
                    if (data.views) {
                        for (const [cameraName, imageDataUrl] of Object.entries(data.views)) {
                            updateCameraView(cameraName, imageDataUrl);
                        }
                    }
                    
                    // Update status information
                    currentStateId.textContent = data.state_id || '--';
                    
                    // Update state type and response information
                    if (data.is_important !== undefined) {
                        stateType.textContent = data.is_important ? 'üî¥ Important' : 'üîµ Regular';
                        const required = data.is_important ? REQUIRED_RESPONSES_PER_IMPORTANT_STATE : REQUIRED_RESPONSES_PER_STATE;
                        const received = data.responses_received || 0;
                        stateResponses.textContent = `${received}/${required}`;
                    } else {
                        stateType.textContent = '--';
                        stateResponses.textContent = '--';
                    }
                    
                    // Update robot state
                    updateRobotState(data.robot_moving, data.is_resetting, data.reset_countdown, data.is_async_collection);
                    
                    // Update control button based on reset state
                    updateControlButtons(data.is_resetting);
                    
                    // Update pending states count
                    if (data.total_pending_states !== undefined) {
                        pendingStatesCount.textContent = data.total_pending_states;
                    } else {
                        pendingStatesCount.textContent = '--';
                    }
                    
                } else if (data.status === 'no_states' || data.status === 'no_pending_states') {
                    console.log('No pending states available');
                    currentStateId.textContent = 'No states';
                    stateType.textContent = '--';
                    stateResponses.textContent = '--';
                    pendingStatesCount.textContent = '0';
                    
                    // Clear camera views
                    for (const cameraName of Object.keys(cameraViews)) {
                        updateCameraView(cameraName, null);
                    }
                }
                
            } catch (error) {
                console.error('Error fetching latest state:', error);
                updateServerStatus(false);
            }
        }
        
        // Fetch pending states info for episode tracking
        async function fetchPendingStatesInfo() {
            try {
                const response = await fetch(`${API_BASE_URL}/api/pending-states-info`, {
                    headers: {
                        'Accept': 'application/json'
                    }
                });
                if (response.ok) {
                    const data = await response.json();
                    processMonitoringData(data);
                    
                    // Update the pending states count in the DOM
                    if (pendingStatesCount) {
                        pendingStatesCount.textContent = data.total_pending || 0;
                    }
                    
                    // Force refresh all episode charts after data update (especially on first load)
                    setTimeout(() => {
                        episodes.forEach(episode => {
                            if (Object.keys(episode.states).length > 0) {
                                updateEpisodeChart(episode.id, null, null, null, true); // Force refresh
                            }
                        });
                    }, 50);
                }
            } catch (error) {
                console.error('Error fetching pending states info:', error);
            }
        }
        
        // Auto-refresh function (always enabled at 30 FPS)
        function startAutoRefresh() {
            autoRefreshInterval = setInterval(async () => {
                await fetchLatestState();
                await fetchPendingStatesInfo(); // Ensure chart updates happen every frame
            }, 33); // 33ms = 30 FPS
            console.log('Auto-refresh started (30 FPS)');
        }
        
        function stopAutoRefresh() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
                console.log('Auto-refresh stopped');
            }
        }
        
        // Control button handlers
        async function handleFastForward() {
            const buttonText = fastForwardBtn.textContent;
            const isStartEpisode = buttonText.includes('Start Episode');
            
            console.log(isStartEpisode ? 'Start Episode button clicked' : 'Next Episode button clicked');
            const button = fastForwardBtn;
            button.classList.add('loading');
            button.disabled = true;
            
            try {
                const endpoint = isStartEpisode ? '/api/control/start-episode' : '/api/control/next-episode';
                const response = await fetch(`${API_BASE_URL}${endpoint}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                const result = await response.json();
                if (result.status === 'success') {
                    const action = isStartEpisode ? 'episode start' : 'next episode';
                    console.log(`‚úÖ ${action} triggered successfully`);
                    
                    // The new episode will be automatically detected on the next data fetch
                    // No need to manually create episode charts since backend manages episodes
                    
                } else {
                    const action = isStartEpisode ? 'start episode' : 'trigger next episode';
                    console.error(`‚ùå Failed to ${action}:`, result.message);
                }
            } catch (error) {
                const action = isStartEpisode ? 'starting episode' : 'triggering next episode';
                console.error(`‚ùå Error ${action}:`, error);
            } finally {
                button.classList.remove('loading');
                button.disabled = false;
            }
        }
        
        async function handleRerecord() {
            console.log('Re-record button clicked');
            const button = rerecordBtn;
            button.classList.add('loading');
            button.disabled = true;
            
            try {
                const response = await fetch(`${API_BASE_URL}/api/control/rerecord`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                const result = await response.json();
                if (result.status === 'success') {
                    console.log('‚úÖ Re-record episode triggered successfully');
                } else {
                    console.error('‚ùå Failed to trigger re-record:', result.message);
                }
            } catch (error) {
                console.error('‚ùå Error triggering re-record:', error);
            } finally {
                button.classList.remove('loading');
                button.disabled = false;
            }
        }
        
        async function handleStop() {
            console.log('Stop button clicked');
            const button = stopBtn;
            button.classList.add('loading');
            button.disabled = true;
            
            try {
                const response = await fetch(`${API_BASE_URL}/api/control/stop`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                const result = await response.json();
                if (result.status === 'success') {
                    console.log('‚úÖ Stop recording triggered successfully');
                } else {
                    console.error('‚ùå Failed to trigger stop:', result.message);
                }
            } catch (error) {
                console.error('‚ùå Error triggering stop:', error);
            } finally {
                button.classList.remove('loading');
                button.disabled = false;
            }
        }
        
        // Event listeners
        fastForwardBtn.addEventListener('click', handleFastForward);
        rerecordBtn.addEventListener('click', handleRerecord);
        stopBtn.addEventListener('click', handleStop);
        
        // Initialize
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('Data Collection Monitor initialized');
            await initializeApiUrl(); // Initialize API URL first
            
            // Initial fetch of episode data with force refresh
            await fetchPendingStatesInfo(); // Initial episode data fetch
            fetchLatestState(); // Initial fetch for latest state info
            
            startAutoRefresh(); // Start auto-refresh immediately
            
            // Additional force refresh after a short delay to ensure everything is loaded
            setTimeout(async () => {
                console.log('üîÑ Force refreshing charts after page load...');
                await fetchPendingStatesInfo(); // Force another refresh
            }, 500);
        });
        
        // Handle page visibility changes to pause/resume auto-refresh
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                console.log('Page hidden, pausing auto-refresh');
                stopAutoRefresh();
            } else {
                console.log('Page visible, resuming auto-refresh');
                startAutoRefresh();
            }
        });
    </script>
</body>
</html>
