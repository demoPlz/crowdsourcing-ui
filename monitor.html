<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Collection Monitor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f8fafc;
            height: 100vh;
            overflow: hidden;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            gap: 20px;
            padding: 20px;
        }
        
        .top-section {
            display: flex;
            gap: 20px;
        }
        
        .camera-section {
            flex: 3;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            padding: 20px;
        }
        
        .status-control-column {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .status-section {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .control-section {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .main-content {
            display: flex;
            flex: 1;
            gap: 20px;
            min-height: 0;
        }
        
        .left-panel {
            flex: 2;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            padding: 20px;
            display: flex;
            flex-direction: column;
        }
        
        .right-panel {
            flex: 1;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .panel-header {
            border-bottom: 2px solid #e2e8f0;
            padding-bottom: 16px;
            margin-bottom: 20px;
        }
        
        .panel-header h2 {
            color: #1e293b;
            font-size: 24px;
            font-weight: 600;
        }
        
        .camera-views {
            width: 100%;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 12px;
            height: 400px;
        }
        
        .camera-view {
            background: #f1f5f9;
            border-radius: 4px;
            border: 1px solid #e2e8f0;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            transition: all 0.2s ease;
        }
        
        .camera-view:hover {
            border-color: #3b82f6;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.15);
        }
        
        .camera-image {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 3px;
        }
        
        .camera-placeholder {
            color: #64748b;
            font-size: 10px;
            text-align: center;
            padding: 8px;
        }
        
        .status-card {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 16px;
        }
        
        .status-card h3 {
            color: #1e293b;
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 12px;
        }
        
        .status-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #e2e8f0;
        }
        
        .status-item:last-child {
            border-bottom: none;
        }
        
        .status-label {
            color: #64748b;
            font-size: 14px;
        }
        
        .status-value {
            color: #1e293b;
            font-weight: 500;
            font-size: 14px;
        }
        
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }
        
        .status-indicator.connected {
            background: #10b981;
            box-shadow: 0 0 8px rgba(16, 185, 129, 0.4);
        }
        
        .status-indicator.disconnected {
            background: #ef4444;
            box-shadow: 0 0 8px rgba(239, 68, 68, 0.4);
        }
        
        .status-indicator.warning {
            background: #f59e0b;
            box-shadow: 0 0 8px rgba(245, 158, 11, 0.4);
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #1d4ed8);
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        
        .robot-state {
            padding: 12px;
            border-radius: 6px;
            font-weight: 500;
            text-align: center;
            margin: 8px 0;
        }
        
        .robot-state.moving {
            background: #fef3c7;
            color: #92400e;
            border: 1px solid #fcd34d;
        }
        
        .robot-state.stationary {
            background: #d1fae5;
            color: #065f46;
            border: 1px solid #6ee7b7;
        }
        
        .error-message {
            background: #fef2f2;
            border: 1px solid #fecaca;
            color: #dc2626;
            padding: 12px;
            border-radius: 6px;
            font-size: 14px;
            text-align: center;
        }
        
        .control-buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .control-button {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 12px 16px;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .control-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 16px rgba(0,0,0,0.15);
        }
        
        .control-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .control-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .control-button.loading {
            opacity: 0.7;
            cursor: wait;
        }
        
        .fast-forward-btn {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            color: white;
        }
        
        .fast-forward-btn:hover {
            background: linear-gradient(135deg, #2563eb, #1e40af);
        }
        
        .rerecord-btn {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: white;
        }
        
        .rerecord-btn:hover {
            background: linear-gradient(135deg, #e3a008, #c2701a);
        }
        
        .stop-btn {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
        }
        
        .stop-btn:hover {
            background: linear-gradient(135deg, #dc2626, #b91c1c);
        }
        
        .control-icon {
            font-size: 20px;
        }
        
        /* Episode Charts Styles */
        .episode-charts-container {
            max-height: calc(100vh - 200px);
            overflow-y: auto;
            padding-right: 8px;
        }
        
        .episode-chart {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
            transition: all 0.2s ease;
        }
        
        .episode-chart:hover {
            border-color: #3b82f6;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.15);
        }
        
        .episode-chart.current {
            border-color: #10b981;
            background: #f0fdf4;
            box-shadow: 0 2px 8px rgba(16, 185, 129, 0.15);
        }
        
        .episode-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .episode-title {
            font-weight: 600;
            font-size: 14px;
            color: #1e293b;
        }
        
        .episode-stats {
            font-size: 12px;
            color: #64748b;
        }
        
        .chart-container {
            position: relative;
            height: 80px;
            background: white;
            border-radius: 4px;
            border: 1px solid #e2e8f0;
            overflow: hidden;
        }
        
        .chart-bars {
            display: flex;
            height: calc(100% - 10px);
            align-items: end;
            padding: 0px 8px 16px 24px;
            gap: 1px;
            overflow: hidden;
            width: calc(100% - 24px);
            position: absolute;
            top: 10px;
            left: 10px;
        }
        
        .state-bar-container {
            flex: 1;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: end;
            position: relative;
            min-width: 2px;
            max-width: 20px;
        }
        
        .state-bar {
            background: linear-gradient(180deg, #10b981, #059669);
            border-radius: 2px 2px 0 0;
            transition: height 0.3s ease;
            position: relative;
            min-height: 2px;
            width: 100%;
        }
        
        .state-bar.empty {
            background: #e2e8f0;
            height: 100% !important;
        }
        
        .state-bar-label {
            position: absolute;
            bottom: -16px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: #64748b;
            white-space: nowrap;
        }
        
        .chart-y-axis {
            position: absolute;
            left: 0;
            top: 10px;
            bottom: 16px;
            width: 24px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 0px 4px 0px 4px;
            background: rgba(248, 250, 252, 0.9);
            border-right: 1px solid #e2e8f0;
        }
        
        .y-axis-label {
            font-size: 10px;
            color: #64748b;
            text-align: center;
        }
        
        .chart-x-axis {
            position: absolute;
            bottom: 0;
            left: 24px;
            right: 0;
            height: 16px;
            display: flex;
            align-items: center;
            padding: 0 8px;
            background: rgba(248, 250, 252, 0.9);
            border-top: 1px solid #e2e8f0;
            font-size: 10px;
            color: #64748b;
        }
        
        /* Scrollbar styling */
        .episode-charts-container::-webkit-scrollbar {
            width: 6px;
        }
        
        .episode-charts-container::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 3px;
        }
        
        .episode-charts-container::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 3px;
        }
        
        .episode-charts-container::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Top Section: Camera Views and Status/Control Column -->
        <div class="top-section">
            <!-- Camera Views -->
            <div class="camera-section">
                <div class="camera-views">
                    <div class="camera-view" id="camera-front">
                        <div class="camera-placeholder">No image</div>
                    </div>
                    <div class="camera-view" id="camera-left">
                        <div class="camera-placeholder">No image</div>
                    </div>
                    <div class="camera-view" id="camera-right">
                        <div class="camera-placeholder">No image</div>
                    </div>
                    <div class="camera-view" id="camera-perspective">
                        <div class="camera-placeholder">No image</div>
                    </div>
                </div>
            </div>
            
            <!-- Status and Control Column -->
            <div class="status-control-column">
                <!-- System Status -->
                <div class="status-section">
                    <!-- Connection Status -->
                    <div class="status-card">
                        <div class="status-item">
                            <span class="status-label">Backend Server</span>
                            <span class="status-value" id="server-status">
                                <span class="status-indicator disconnected"></span>
                                Checking...
                            </span>
                        </div>
                    </div>
                    
                    <!-- Robot Status -->
                    <div class="status-card">
                        <div class="robot-state stationary" id="robot-state">
                            üõë Robot Status Unknown
                        </div>
                        <div class="status-item">
                            <span class="status-label">Current State ID</span>
                            <span class="status-value" id="current-state-id">--</span>
                        </div>
                    </div>
                </div>
                
                <!-- Control Panel -->
                <div class="control-section">
                    <div class="control-buttons">
                        <button class="control-button fast-forward-btn" id="fast-forward-btn">
                            <span class="control-icon">‚è©</span>
                            Next Episode
                        </button>
                        
                        <button class="control-button rerecord-btn" id="rerecord-btn">
                            <span class="control-icon">üîÑ</span>
                            Re-record Episode
                        </button>
                        
                        <button class="control-button stop-btn" id="stop-btn">
                            <span class="control-icon">‚èπÔ∏è</span>
                            Stop Recording
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Main Content Area -->
        <div class="main-content">
            <!-- Episode Progress Charts (full width) -->
            <div class="left-panel" style="flex: 1;">
                <div class="episode-charts-container" id="episode-charts-container">
                    <!-- Episode charts will be dynamically added here -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // Simple API Configuration - use appropriate proxy based on environment
        async function getCurrentNgrokUrl() {
            try {
                // For production (Netlify), always use the function proxy to avoid CORS issues
                if (location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
                    return '/.netlify/functions/api';
                }
                
                // For local development, try to get the actual ngrok URL from Netlify function
                // This only works if running netlify dev, otherwise fallback to hardcoded URL
                try {
                    const response = await fetch('/.netlify/functions/get-backend-url');
                    if (response.ok) {
                        const data = await response.json();
                        return data.backend_url;
                    }
                } catch (netlifyError) {
                    // Netlify functions not available (running on pure Vite dev server)
                    console.log('Netlify functions not available, using fallback ngrok URL');
                }
                
                // Fallback to hardcoded ngrok URL for local development
                return 'https://45c7d157915b.ngrok-free.app';
            } catch (error) {
                console.error('Error getting backend URL:', error);
                // Fallback based on environment
                if (location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
                    return '/.netlify/functions/api'; // Use proxy for production
                }
                return 'https://45c7d157915b.ngrok-free.app'; // Direct for local dev
            }
        }

        // Initialize API_BASE_URL - will be set dynamically
        let API_BASE_URL = '/.netlify/functions/api'; // Default to proxy

        // Set API_BASE_URL dynamically based on environment
        async function initializeApiUrl() {
            if (location.hostname === 'localhost' || location.hostname === '127.0.0.1') {
                if (location.port === '5173' || location.port === '5174') {
                    // Running on Vite dev server - get direct ngrok URL
                    API_BASE_URL = await getCurrentNgrokUrl();
                    console.log('[DEBUG] Monitor using direct ngrok URL for Vite dev server:', API_BASE_URL);
                } else {
                    // Running on production build locally
                    API_BASE_URL = 'http://127.0.0.1:9000';
                }
            } else {
                // Running on deployed Netlify - use function proxy to avoid CORS
                API_BASE_URL = '/.netlify/functions/api';
                console.log('[DEBUG] Monitor using Netlify function proxy for production:', API_BASE_URL);
            }
        }

        // Configuration
        let autoRefreshInterval = null;
        
        // DOM elements
        const serverStatus = document.getElementById('server-status');
        const robotState = document.getElementById('robot-state');
        const currentStateId = document.getElementById('current-state-id');
        
        // Control button elements
        const fastForwardBtn = document.getElementById('fast-forward-btn');
        const rerecordBtn = document.getElementById('rerecord-btn');
        const stopBtn = document.getElementById('stop-btn');
        
        // Camera view elements
        const cameraViews = {
            front: document.getElementById('camera-front'),
            left: document.getElementById('camera-left'),
            right: document.getElementById('camera-right'),
            perspective: document.getElementById('camera-perspective')
        };
        
        // Episode charts management
        const episodeChartsContainer = document.getElementById('episode-charts-container');
        let episodes = []; // Array of episode data
        let currentEpisodeIndex = 0;
        let REQUIRED_RESPONSES_PER_STATE = 3; // Will be updated from API
        let lastProcessedStateId = -1; // Track the highest state ID we've processed
        let episodeStartStateId = 0; // Track where current episode started
        
        // Update server status indicator
        function updateServerStatus(connected) {
            const indicator = serverStatus.querySelector('.status-indicator');
            if (connected) {
                indicator.className = 'status-indicator connected';
                serverStatus.innerHTML = '<span class="status-indicator connected"></span>Connected';
            } else {
                indicator.className = 'status-indicator disconnected';
                serverStatus.innerHTML = '<span class="status-indicator disconnected"></span>Disconnected';
            }
        }
        
        // Update camera view
        function updateCameraView(cameraName, imageDataUrl) {
            const cameraView = cameraViews[cameraName];
            if (!cameraView) return;
            
            if (imageDataUrl && imageDataUrl.startsWith('data:image/')) {
                cameraView.innerHTML = `<img src="${imageDataUrl}" alt="${cameraName} camera" class="camera-image">`;
            } else {
                cameraView.innerHTML = '<div class="camera-placeholder">No image</div>';
            }
        }
        
        // Update robot state
        function updateRobotState(isMoving) {
            if (isMoving) {
                robotState.className = 'robot-state moving';
                robotState.textContent = 'üèÉ Robot Moving';
            } else {
                robotState.className = 'robot-state stationary';
                robotState.textContent = 'üõë Robot Stationary';
            }
        }
        
        // Update joint positions display
        function updateJointPositions(joints) {
            // Function removed - joint positions panel no longer exists
        }
        
        // Episode Chart Management
        function createNewEpisode() {
            const episodeIndex = episodes.length;
            const episode = {
                index: episodeIndex,
                states: {},
                maxStates: 0,
                isComplete: false,
                startStateId: lastProcessedStateId + 1 // Track where this episode starts
            };
            episodes.push(episode);
            
            // Update episode tracking variables
            episodeStartStateId = lastProcessedStateId + 1;
            
            // Create the DOM element for this episode
            createEpisodeChartElement(episode);
            
            // Mark this as the current episode
            currentEpisodeIndex = episodeIndex;
            updateCurrentEpisodeIndicator();
            
            console.log(`üìä Created new episode ${episodeIndex}, starting from state ID ${episodeStartStateId}`);
            return episode;
        }
        
        function createEpisodeChartElement(episode) {
            const episodeDiv = document.createElement('div');
            episodeDiv.className = 'episode-chart';
            episodeDiv.id = `episode-${episode.index}`;
            
            episodeDiv.innerHTML = `
                <div class="episode-header">
                    <span class="episode-title">Episode ${episode.index + 1}</span>
                    <span class="episode-stats" id="episode-${episode.index}-stats">0 states, 0 responses</span>
                </div>
                <div class="chart-container">
                    <div class="chart-y-axis">
                        <div class="y-axis-label">${REQUIRED_RESPONSES_PER_STATE}</div>
                        <div class="y-axis-label">0</div>
                    </div>
                    <div class="chart-bars" id="episode-${episode.index}-bars">
                        <!-- State bars will be added here -->
                    </div>
                    <div class="chart-x-axis">States ‚Üí</div>
                </div>
            `;
            
            episodeChartsContainer.appendChild(episodeDiv);
        }
        
        function updateEpisodeChart(episodeIndex, stateId, responsesReceived) {
            if (episodeIndex >= episodes.length) return;
            
            const episode = episodes[episodeIndex];
            
            // Update episode data
            episode.states[stateId] = responsesReceived;
            episode.maxStates = Math.max(episode.maxStates, Object.keys(episode.states).length);
            
            // Get the bars container
            const barsContainer = document.getElementById(`episode-${episodeIndex}-bars`);
            if (!barsContainer) return;
            
            // Clear existing bars
            barsContainer.innerHTML = '';
            
            // Create bars for all states in this episode
            const stateIds = Object.keys(episode.states).sort((a, b) => parseInt(a) - parseInt(b));
            
            // Calculate the optimal width for each bar based on available space
            const containerWidth = barsContainer.clientWidth || 200; // fallback width
            const padding = 16; // total horizontal padding
            const gapWidth = 1; // gap between bars
            const availableWidth = containerWidth - padding;
            const totalGapWidth = (stateIds.length - 1) * gapWidth;
            const barWidth = Math.max(2, Math.min(20, (availableWidth - totalGapWidth) / stateIds.length));
            
            stateIds.forEach((stateId, index) => {
                const responses = episode.states[stateId];
                const barContainer = document.createElement('div');
                barContainer.className = 'state-bar-container';
                barContainer.style.width = `${barWidth}px`;
                barContainer.style.flex = 'none'; // Override flex: 1 to use fixed width
                
                const bar = document.createElement('div');
                bar.className = 'state-bar';
                
                if (responses === 0) {
                    bar.classList.add('empty');
                } else {
                    const heightPercent = (responses / REQUIRED_RESPONSES_PER_STATE) * 100;
                    bar.style.height = `${heightPercent}%`;
                }
                
                barContainer.appendChild(bar);
                barsContainer.appendChild(barContainer);
            });
            
            // Update episode stats
            const statsElement = document.getElementById(`episode-${episodeIndex}-stats`);
            if (statsElement) {
                const totalResponses = Object.values(episode.states).reduce((sum, count) => sum + count, 0);
                const stateCount = Object.keys(episode.states).length;
                statsElement.textContent = `${stateCount} states, ${totalResponses} responses`;
            }
            
            // Check if episode is complete
            const allStatesComplete = Object.values(episode.states).every(count => count >= REQUIRED_RESPONSES_PER_STATE);
            if (allStatesComplete && stateCount > 0) {
                episode.isComplete = true;
                document.getElementById(`episode-${episodeIndex}`).classList.add('complete');
            }
        }
        
        function updateCurrentEpisodeIndicator() {
            // Remove current class from all episodes
            document.querySelectorAll('.episode-chart').forEach(chart => {
                chart.classList.remove('current');
            });
            
            // Add current class to the current episode
            const currentChart = document.getElementById(`episode-${currentEpisodeIndex}`);
            if (currentChart) {
                currentChart.classList.add('current');
                // Scroll to current episode
                currentChart.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }
        
        function processMonitoringData(data) {
            // Update REQUIRED_RESPONSES_PER_STATE from the data if available
            if (data.required_responses_per_state) {
                REQUIRED_RESPONSES_PER_STATE = data.required_responses_per_state;
            }
            
            // Ensure we have at least one episode
            if (episodes.length === 0) {
                createNewEpisode();
            }
            
            // Process pending states info to update charts
            if (data.states_info) {
                const currentEpisode = episodes[currentEpisodeIndex];
                
                Object.entries(data.states_info).forEach(([stateIdStr, stateInfo]) => {
                    const stateId = parseInt(stateIdStr);
                    const responsesReceived = stateInfo.responses_received || 0;
                    
                    // Only process states that belong to the current episode
                    // (states with ID >= the episode's start state ID)
                    if (stateId >= currentEpisode.startStateId) {
                        updateEpisodeChart(currentEpisodeIndex, stateId, responsesReceived);
                        lastProcessedStateId = Math.max(lastProcessedStateId, stateId);
                    }
                });
            }
        }
        
        // Fetch latest state from monitoring endpoint
        async function fetchLatestState() {
            try {
                console.log('Fetching latest state from:', `${API_BASE_URL}/api/monitor/latest-state`);
                const response = await fetch(`${API_BASE_URL}/api/monitor/latest-state`, {
                    headers: {
                        'ngrok-skip-browser-warning': 'true'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('Received monitoring data:', data);
                
                // Update server status
                updateServerStatus(true);
                
                if (data.status === 'success') {
                    // Update camera views
                    if (data.views) {
                        for (const [cameraName, imageDataUrl] of Object.entries(data.views)) {
                            updateCameraView(cameraName, imageDataUrl);
                        }
                    }
                    
                    // Update status information
                    currentStateId.textContent = data.state_id || '--';
                    
                    // Update robot state
                    updateRobotState(data.robot_moving);
                    
                } else if (data.status === 'no_states') {
                    console.log('No pending states available');
                    currentStateId.textContent = 'No states';
                    
                    // Clear camera views
                    for (const cameraName of Object.keys(cameraViews)) {
                        updateCameraView(cameraName, null);
                    }
                }
                
                // Fetch pending states info for episode charts
                await fetchPendingStatesInfo();
                
            } catch (error) {
                console.error('Error fetching latest state:', error);
                updateServerStatus(false);
            }
        }
        
        // Fetch pending states info for episode tracking
        async function fetchPendingStatesInfo() {
            try {
                const response = await fetch(`${API_BASE_URL}/api/pending-states-info`, {
                    headers: {
                        'ngrok-skip-browser-warning': 'true'
                    }
                });
                if (response.ok) {
                    const data = await response.json();
                    processMonitoringData(data);
                }
            } catch (error) {
                console.error('Error fetching pending states info:', error);
            }
        }
        
        // Auto-refresh function (always enabled at 30 FPS)
        function startAutoRefresh() {
            autoRefreshInterval = setInterval(fetchLatestState, 33); // 33ms = 30 FPS
            console.log('Auto-refresh started (30 FPS)');
        }
        
        function stopAutoRefresh() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
                console.log('Auto-refresh stopped');
            }
        }
        
        // Control button handlers
        async function handleFastForward() {
            console.log('Next Episode button clicked');
            const button = fastForwardBtn;
            button.classList.add('loading');
            button.disabled = true;
            
            try {
                const response = await fetch(`${API_BASE_URL}/api/control/next-episode`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'ngrok-skip-browser-warning': 'true'
                    }
                });
                
                const result = await response.json();
                if (result.status === 'success') {
                    console.log('‚úÖ Next episode triggered successfully');
                    
                    // Create a new episode chart for the next episode
                    // The new episode will automatically start tracking from the next state ID
                    createNewEpisode();
                    
                } else {
                    console.error('‚ùå Failed to trigger next episode:', result.message);
                }
            } catch (error) {
                console.error('‚ùå Error triggering next episode:', error);
            } finally {
                button.classList.remove('loading');
                button.disabled = false;
            }
        }
        
        async function handleRerecord() {
            console.log('Re-record button clicked');
            const button = rerecordBtn;
            button.classList.add('loading');
            button.disabled = true;
            
            try {
                const response = await fetch(`${API_BASE_URL}/api/control/rerecord`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'ngrok-skip-browser-warning': 'true'
                    }
                });
                
                const result = await response.json();
                if (result.status === 'success') {
                    console.log('‚úÖ Re-record episode triggered successfully');
                } else {
                    console.error('‚ùå Failed to trigger re-record:', result.message);
                }
            } catch (error) {
                console.error('‚ùå Error triggering re-record:', error);
            } finally {
                button.classList.remove('loading');
                button.disabled = false;
            }
        }
        
        async function handleStop() {
            console.log('Stop button clicked');
            const button = stopBtn;
            button.classList.add('loading');
            button.disabled = true;
            
            try {
                const response = await fetch(`${API_BASE_URL}/api/control/stop`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'ngrok-skip-browser-warning': 'true'
                    }
                });
                
                const result = await response.json();
                if (result.status === 'success') {
                    console.log('‚úÖ Stop recording triggered successfully');
                } else {
                    console.error('‚ùå Failed to trigger stop:', result.message);
                }
            } catch (error) {
                console.error('‚ùå Error triggering stop:', error);
            } finally {
                button.classList.remove('loading');
                button.disabled = false;
            }
        }
        
        // Event listeners
        fastForwardBtn.addEventListener('click', handleFastForward);
        rerecordBtn.addEventListener('click', handleRerecord);
        stopBtn.addEventListener('click', handleStop);
        
        // Initialize
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('Data Collection Monitor initialized');
            await initializeApiUrl(); // Initialize API URL first
            fetchLatestState(); // Initial fetch
            startAutoRefresh(); // Start auto-refresh immediately
        });
        
        // Handle page visibility changes to pause/resume auto-refresh
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                console.log('Page hidden, pausing auto-refresh');
                stopAutoRefresh();
            } else {
                console.log('Page visible, resuming auto-refresh');
                startAutoRefresh();
            }
        });
    </script>
</body>
</html>
