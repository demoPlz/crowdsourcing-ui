<!-- wxai_min.html  ‚Äì  minimal translate-only IK demo -->
<!DOCTYPE html><html lang="en"><head>
<meta charset="utf-8" />
<title>WidowX AI ‚Äî position IK only</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#f5f5f5}
  /* Multi-view container wrapper with blue background */
  #viewport{
    position:fixed; 
    top:50%; left:50%; 
    transform:translate(-50%, -50%);
    background: #3b82f6;
    border-radius: 12px;
    padding: 20px;
    box-shadow:0 4px 20px rgba(0,0,0,0.15);
    display: flex;
    flex-direction: column;
    gap: 20px;
  }
  
  /* Text prompt area */
  #viewport .prompt-text{
    color: white;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans";
    font-size: 18px;
    font-weight: 600;
    text-align: left;
    text-shadow: 0 2px 4px rgba(0,0,0,0.3);
    line-height: 1.4;
    min-height: auto;
    padding: 0;
    margin: 0;
  }

  /* Content container for views and controls */
  #viewport .content-container{
    display: flex;
    gap: 20px;
    align-items: center;
  }
  
  /* Grid container for camera views */
  #viewport .views-grid{
    display:grid; 
    gap:0px; 
    border-radius:4px;
    overflow:hidden;
    flex-shrink: 0;
  }

  /* Container for sliders with CAPTCHA styling */
  #viewport .controls-container{
    background: rgba(255, 255, 255, 0.95);
    border-radius: 8px;
    padding: 16px 16px 12px 16px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    border: 1px solid rgba(255,255,255,0.2);
    min-width: 200px;
    display: flex;
    flex-direction: column;
    gap: 20px;
  }

  /* Single slider layout (underneath views) */
  #viewport.single-slider{
    flex-direction: column;
  }
  #viewport.single-slider .content-container{
    flex-direction: column;
    align-items: center;
  }
  #viewport.single-slider .controls-container{
    align-self: center;
    max-width: 400px;
  }

  /* Multiple slider layout (to the right of views) */
  #viewport.multiple-sliders .content-container{
    flex-direction: row;
    align-items: center;
  }

  /* Position task completed container in multiple slider layout */
  #viewport.multiple-sliders .task-completed-container {
    margin-top: 12px;
    align-self: flex-start;
  }

  /* Position task completed container in single slider layout */
  #viewport.single-slider .task-completed-container {
    align-self: center;
    max-width: 400px;
    margin-top: 12px;
  }

  /* Style the lil-gui within controls container */
  .controls-container .lil-gui {
    --background-color: transparent;
    --widget-color: rgba(255,255,255,0.9);
    --hover-color: rgba(255,255,255,1);
    --focus-color: #3b82f6;
    --text-color: #374151;
    --text-color-disabled: #9ca3af;
    --border-color: rgba(0,0,0,0.1);
    --border-color-hover: rgba(0,0,0,0.2);
    border: none !important;
    box-shadow: none !important;
    font-size: 16px;
  }

  /* Hide any lil-gui title/header elements */
  .controls-container .lil-gui .title,
  .controls-container .lil-gui .lil-gui > .title {
    display: none !important;
  }

  .controls-container .lil-gui .controller {
    margin: 8px 0;
    height: 32px;
  }

  .controls-container .lil-gui .controller .name {
    font-size: 16px;
    font-weight: 500;
    min-width: 60px;
  }

  .controls-container .lil-gui .controller input[type="range"] {
    -webkit-appearance: none;
    appearance: none;
    background: linear-gradient(to right, #d1d5db 0%, #d1d5db 100%);
    border-radius: 8px;
    height: 16px;
    min-width: 140px;
    outline: none;
    border: 1px solid #9ca3af;
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
    pointer-events: auto !important;
    cursor: pointer;
  }

  /* Ensure calibration GUI sliders are interactive */
  .lil-gui input[type="range"] {
    pointer-events: auto !important;
    cursor: pointer;
    user-select: none;
  }

  /* Webkit slider thumb (Chrome, Safari, Edge) */
  .controls-container .lil-gui .controller input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 40px;
    height: 28px;
    background: linear-gradient(145deg, #cbd5e1 0%, #94a3b8 50%, #64748b 100%);
    border: 2px solid #475569;
    border-radius: 6px;
    cursor: pointer;
    box-shadow: 
      0 3px 8px rgba(0,0,0,0.4), 
      inset 0 1px 0 rgba(255,255,255,0.3);
    position: relative;
  }

  /* Firefox slider thumb */
  .controls-container .lil-gui .controller input[type="range"]::-moz-range-thumb {
    width: 40px;
    height: 28px;
    background: linear-gradient(145deg, #cbd5e1 0%, #94a3b8 50%, #64748b 100%);
    border: 2px solid #475569;
    border-radius: 6px;
    cursor: pointer;
    box-shadow: 
      0 3px 8px rgba(0,0,0,0.4), 
      inset 0 1px 0 rgba(255,255,255,0.3);
  }

  /* Hover effects */
  .controls-container .lil-gui .controller input[type="range"]::-webkit-slider-thumb:hover {
    background: linear-gradient(145deg, #e2e8f0 0%, #cbd5e1 50%, #94a3b8 100%);
    box-shadow: 
      0 4px 10px rgba(0,0,0,0.5), 
      inset 0 1px 0 rgba(255,255,255,0.5);
    border: 2px solid #334155;
  }

  .controls-container .lil-gui .controller input[type="range"]::-moz-range-thumb:hover {
    background: linear-gradient(145deg, #e2e8f0 0%, #cbd5e1 50%, #94a3b8 100%);
    box-shadow: 
      0 4px 10px rgba(0,0,0,0.5), 
      inset 0 1px 0 rgba(255,255,255,0.5);
    border: 2px solid #334155;
  }

  /* Track styling for Firefox */
  .controls-container .lil-gui .controller input[type="range"]::-moz-range-track {
    background: linear-gradient(to right, #d1d5db 0%, #d1d5db 100%);
    border-radius: 8px;
    height: 16px;
    border: 1px solid #9ca3af;
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
  }

  /* Hide the number input/display by default */
  .controls-container .lil-gui .controller input[type="number"],
  .controls-container .lil-gui .controller .display {
    display: none !important;
  }

  /* Show numerical values in dev mode */
  body.dev-mode .controls-container .lil-gui .controller input[type="number"],
  body.dev-mode .controls-container .lil-gui .controller .display {
    display: block !important;
    width: 60px;
    font-size: 12px;
    margin-left: 8px;
  }

  /* Gripper button styling */
  .controls-container .gripper-section {
    margin: 0 0 12px 0;
  }

  .controls-container .gripper-label {
    font-size: 16px;
    font-weight: 500;
    color: #374151;
    margin-bottom: 8px;
    text-align: left;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans";
  }

  .controls-container .gripper-buttons {
    display: flex;
    gap: 8px;
    justify-content: center;
    margin: 0;
  }

  /* Reset button styling */
  .controls-container .lil-gui .controller .reset-btn {
    padding: 1px 0px;
    margin-left: 5px;
    border: 1px solid #d1d5db;
    background: #f3f4f6;
    border-radius: 1px;
    font-size: 8px;
    cursor: pointer;
    transition: background 0.2s ease;
    color: #374151;
    width: 30px;
    height: 20px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    user-select: none;
  }

  .controls-container .lil-gui .controller .reset-btn:hover {
    background: #e5e7eb;
    border-color: #9ca3af;
  }

  .controls-container .lil-gui .controller .reset-btn:active {
    background: #d1d5db;
  }

  .controls-container .gripper-buttons button,
  .controls-container .confirm-button {
    padding: 8px 16px;
    border: none;
    border-radius: 6px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    text-transform: capitalize;
  }

  .controls-container .gripper-buttons button.open-btn {
    background: #10b981;
    color: white;
    flex: 1;
  }

  .controls-container .gripper-buttons button.close-btn {
    background: #ef4444;
    color: white;
    flex: 1;
  }

  /* Inactive gripper button states */
  .controls-container .gripper-buttons button.open-btn.inactive {
    background: #e5e7eb;
    color: #6b7280;
    border: 2px solid #d1d5db;
  }

  .controls-container .gripper-buttons button.close-btn.inactive {
    background: #e5e7eb;
    color: #6b7280;
    border: 2px solid #d1d5db;
  }

  /* Active gripper button states (enhanced) */
  .controls-container .gripper-buttons button.open-btn.active {
    background: #10b981;
    color: white;
    border: 2px solid #059669;
    box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.2);
  }

  .controls-container .gripper-buttons button.close-btn.active {
    background: #ef4444;
    color: white;
    border: 2px solid #dc2626;
    box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.2);
  }

  .controls-container .confirm-button {
    background: #3b82f6;
    color: white;
    width: 100%;
    font-size: 16px;
    font-weight: 600;
    padding: 12px 16px;
  }

  /* Task Already Completed button styling */
  .task-completed-container {
    background: rgba(255, 255, 255, 0.95);
    border-radius: 8px;
    padding: 16px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    border: 1px solid rgba(255,255,255,0.2);
    min-width: 200px;
    align-self: flex-start;
  }

  .task-completed-button {
    background: #f59e0b;
    color: white;
    width: 100%;
    font-size: 14px;
    font-weight: 500;
    padding: 10px 16px;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .task-completed-button:hover {
    background: #d97706;
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(245, 158, 11, 0.3);
  }

  .task-completed-button:active {
    transform: translateY(0);
  }

  .controls-container button:hover {
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    transition: all 0.2s ease;
  }

  .controls-container button:active {
    transform: translateY(0);
  }

  .view-container{
    position:relative;
    display:grid;
    place-items:center;
    overflow:hidden;
  }
  .view-container.selected{border:2px solid #60a5fa;box-shadow:0 0 15px rgba(96,165,250,.6)}
  canvas{display:block;object-fit:cover;width:100%;height:100%}
  /* (no width/height forcing on canvas; renderer controls it) */
 /* --- nice full-screen status overlay + spinner --- */
  #statusOverlay{
    position:fixed; inset:0; display:none; place-items:center;
    background: radial-gradient(1200px 800px at 50% 30%, #111827 0%, #0b0d12 60%, #000 100%);
    color:#e5e7eb; padding:24px; text-align:center;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
  }
  #statusOverlay .card{
    max-width: 720px; width: min(92vw, 720px);
    background: rgba(17,24,39,0.55);
    border: 1px solid rgba(255,255,255,0.08);
    box-shadow: 0 10px 30px rgba(0,0,0,0.5), inset 0 1px 0 rgba(255,255,255,0.04);
    border-radius: 20px; padding: 26px 28px;
    backdrop-filter: blur(8px);
  }
  #statusOverlay .title{ font-size:20px; letter-spacing:.02em; margin:0 0 8px }
  #statusOverlay .msg  { font-size:16px; line-height:1.5; opacity:.9; margin:0 }
  #statusOverlay .row  { display:flex; align-items:center; gap:14px; justify-content:center; margin-bottom:10px }
  #statusOverlay .spinner{
    width:22px; height:22px; border-radius:50%;
    border:3px solid rgba(255,255,255,.25);
    border-top-color:#60a5fa; border-right-color:#93c5fd;
    animation: spin 1s linear infinite;
    box-shadow: 0 0 20px rgba(96,165,250,.35);
  }
  @keyframes spin{ to { transform: rotate(360deg); } }
  
  /* Auto-refresh progress bar styles */
  #refreshProgressBar {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    height: 4px;
    background: rgba(255, 255, 255, 0.2);
    z-index: 10000;
    opacity: 0;
    transition: opacity 0.3s ease;
  }
  
  #refreshProgressBar.visible {
    opacity: 1;
  }
  
  #refreshProgressBar .progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #3b82f6, #1d4ed8);
    width: 0%;
    transition: width 0.1s linear;
    box-shadow: 0 0 10px rgba(59, 130, 246, 0.6);
  }
  
  #refreshCountdown {
    position: fixed;
    top: 20px;
    right: 20px;
    background: rgba(17, 24, 39, 0.9);
    color: white;
    padding: 12px 20px;
    border-radius: 25px;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans";
    font-size: 14px;
    font-weight: 600;
    z-index: 10001;
    backdrop-filter: blur(8px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    opacity: 0;
    transform: translateY(-10px);
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  
  #refreshCountdown.visible {
    opacity: 1;
    transform: translateY(0);
  }
  
  #refreshCountdown .countdown-icon {
    display: inline-block;
    animation: pulse 1s ease-in-out infinite;
  }

  /* Disabled gripper buttons look inert + show not-allowed cursor */
  .controls-container .gripper-buttons button:disabled {
    background: #e5e7eb;
    color: #9ca3af;
    border: 2px dashed #d1d5db;
    cursor: not-allowed;
    box-shadow: none;
  }
  
  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.6; }
  }
</style>

<!-- Polyfill so the import-map works everywhere -->
<script async src="https://cdn.jsdelivr.net/npm/es-module-shims@2/dist/es-module-shims.js"></script>

<script type="importmap">
{
  "imports": {
    "three":               "https://cdn.jsdelivr.net/npm/three@0.165/build/three.module.js",
    "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.165/examples/jsm/",
    "urdf-loader":         "https://cdn.jsdelivr.net/npm/urdf-loader@0.12.6/src/URDFLoader.js?module",
    "closed-chain-ik":     "https://cdn.jsdelivr.net/npm/closed-chain-ik@0.18.0/dist/index.module.js"
  }
}
</script></head><body>
  <!-- Centering mount for the WebGL canvas; avoids CSS stretching -->
  <div id="viewport"></div>
  
  <!-- Auto-refresh progress bar -->
  <div id="refreshProgressBar">
    <div class="progress-fill"></div>
  </div>
  
  <!-- Auto-refresh countdown display -->
  <div id="refreshCountdown">
    <span class="countdown-icon">üîÑ</span>
    <span>Loading next task in <span id="countdownTime">5</span>s</span>
  </div>
<script type="module">

/* ---------- stable per-browser session id + fetch helper ---------- */
const SID_STORAGE_KEY = 'crowd_sid';
function getStableSID() {
  try {
    const existing = localStorage.getItem(SID_STORAGE_KEY);
    if (existing) return existing;
  } catch (_) { /* localStorage blocked? proceed with ephemeral */ }

  let sid;
  try {
    sid = (crypto && crypto.randomUUID) ? crypto.randomUUID() : null;
  } catch (_) { sid = null; }
  if (!sid) sid = 'sid-' + Math.random().toString(36).slice(2) + '-' + Date.now();

  try { localStorage.setItem(SID_STORAGE_KEY, sid); } catch (_) {}
  return sid;
}
const SID = getStableSID();
console.log('[SID]', SID);

/** Like fetch(), but always sends X-Session-ID and expands relative API paths */
function apiFetch(path, options = {}) {
  const url = path.startsWith('http') ? path : `${API_BASE_URL}${path}`;
  const headers = { ...(options.headers || {}), 'X-Session-ID': SID };
  return fetch(url, { ...options, headers });
}

/* ---------- imports ---------- */
import * as THREE                    from 'three';
import { OrbitControls }             from 'three/examples/jsm/controls/OrbitControls.js';
import URDFLoader                    from 'urdf-loader';
import {
  urdfRobotToIKRoot,
  setIKFromUrdf,
  setUrdfFromIK,
  Goal,
  Solver,
  DOF
} from 'closed-chain-ik';

import {GUI} from 'three/examples/jsm/libs/lil-gui.module.min.js';

// Simple API Configuration - use appropriate proxy based on environment
async function getCurrentCloudflaredUrl() {
  try {
    // For production (Netlify), always use the function proxy to avoid CORS issues
    if (location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
      return '/.netlify/functions/api';
    }
    
    // For local development, try to get the actual cloudflared URL from Netlify function
    // This only works if running netlify dev, otherwise fallback to hardcoded URL
    try {
      const response = await fetch('/.netlify/functions/get-backend-url');
      if (response.ok) {
        const data = await response.json();
        return data.backend_url;
      }
    } catch (netlifyError) {
      // Netlify functions not available (running on pure Vite dev server)
      console.log('Netlify functions not available, using fallback Tailscale URL');
    }
    
    // Fallback to hardcoded Tailscale URL for local development
    return 'https://ztclab-1.tail503d36.ts.net';
  } catch (error) {
    console.error('Error getting backend URL:', error);
    // Fallback based on environment
    if (location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
      return '/.netlify/functions/api'; // Use proxy for production
    }
    return 'https://reconstruction-parker-put-push.trycloudflare.com'; // Direct for local dev
  }
}

// Initialize API_BASE_URL - will be set dynamically in the loader
let API_BASE_URL = '/.netlify/functions/api'; // Default to proxy

// Function to check if we're in async collection mode
async function isAsyncCollectionMode() {
  try {
    const response = await fetch(`${API_BASE_URL}/api/monitor/latest-state`);
    if (!response.ok) {
      console.warn('Could not check async collection mode, defaulting to false');
      return false;
    }
    const data = await response.json();
    return data.is_async_collection === true;
  } catch (error) {
    console.warn('Error checking async collection mode:', error);
    return false;
  }
}

// Auto-refresh with progress bar function
async function delayedRefresh(delay = 5000) {
  // Check if we're in async collection mode
  const isAsync = await isAsyncCollectionMode();
  
  // If in async collection mode, refresh immediately
  if (isAsync) {
    console.log('üîÑ Async collection mode detected - refreshing immediately');
    // Hard refresh the page to load the next task (equivalent to Ctrl+Shift+R)
    // This forces a bypass of all caches
    window.location.replace(window.location.href.split('?')[0] + '?_=' + Date.now());
    return;
  }
  
  const progressBar = document.getElementById('refreshProgressBar');
  const countdown = document.getElementById('refreshCountdown');
  const countdownTime = document.getElementById('countdownTime');
  const progressFill = progressBar.querySelector('.progress-fill');
  
  // Show progress bar and countdown
  progressBar.classList.add('visible');
  countdown.classList.add('visible');
  
  let timeLeft = delay / 1000; // Convert to seconds
  let elapsed = 0;
  
  const updateInterval = 100; // Update every 100ms for smooth progress
  
  const timer = setInterval(() => {
    elapsed += updateInterval;
    timeLeft = Math.max(0, (delay - elapsed) / 1000);
    
    // Update progress bar
    const progress = (elapsed / delay) * 100;
    progressFill.style.width = `${Math.min(progress, 100)}%`;
    
    // Update countdown display
    countdownTime.textContent = Math.ceil(timeLeft);
    
    // Check if time is up
    if (elapsed >= delay) {
      clearInterval(timer);
      
      // Hide progress elements
      progressBar.classList.remove('visible');
      countdown.classList.remove('visible');
      
      // Perform the refresh after a brief delay to allow animations
      setTimeout(() => {
        // Hard refresh the page to load the next task (equivalent to Ctrl+Shift+R)
        // This forces a bypass of all caches
        window.location.replace(window.location.href.split('?')[0] + '?_=' + Date.now());
      }, 300);
    }
  }, updateInterval);
}

async function getInitialState() {
  try {
    console.log('[DEBUG] Fetching initial state from:', `${API_BASE_URL}/api/get-state`);
    const response = await apiFetch(`/api/get-state`, {
      headers: {
        'Accept': 'application/json'
      }
    });
    console.log('[DEBUG] Response status:', response.status, response.statusText);
    
    if (!response.ok) {
      const responseText = await response.text();
      console.error('[DEBUG] Response error body:', responseText.substring(0, 500));
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const data = await response.json();
    console.log('[DEBUG] Successfully fetched initial state');
    return data;
  } catch (error) {
    console.error("Could not fetch initial state:", error);
    showServerNotStarted();
    // Hide interactive UI when server is not running
    const uiElems = document.querySelectorAll("button, .lil-gui, #viewport");
    uiElems.forEach(el=>{
      el.style.display = "none";
    });
    return {};
  }
}


// Build a THREE.Texture from a base64 JPEG data URL
async function makeTextureFromDataURL(url) {
  const loader = new THREE.TextureLoader();
  return await new Promise((resolve, reject) => {
    loader.load(
      url,
      tex => {
        tex.flipY = true;
        tex.generateMipmaps = false;
        tex.minFilter = THREE.LinearFilter;
        tex.magFilter = THREE.LinearFilter;
        tex.needsUpdate = true;
        resolve(tex);
      },
      undefined,
      err => reject(err)
    );
  });
}

/* ---------- scene ---------- */
const defaultBg = new THREE.Color(0xf5f5f5);
const scene = new THREE.Scene();
scene.background = defaultBg;
scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1));

const dir = new THREE.DirectionalLight(0xffffff, 1.2);
dir.position.set(2, 4, 2);
scene.add(dir);

/* ---------- floor / workspace visual -------------------- */
// light, neutral grid on the ground (y = 0)

// Default camera (will be cloned for each view)
const templateCamera = new THREE.PerspectiveCamera(45, 1, 0.01, 100);
templateCamera.position.set(0.2, -2, 0).applyAxisAngle(new THREE.Vector3(0, -1, 1), Math.PI);

// Render everything at a more compact size for captcha-style layout
const VIEW_SCALE = 0.8;

// Multi-view system
const views = new Map(); // viewName -> {camera, renderer, container, name}
let currentViewName = null;
let calibrationMode = false; // Calibration mode (UI & per-camera params)
const mount = document.getElementById('viewport');

// Create the prompt text first
const promptText = document.createElement('div');
promptText.className = 'prompt-text';
promptText.textContent = 'Pick up the red block.'; // Default text, will be updated from server
mount.appendChild(promptText);

// Create the content container for views and controls
const contentContainer = document.createElement('div');
contentContainer.className = 'content-container';
mount.appendChild(contentContainer);

// Create the views grid container
const viewsGrid = document.createElement('div');
viewsGrid.className = 'views-grid';
contentContainer.appendChild(viewsGrid);

// Create a wrapper for controls and task completed button
const controlsWrapper = document.createElement('div');
controlsWrapper.style.display = 'flex';
controlsWrapper.style.flexDirection = 'column';
controlsWrapper.style.gap = '0px';
contentContainer.appendChild(controlsWrapper);

// Create the controls container for sliders
const controlsContainer = document.createElement('div');
controlsContainer.className = 'controls-container';
controlsContainer.style.display = 'none'; // Hidden initially
controlsWrapper.appendChild(controlsContainer);

// Multi-view grid layout helper
function calculateGridLayout(numViews) {
  if (numViews === 1) return { rows: 1, cols: 1 };
  if (numViews === 2) return { rows: 1, cols: 2 };
  if (numViews === 3) return { rows: 2, cols: 2 }; // 2 on top, 1 on bottom
  if (numViews === 4) return { rows: 2, cols: 2 };
  // For more views, calculate a reasonable grid
  const cols = Math.ceil(Math.sqrt(numViews));
  const rows = Math.ceil(numViews / cols);
  return { rows, cols };
}

function setupViewportGrid(numViews) {
  const { rows, cols } = calculateGridLayout(numViews);
  viewsGrid.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
  viewsGrid.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
}

function createViewRenderer(viewName, cameraModel, texture) {
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(devicePixelRatio);
  
  const camera = templateCamera.clone();
  
  const container = document.createElement('div');
  container.className = 'view-container';
  container.dataset.viewName = viewName;
  
  container.appendChild(renderer.domElement);
  viewsGrid.appendChild(container);
  
  const view = {
    camera,
    renderer,
    container,
    name: viewName,
    model: cameraModel,
    texture: texture
  };
  
  views.set(viewName, view);
  return view;
}

function updateViewSizes() {
  const viewContainers = viewsGrid.querySelectorAll('.view-container');
  if (viewContainers.length === 0) return;
  
  // Define compact view dimensions based on number of views (increased by 87.5% total: 1.25 * 1.5)
  const numViews = viewContainers.length;
  let targetWidth, targetHeight;
  
  if (numViews === 1) {
    targetWidth = 600;  // 400 * 1.5
    targetHeight = 450; // 300 * 1.5
  } else if (numViews === 2) {
    targetWidth = 450;  // 300 * 1.5
    targetHeight = 338; // 225 * 1.5
  } else if (numViews === 3 || numViews === 4) {
    targetWidth = 375;  // 250 * 1.5
    targetHeight = 282; // 188 * 1.5
  } else {
    targetWidth = 300;  // 200 * 1.5
    targetHeight = 225; // 150 * 1.5
  }
  
  // Apply sizing to views grid - no gaps or padding now
  const { rows, cols } = calculateGridLayout(numViews);
  const totalWidth = cols * targetWidth; // no gaps
  const totalHeight = rows * targetHeight; // no gaps
  
  viewsGrid.style.width = totalWidth + 'px';
  viewsGrid.style.height = totalHeight + 'px';
  
  views.forEach(view => {
    const model = view.model;
    if (!model) return;
    
    const W = model.width | 0;
    const H = model.height | 0;
    
    // Make canvas fill the entire container
    const containerAspect = targetWidth / targetHeight;
    const imageAspect = W / H;
    
    let renderWidth = targetWidth;
    let renderHeight = targetHeight;
    
    // Fill the container completely (may crop image slightly)
    if (containerAspect > imageAspect) {
      // Container is wider than image aspect - fit to width
      renderHeight = Math.round(targetWidth / imageAspect);
    } else {
      // Container is taller than image aspect - fit to height  
      renderWidth = Math.round(targetHeight * imageAspect);
    }
    
    view.renderer.setSize(renderWidth, renderHeight);
    
    // Set container size to match target exactly
    view.container.style.width = targetWidth + 'px';
    view.container.style.height = targetHeight + 'px';
  });
}


// --- status overlay (initially hidden) ---
const statusOverlay = document.createElement('div');
statusOverlay.id = 'statusOverlay';
document.body.appendChild(statusOverlay);

function showServerNotStarted(){
  statusOverlay.innerHTML = `
    <div class="card">
      <div class="row">
        <div class="spinner" aria-hidden="true"></div>
        <h2 class="title">Connecting to data collection server‚Ä¶</h2>
      </div>
      <p class="msg">
        Data collection server hasn't started yet.<br/>
        Please wait for further communications.
      </p>
    </div>`;
  statusOverlay.style.display = 'grid';
}

// ================================ devMode ===================================
const devMode = false;
// Apply dev-mode class to body if devMode is enabled
if (devMode) {
  document.body.classList.add('dev-mode');
}
// ================================ devMode ===================================


let calibGUI = null;                       // lil-gui instance for calibration
const calibState = {};                     // name -> {tx,ty,tz,rx,ry,rz,fx,fy,cx,cy}
const calibDefaults = {};                  // snapshot at calibration start (per camera)

/* ---------- load URDF ---------- */
const loader = new URDFLoader();
loader.packages = {                 // map package:// paths ‚Üí server paths
  'trossen_arm_description': 'assets/trossen_arm_description'
};

loader.load(
  'assets/trossen_arm_description/urdf/generated/wxai/wxai_base.urdf',
  async robot => {

    // Set API_BASE_URL dynamically based on environment
    if (location.hostname === 'localhost' || location.hostname === '127.0.0.1') {
      if (location.port === '5173' || location.port === '5174') {
        // Running on Vite dev server - get direct cloudflared URL
        API_BASE_URL = await getCurrentCloudflaredUrl();
        console.log('[DEBUG] Using direct cloudflared URL for Vite dev server:', API_BASE_URL);
      } else {
        // Running on production build locally
        API_BASE_URL = 'http://127.0.0.1:9000';
      }
    } else {
      // Running on deployed Netlify - use function proxy to avoid CORS
      API_BASE_URL = '/.netlify/functions/api';
      console.log('[DEBUG] Using Netlify function proxy for production:', API_BASE_URL);
    }

    console.log('Using API Base URL:', API_BASE_URL);

    scene.add(robot);

    let robotVisible = false; // toggle visibility of the robot model
    robot.visible = false;     // hide arm until user moves a slider
    let toggleRobotBtn = null;

    /* --- build IK tree from URDF (limits copied automatically) --- */
    const ikRoot = urdfRobotToIKRoot(robot);          // :contentReference[oaicite:0]{index=0}

    ikRoot.clearDoF()

    const state = await getInitialState();
    const cameraModels = state.camera_models ?? {};
    // If the data collection server isn't available, stop building UI
    if (!state || Object.keys(state).length === 0 || !cameraModels) {
      // Ensure the status overlay is visible and abort UI construction
      showServerNotStarted();
      return; // ‚Üê prevents creating sliders/buttons and starting animation
    }

    /* ---------- build textures from JPEG base64 views --------------- */
    const viewTextures = {}; // 'front' ‚Üí THREE.Texture
    for (const [key, dataUrl] of Object.entries(state.views ?? {})) {
      viewTextures[key] = await makeTextureFromDataURL(dataUrl);
    }

    const initialJointPositions = state.joint_positions ?? {};
    const activeControls        = state.controls ?? ['x','y','z','roll','pitch','yaw'];

    /* ---------- gripper finger-tip calibration (load + state) ---------- */
    const TIP_CAL_LS_KEY = 'wxai_gripper_tip_calib';

    function loadTipCalibFromLS() {
      try { const txt = localStorage.getItem(TIP_CAL_LS_KEY); return txt ? JSON.parse(txt) : null; } catch { return null; }
    }
    function saveTipCalibToLS(obj) {
      try { localStorage.setItem(TIP_CAL_LS_KEY, JSON.stringify(obj)); } catch {}
    }

    // Server-provided values take priority, then localStorage, then defaults
    let tipCalib = (state.gripper_tip_calib && state.gripper_tip_calib.left && state.gripper_tip_calib.right)
      ? JSON.parse(JSON.stringify(state.gripper_tip_calib))
      : (loadTipCalibFromLS() ?? {
          left:  { x: 0.03, y: 0.00, z: 0.00 },
          right: { x: 0.03, y: 0.00, z: 0.00 }
        });

    saveTipCalibToLS(tipCalib); // mirror locally so it's never lost client‚Äëside

    // Calibratable local offsets (per finger) that the renderer uses
    const fingerTipLocalLeft  = new THREE.Vector3(tipCalib.left.x,  tipCalib.left.y,  tipCalib.left.z);
    const fingerTipLocalRight = new THREE.Vector3(tipCalib.right.x, tipCalib.right.y, tipCalib.right.z);

    function applyTipCalibToVectors(){
      fingerTipLocalLeft.set (tipCalib.left.x,  tipCalib.left.y,  tipCalib.left.z);
      fingerTipLocalRight.set(tipCalib.right.x, tipCalib.right.y, tipCalib.right.z);
    }

    
    // Update prompt text from server state
    const promptFromServer = state.prompt || 'Pick up the red block.';
    promptText.textContent = promptFromServer;
    
    for (const [name, val] of Object.entries(initialJointPositions)) {
      robot.setJointValue(name, val);
    }

    /* ---------- gripper-motion arrows ---------------------------------- */
    let gripArrows = [];                       // keeps currently-shown arrow meshes
    let gripDir    = state.gripper ?? 0;

    function drawGripArrows(dir /* +1 open | ‚Äì1 close */) {
      /* remove previous arrows */
      gripArrows.forEach(a => scene.remove(a));
      gripArrows.length = 0;

      gripDir = dir || 0;     // remember last request
      
      // Always create arrows, use default direction if none specified
      const effectiveDir = dir || 1; // default to open arrows if no direction specified
      const colour   = effectiveDir > 0 ? 0x00ff00 : 0xff0000;
      const len      = 0.04, headLen = 0.02;
      const shaftLen = len - headLen, shaftRad = 0.005, offset = 0.00;
      const tipX     = 0.02;

      function addArrow(linkName, outward) {
        const link = robot.getObjectByName(linkName); if (!link) return;
        const dirLocal    = new THREE.Vector3(0, effectiveDir * outward, 0).normalize();
        const baseDist    = effectiveDir > 0 ? offset : offset + len;
        const originLocal = new THREE.Vector3(tipX, outward * baseDist, 0);

        /* geometry ---------------------------------------------------- */
        const mat       = new THREE.MeshBasicMaterial({ color: colour });
        const grp       = new THREE.Group();

        const shaftGeo  = new THREE.CylinderGeometry(shaftRad, shaftRad,
                                                     shaftLen, 8, 1, true);
        const shaft     = new THREE.Mesh(shaftGeo, mat);
        shaft.position.y = shaftLen / 2;
        grp.add(shaft);

        const coneGeo   = new THREE.ConeGeometry(headLen * 0.6, headLen, 8);
        const cone      = new THREE.Mesh(coneGeo, mat);
        cone.position.y = shaftLen + headLen / 2;
        grp.add(cone);

        grp.position.copy(originLocal);
        grp.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dirLocal);
        
        // Add arrows to scene instead of robot links so they're visible even when robot is hidden
        scene.add(grp);
        
        // Store link reference to update arrow position in animation loop
        grp.userData.targetLink = link;
        grp.userData.originLocal = originLocal.clone();
        grp.userData.dirLocal = dirLocal.clone();
        
        gripArrows.push(grp);
      }
      addArrow('gripper_left',  +1);
      addArrow('gripper_right', -1);
    }

    function updateGripArrowVisibility() {
      // Show gripper arrows only for front and perspective cameras
      const showArrows = currentViewName === 'front' || currentViewName === 'perspective';
      console.log(`[DEBUG] updateGripArrowVisibility: currentViewName="${currentViewName}", showArrows=${showArrows}, gripArrows.length=${gripArrows.length}`);
      gripArrows.forEach(arrow => {
        if (arrow && arrow.visible !== undefined) {
          arrow.visible = showArrows;
        }
      });
    }

    drawGripArrows(state.gripper ?? 0);        // render initial arrows from server
    updateGripArrowVisibility();               // set initial visibility based on current view

    const gui = new GUI({ container: controlsContainer });
    gui.domElement.style.position = 'static'; // Remove absolute positioning
    gui.domElement.style.width = '100%';
    
    // Create gripper controls container (will be added after sliders)
    let gripperButtonsContainer = null;
    let openBtn = null, closeBtn = null; // Store button references for state updates
    
    function updateGripperButtonStates() {
      if (!openBtn || !closeBtn) return;
      
      // Remove all state classes first
      openBtn.classList.remove('active', 'inactive');
      closeBtn.classList.remove('active', 'inactive');
      
      // Apply states based on current gripper direction
      if (gripDir > 0) { // Open
        openBtn.classList.add('active');
        closeBtn.classList.add('inactive');
      } else if (gripDir < 0) { // Close
        openBtn.classList.add('inactive');
        closeBtn.classList.add('active');
      } else { // Neutral/Default - both inactive
        openBtn.classList.add('inactive');
        closeBtn.classList.add('inactive');
      }
    }

    function updateGripperInteractivity() {
      const atDefault = slidersAtDefault();
      if (!openBtn || !closeBtn) return;

      openBtn.disabled = !atDefault;
      closeBtn.disabled = !atDefault;

      // Build a clear hover message
      const changed = getChangedAxes();
      const hoverMsg = atDefault
        ? 'You can change the gripper state.'
        : `Gripper locked: pose sliders changed (${changed.join(', ')}). Reset sliders to their starting values to change the gripper.`;

      openBtn.title = hoverMsg;
      closeBtn.title = hoverMsg;

      // Also put the explanation on the label if present
      const label = document.querySelector('.gripper-label');
      if (label) label.title = hoverMsg;

      // Visually reflect disabled state via existing classes
      if (!atDefault) {
        openBtn.classList.add('inactive'); openBtn.classList.remove('active');
        closeBtn.classList.add('inactive'); closeBtn.classList.remove('active');
      } else {
        updateGripperButtonStates();
      }
    }
    
    if (activeControls.includes('gripper')) {
      gripperButtonsContainer = document.createElement('div');
      gripperButtonsContainer.className = 'gripper-section';
      
      const gripperLabel = document.createElement('div');
      gripperLabel.className = 'gripper-label';
      gripperLabel.textContent = 'gripper';
      gripperButtonsContainer.appendChild(gripperLabel);
      
      const buttonsContainer = document.createElement('div');
      buttonsContainer.className = 'gripper-buttons';
      
      openBtn = document.createElement('button');
      openBtn.textContent = 'Open';
      openBtn.className = 'open-btn';
      openBtn.onclick = () => {
        drawGripArrows(+1);
        updateGripArrowVisibility();
        updateGripperButtonStates();
      };
      
      closeBtn = document.createElement('button');
      closeBtn.textContent = 'Close';
      closeBtn.className = 'close-btn';
      closeBtn.onclick = () => {
        drawGripArrows(-1);
        updateGripArrowVisibility();
        updateGripperButtonStates();
      };
      
      buttonsContainer.appendChild(openBtn);
      buttonsContainer.appendChild(closeBtn);
      gripperButtonsContainer.appendChild(buttonsContainer);
    }

    const camPoses = state.camera_poses ?? {}

    // --- Intrinsics ‚Üí projection helper (use Knew from backend) ---
    function applyProjectionFromK(view) {
      const model = view.model;
      const camera = view.camera;
      if (!model || !model.Knew || !model.width || !model.height) {
        return false;
      }
      const K = model.Knew;       // 3x3 (row-major)
      const W = model.width|0;
      const H = model.height|0;
      const near = camera.near, far = camera.far;

      // Scale intrinsics to current viewport (CSS) size
      const sz = new THREE.Vector2();
      view.renderer.getDrawingBufferSize(sz);
      const vw = sz.x, vh = sz.y;
      const sx = vw / W, sy = vh / H;

      const fx = K[0][0] * sx, fy = K[1][1] * sy;
      const cx = K[0][2] * sx, cy = K[1][2] * sy;

      // OpenCV pixels (origin top-left, +y down) ‚Üí Three frustum (y up)
      const left   = -cx * near / fx;
      const right  =  (vw - cx) * near / fx;
      const top    =  cy * near / fy;
      const bottom = -(vh - cy) * near / fy;

      const P = new THREE.Matrix4().makePerspective(left, right, top, bottom, near, far);
      camera.projectionMatrix.copy(P);
      camera.projectionMatrixInverse.copy(P).invert();
      camera.projectionMatrixAutoUpdate = false;
      return true;
    }

    function applyDefaultPerspective(view) {
      const camera = view.camera;
      camera.projectionMatrixAutoUpdate = true;
      camera.fov = 45;
      camera.aspect = 1; // Will be updated when renderer size is set
      camera.updateProjectionMatrix();
    }

    function updateViewCamera(view, pose) {
      if (!pose) return false;
      
      const m = poseToMatrix(pose);
      const pos   = new THREE.Vector3();
      const quat  = new THREE.Quaternion();
      const scale = new THREE.Vector3();
      m.decompose(pos, quat, scale);

      view.camera.position.copy(pos);
      view.camera.quaternion.copy(quat);
      view.camera.updateMatrixWorld();
      
      return true;
    }

    /* ---------- calibration helpers (intrinsics & extrinsics) ------- */
    function poseKeyForName(name) {
      // camPoses keys look like "front_pose", "left_pose", ...
      for (const k of Object.keys(camPoses)) if (k.startsWith(name)) return k;
      return null;
    }

    function ensureCalibStateFor(name) {
      if (calibState[name]) return;
      // Seed from current view's camera transform & model K
      const view = views.get(name);
      if (!view) return;
      
      const pos = new THREE.Vector3();
      const quat = new THREE.Quaternion();
      view.camera.updateMatrixWorld();
      view.camera.getWorldPosition(pos);
      view.camera.getWorldQuaternion(quat);
      const eul = new THREE.Euler().setFromQuaternion(quat, 'XYZ');
      const model = cameraModels?.[name];
      const K = model?.Knew;
      calibState[name] = {
        tx: pos.x, ty: pos.y, tz: pos.z,
        rx: eul.x, ry: eul.y, rz: eul.z,
        fx: K ? K[0][0] : 800,
        fy: K ? K[1][1] : 800,
        cx: K ? K[0][2] : (model?.width ?? 640) / 2,
        cy: K ? K[1][2] : (model?.height ?? 480) / 2,
        zoom: 1.0,  // multiplicative scale for fx, fy
      };
    }

    function destroyCalibGUI() { if (calibGUI) { calibGUI.destroy(); calibGUI = null; } }

    function applyExtrinsicsFromParams(name) {
      const s = calibState[name]; if (!s) return;
      const view = views.get(name); if (!view) return;
      
      const q = new THREE.Quaternion().setFromEuler(new THREE.Euler(s.rx, s.ry, s.rz, 'XYZ'));
      view.camera.position.set(s.tx, s.ty, s.tz);
      view.camera.quaternion.copy(q);
      view.camera.updateMatrixWorld(true);
      
      // Update camPoses so switching away/back keeps edited pose
      const key = poseKeyForName(name);
      if (key) {
        const m = new THREE.Matrix4().compose(view.camera.position.clone(), view.camera.quaternion.clone(), new THREE.Vector3(1,1,1));
        const e = m.elements; // row-major in Three (column-major storage)
        camPoses[key] = [
          [e[0], e[4], e[8],  e[12]],
          [e[1], e[5], e[9],  e[13]],
          [e[2], e[6], e[10], e[14]],
          [e[3], e[7], e[11], e[15]],
        ];
      }
    }

    function applyIntrinsicsFromParams(name) {
      const s = calibState[name]; if (!s) return;
      const model = cameraModels?.[name]; if (!model) return;
      const view = views.get(name); if (!view) return;
      
      const z = (s.zoom ?? 1.0);
      const fx_eff = s.fx * z;
      const fy_eff = s.fy * z;
      model.Knew = [
        [fx_eff, 0,     s.cx],
        [0,      fy_eff, s.cy],
        [0,    0,    1   ],
      ];
      applyProjectionFromK(view);
    }

    // tiny helper: add a slider **and** a matching "revert" button for it
    function addParamWithRevert(folder, stateObj, key, range, step, label, onChange, camName){
      const [min, max] = range;
      const ctrl = folder.add(stateObj, key, min, max, step).name(label).onChange((value) => {
        onChange(camName);
      });
      
      const revertObj = {};
      const revertLabel = `revert ${label}`;
      revertObj[revertLabel] = () => {
        // restore from snapshot taken when entering calibration
        stateObj[key] = calibDefaults[camName][key];
        ctrl.updateDisplay();
        onChange(camName);
      };
      folder.add(revertObj, revertLabel);
      return ctrl;
    }

    function enterCalibration() {
      if (!currentViewName) { console.warn('Pick a camera view before calibrating.'); return; }
      calibrationMode = true;
      destroyCalibGUI();
      ensureCalibStateFor(currentViewName);
      const s = calibState[currentViewName];
      calibDefaults[currentViewName] = { ...s };
      calibGUI = new GUI();
      // Position panel top-right with higher z-index and ensure it's interactive
      calibGUI.domElement.style.position = 'fixed';
      calibGUI.domElement.style.top = '8px';
      calibGUI.domElement.style.right = '8px';
      calibGUI.domElement.style.zIndex = 9999;
      calibGUI.domElement.style.pointerEvents = 'auto';
      calibGUI.domElement.style.userSelect = 'none';
      
      // Intrinsics controls (no folder)
      const model = cameraModels[currentViewName];
      const W = model?.width  ?? 640;
      const H = model?.height ?? 480;
      addParamWithRevert(calibGUI, s, 'zoom', [0.1, 5.0], 0.1, 'zoom', applyIntrinsicsFromParams, currentViewName);
      addParamWithRevert(calibGUI, s, 'fx', [50, 8000], 1,   'fx', applyIntrinsicsFromParams, currentViewName);
      addParamWithRevert(calibGUI, s, 'fy', [50, 8000], 1,   'fy', applyIntrinsicsFromParams, currentViewName);
      addParamWithRevert(calibGUI, s, 'cx', [0, W],     0.1, 'cx', applyIntrinsicsFromParams, currentViewName);
      addParamWithRevert(calibGUI, s, 'cy', [0, H],     0.1, 'cy', applyIntrinsicsFromParams, currentViewName);
      
      // Extrinsics controls (no folder)
      addParamWithRevert(calibGUI, s, 'tx', [s.tx - 0.25, s.tx + 0.25], 0.0005, 'tx (m)',   applyExtrinsicsFromParams, currentViewName);
      addParamWithRevert(calibGUI, s, 'ty', [s.ty - 0.25, s.ty + 0.25], 0.0005, 'ty (m)',   applyExtrinsicsFromParams, currentViewName);
      addParamWithRevert(calibGUI, s, 'tz', [s.tz - 0.25, s.tz + 0.25], 0.0005, 'tz (m)',   applyExtrinsicsFromParams, currentViewName);
      addParamWithRevert(calibGUI, s, 'rx', [s.rx - 1.0,  s.rx + 1.0 ], 0.0005, 'roll rx',  applyExtrinsicsFromParams, currentViewName);
      addParamWithRevert(calibGUI, s, 'ry', [s.ry - 1.0,  s.ry + 1.0 ], 0.0005, 'pitch ry', applyExtrinsicsFromParams, currentViewName);
      addParamWithRevert(calibGUI, s, 'rz', [s.rz - 1.0,  s.rz + 1.0 ], 0.0005, 'yaw rz',   applyExtrinsicsFromParams, currentViewName);
      
      // ---- Save calibration action (writes to backend) ----
      const actions = {
        async save_calibration() {
          try {
            // build 4x4 from current cam pose (tx,ty,tz + rx,ry,rz)
            const q = new THREE.Quaternion().setFromEuler(new THREE.Euler(s.rx, s.ry, s.rz, 'XYZ'));
            const Tm = new THREE.Matrix4().compose(
              new THREE.Vector3(s.tx, s.ty, s.tz),
              q,
              new THREE.Vector3(1,1,1)
            );
            // convert to row-major list-of-lists like the rest of the app
            const e = Tm.elements;
            const T_three = [
              [e[0], e[4], e[8],  e[12]],
              [e[1], e[5], e[9],  e[13]],
              [e[2], e[6], e[10], e[14]],
              [e[3], e[7], e[11], e[15]],
            ];
            const model = cameraModels[currentViewName];
            // Use effective fx/fy that include zoom
            const z = (s.zoom ?? 1.0);
            const fx_eff = s.fx * z;
            const fy_eff = s.fy * z;
            const payload = {
              camera: currentViewName,
              intrinsics: {
                width:  model?.width  ?? 640,
                height: model?.height ?? 480,
                Knew: [
                  [fx_eff, 0,    s.cx],
                  [0,    fy_eff, s.cy],
                  [0,    0,    1   ],
                ],
                zoom: z
              },
              extrinsics: { T_three }
            };
            const resp = await apiFetch(`/api/save-calibration`, {
              method: 'POST',
              headers: { 
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(payload)
            });
            const out = await resp.json();
            if (!resp.ok) throw new Error(out?.error || 'save failed');
            console.log('‚úÖ saved calibration:', out);
            alert(`Saved calibration for '${currentViewName}' to ${out.path}`);
          } catch (err) {
            console.error('‚ùå save calibration failed', err);
            alert('Save calibration failed. See console for details.');
          }
        }
      };
      calibGUI.add(actions, 'save_calibration').name('Save calibration');

      /* --------- Gripper tip calibration (dev panel) --------- */
      // Working copy for sliders
      const tipDev = JSON.parse(JSON.stringify(tipCalib));

      // When sliders move: commit to live calib, update vectors, persist locally
      function onTipDevChange(){
        tipCalib.left.x  = tipDev.left.x;  tipCalib.left.y  = tipDev.left.y;  tipCalib.left.z  = tipDev.left.z;
        tipCalib.right.x = tipDev.right.x; tipCalib.right.y = tipDev.right.y; tipCalib.right.z = tipDev.right.z;
        applyTipCalibToVectors();
        saveTipCalibToLS(tipCalib);
      }

      const tipFolderDev = calibGUI.addFolder('gripper tips');
      const rng = [-0.10, 0.10], step = 0.0005; // 0.5 mm step; widen if needed

      tipFolderDev.add(tipDev.left,  'x', rng[0], rng[1], step).name('left x (m)').onChange(onTipDevChange);
      tipFolderDev.add(tipDev.left,  'y', rng[0], rng[1], step).name('left y (m)').onChange(onTipDevChange);
      tipFolderDev.add(tipDev.left,  'z', rng[0], rng[1], step).name('left z (m)').onChange(onTipDevChange);

      tipFolderDev.add(tipDev.right, 'x', rng[0], rng[1], step).name('right x (m)').onChange(onTipDevChange);
      tipFolderDev.add(tipDev.right, 'y', rng[0], rng[1], step).name('right y (m)').onChange(onTipDevChange);
      tipFolderDev.add(tipDev.right, 'z', rng[0], rng[1], step).name('right z (m)').onChange(onTipDevChange);

      // Save to backend (same pattern as camera)
      const tipActions = {
        async save_gripper_tips(){
          const payload = {
            gripper_tip_calib: tipCalib,
            state_id: state.state_id,
            episode_id: state.episode_id
          };
          try {
            // Prefer a generic calibration endpoint (like cameras)
            let resp = await apiFetch(`/api/save-calibration`, {
              method: 'POST',
              headers: { 'Content-Type':'application/json' },
              body: JSON.stringify({ type: 'gripper_tips', ...payload })
            });

            // Fallback: dedicated route if your backend uses one
            if (!resp.ok) {
              resp = await apiFetch(`/api/save-gripper-tips`, {
                method: 'POST',
                headers: { 'Content-Type':'application/json' },
                body: JSON.stringify(payload)
              });
            }

            const out = await resp.json();
            if (!resp.ok) throw new Error(out?.error || 'save failed');
            console.log('‚úÖ saved gripper tip calibration', out);
            alert(`Saved gripper tip calibration${out.path ? ` to ${out.path}` : ''}.`);
          } catch (err) {
            console.error('‚ùå failed to save gripper tip calibration', err);
            alert('Saved locally. Server save failed (check console).');
          }
        }
      };
      tipFolderDev.add(tipActions, 'save_gripper_tips').name('Save gripper tips');

      // Initial apply so the matrices reflect slider defaults
      applyIntrinsicsFromParams(currentViewName);
      applyExtrinsicsFromParams(currentViewName);

    }

    function exitCalibration() {
      destroyCalibGUI();
      calibrationMode = false;
    }

    setIKFromUrdf(ikRoot, robot);
    ikRoot.updateMatrixWorld(true);

    /* --- locate the end-effector link inside IK tree --- */
    let ee = null;
    
    ikRoot.traverse(child => {                        // Frame.traverse
      if ( child.name === 'ee_gripper_link' ) { ee = child; return true; }
    });

    /* --- create a translation-only Goal --- */
    const goal = new Goal();
    goal.setDoF(DOF.X, DOF.Y, DOF.Z, DOF.EX, DOF.EY, DOF.EZ);

    goal.makeClosure( ee );                          // link goal ‚Üî ee

    /* ---- sample the **visual** EE pose after matrices are fresh */
    const startPos  = new THREE.Vector3();
    const startQuat = new THREE.Quaternion();

    robot.updateMatrixWorld( true );                 // propagate world mats
    const eeVis = robot.getObjectByName( 'ee_gripper_link' );
    eeVis.getWorldPosition   ( startPos  );
    eeVis.getWorldQuaternion ( startQuat );

    goal.setPosition   ( startPos.x, startPos.y, startPos.z );
    goal.setQuaternion ( startQuat.x, startQuat.y, startQuat.z, startQuat.w );

    const baseQuat = startQuat.clone();
    // NEW: track accumulated orientation and last slider values (for incremental deltas)
    let currentQuat = baseQuat.clone();
    let lastAngles = { roll: 0, pitch: 0, yaw: 0 };

    /* ---------- semi-transparent alignment line -------------------- */
    const lineLen = 0.80;      // meters
    const lineRad = 0.002;     // thickness
    const lineOffX = - 0.01;
    const lineMat = new THREE.MeshBasicMaterial({
      color: 0x00ff00, transparent: true, opacity: 0.4
    });
    const line    = new THREE.Mesh(
      new THREE.CylinderGeometry(lineRad, lineRad, lineLen, 8, 1, true),
      lineMat
    );
    line.rotation.x = Math.PI / 2;   // cylinder-Y ‚Üí world Z
    scene.add(line);
    // --- cache & helpers for fast updates (no per-frame allocs) ---
    const baseLineLen = line.geometry.parameters.height; // original cylinder height
    const floorZ      = 0.0;      // ground plane (Z-up)
    const bottomPad   = 0.0005;   // tiny lift to avoid z-fighting
    const _eePosTmp   = new THREE.Vector3();

    /* ---------- two yellow drop lines from gripper finger tips ---------- */

    // If you want the lines to end at exactly z=0, keep this at 0.0.
    // If you see z-fighting flicker, bump it up slightly (e.g., 0.0005).
    const fingerBottomPad = 0.0;

    // Shared yellow material (semi‚Äëtransparent)
    const fingerLineMat = new THREE.MeshBasicMaterial({
      color: 0xffcc00, transparent: true, opacity: 0.8
    });

    // Helper to build a vertical cylinder whose local Y maps to world Z (like the green line)
    function makeDownLine(material){
      const m = new THREE.Mesh(
        new THREE.CylinderGeometry(lineRad, lineRad, lineLen, 8, 1, true),
        material
      );
      m.rotation.x = Math.PI / 2;   // align cylinder Y ‚Üí world Z
      m.visible = false;
      scene.add(m);
      return m;
    }

    const leftFingerLine  = makeDownLine(fingerLineMat);
    const rightFingerLine = makeDownLine(fingerLineMat);

    // Cache references to the finger links in the URDF
    // (Rename here if your URDF uses different link names)
    const leftFingerLink  = robot.getObjectByName('gripper_left');
    const rightFingerLink = robot.getObjectByName('gripper_right');


    /* ---- red sphere exactly at that pose ---------------------- */
    const marker = new THREE.Mesh(
      new THREE.SphereGeometry( 0.005, 16, 16 ),
      new THREE.MeshStandardMaterial( { color: 0xff0000 } )
    );
    marker.position.copy    ( startPos  );
    marker.quaternion.copy  ( startQuat );
    scene.add( marker );

    // Make the dot easy to pick: invisible, larger hit target
    const pickProxy = new THREE.Mesh(
      new THREE.SphereGeometry(0.02, 16, 16), // ~2cm radius hit area
      new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0, depthWrite: false })
    );
    pickProxy.name = 'marker_pick_proxy';
    marker.add(pickProxy);

    // ===== Rotation wheels (roll/pitch/yaw) ‚Äî helpers & state =====
    const rotationWheels = {};        // { roll:{group, segments:Mesh[]}, pitch:{...}, yaw:{...} }
    let rotationPickables = [];       // flat list of all wheel segment meshes for raycasting

    // Visual states for wheels
    const WHEEL_OPACITY = {
      idle:   { even: 0.44, odd: 0.24 },
      hover:  { even: 0.64, odd: 0.44 },
      active: { even: 0.84, odd: 0.64 },
    };

    // Build one wheel (striped annulus) for an axis
    function makeWheel(axisName, colorHex, innerR=0.065, outerR=0.085, strips=48) {
      const group = new THREE.Group();
      group.name = `wheel_${axisName}`;
      group.userData.axis = axisName;
      group.renderOrder = 999; // draw above everything
      const segments = [];

      const segAngle = (Math.PI * 2) / strips;
      const gap = segAngle * 0.08;               // subtle gaps between strips
      const thetaLen = segAngle - gap;

      for (let i = 0; i < strips; i++) {
        const thetaStart = i * segAngle + gap * 0.5;
        const geom = new THREE.RingGeometry(innerR, outerR, 18, 1, thetaStart, thetaLen);
        const mat = new THREE.MeshBasicMaterial({
          color: colorHex,
          transparent: true,
          opacity: (i % 2 === 0 ? WHEEL_OPACITY.idle.even : WHEEL_OPACITY.idle.odd),
          side: THREE.DoubleSide,
          depthTest: false,   // always visible
        });
        const seg = new THREE.Mesh(geom, mat);
        seg.userData.axis = axisName; // so picking any segment knows its axis
        group.add(seg);
        segments.push(seg);
      }

      return { group, segments };
    }

    function setWheelState(axis, state /* idle|hover|active */) {
      const w = rotationWheels[axis]; if (!w) return;
      const cfg = WHEEL_OPACITY[state] || WHEEL_OPACITY.idle;
      w.segments.forEach((seg, i) => {
        seg.material.opacity = (i % 2 === 0 ? cfg.even : cfg.odd);
        seg.material.needsUpdate = true;
      });
    }
    function resetAllWheelStates() {
      ['roll','pitch','yaw'].forEach(a => setWheelState(a, 'idle'));
    }

    // Build and mount all wheels that are enabled by activeControls
    function buildRotationWheels() {
      rotationPickables.length = 0;
      // pleasant, readable axis colors
      const colorFor = { roll: 0xff5b5b, pitch: 0x22cc88, yaw: 0x4f8cff };

      ['roll','pitch','yaw'].forEach(axis => {
        if (!activeControls.includes(axis)) return;
        const { group, segments } = makeWheel(axis, colorFor[axis]);
        scene.add(group);
        rotationWheels[axis] = { group, segments };
        rotationPickables.push(...segments);
      });

      resetAllWheelStates();
    }

    // World-space local axes from the marker‚Äôs orientation
    function localAxesWorld() {
      const q = marker.quaternion;
      return {
        xW: new THREE.Vector3(1,0,0).applyQuaternion(q).normalize(),
        yW: new THREE.Vector3(0,1,0).applyQuaternion(q).normalize(),
        zW: new THREE.Vector3(0,0,1).applyQuaternion(q).normalize(),
      };
    }

    // For a given axis name, return plane normal n and in-plane orthonormal basis u,v
    function planeBasisForAxis(axis) {
      const { xW, yW, zW } = localAxesWorld();
      if (axis === 'roll')   return { n: xW, u: yW, v: zW }; // rotate about local X ‚Üí YZ plane
      if (axis === 'pitch')  return { n: yW, u: zW, v: xW }; // rotate about local Y ‚Üí XZ plane
      /* yaw */              return { n: zW, u: xW, v: yW }; // rotate about local Z ‚Üí XY plane
    }
    function alignRingToNormal(group, n) {
      const from = new THREE.Vector3(0,0,1); // RingGeometry faces +Z by default
      const q = new THREE.Quaternion().setFromUnitVectors(from, n);
      group.quaternion.copy(q);
      group.updateMatrixWorld(true);
    }

    function angleOnPlaneFromPoint(p, center, u, v) {
      const r = p.clone().sub(center);
      return Math.atan2(r.dot(v), r.dot(u));
    }
    function normalizeAngle(a) {
      while (a >  Math.PI) a -= Math.PI * 2;
      while (a < -Math.PI) a += Math.PI * 2;
      return a;
    }

    // Build wheels now that the marker exists
    buildRotationWheels();
    // ===== Rotation wheels ‚Äî helpers & state (end) =====


    /* 2) build lil-GUI sliders ----------------------------------- */
    const startEuler = new THREE.Euler().setFromQuaternion(startQuat, 'XYZ');
    const params = {
      x: startPos.x, y: startPos.y, z: startPos.z,
      // roll:  startEuler.x,
      // pitch: startEuler.y,
      // yaw:   startEuler.z
      roll:  0.0,
      pitch: 0.0,
      yaw:   0.0
    };

    // Record the starting values once; used to detect "pose unchanged"
    const initialParams = {
      x: params.x, y: params.y, z: params.z,
      roll: params.roll, pitch: params.pitch, yaw: params.yaw
    };
    // Only check the controls that are present
    const poseAxes = ['x','y','z','roll','pitch','yaw'].filter(k => activeControls.includes(k));
    const EPS = 1e-6; // tolerance for float comparisons
    function approximatelyEqual(a,b,eps=EPS){ return Math.abs(a - b) <= eps; }
    function getChangedAxes(){ return poseAxes.filter(k => !approximatelyEqual(params[k], initialParams[k])); }
    function slidersAtDefault(){ return getChangedAxes().length === 0; }

    function updateGoal() {
      /* position */
      goal.setPosition(params.x, params.y, params.z);
      marker.position.set(params.x, params.y, params.z);

      /* orientation */
      const dRoll  = params.roll  - lastAngles.roll;
      const dPitch = params.pitch - lastAngles.pitch;
      const dYaw   = params.yaw   - lastAngles.yaw;

      // Only update if there was any change (avoids drift)
      if (dRoll !== 0 || dPitch !== 0 || dYaw !== 0) {
        // Increment defined in local axes with the same XYZ order
        const inc = new THREE.Quaternion().setFromEuler(
          new THREE.Euler(dRoll, dPitch, dYaw, 'XYZ')
        );
        // Local (body) rotation: post-multiply
        currentQuat.multiply(inc).normalize();
        lastAngles.roll  = params.roll;
        lastAngles.pitch = params.pitch;
        lastAngles.yaw   = params.yaw;
      }

      goal.setQuaternion(currentQuat.x, currentQuat.y, currentQuat.z, currentQuat.w);
      marker.quaternion.copy(currentQuat);

      // On first slider interaction: reveal the robot and update button label
      if (!robotVisible) {
        robotVisible = true;
        robot.visible = true;
        if (toggleRobotBtn) toggleRobotBtn.textContent = 'hide robot model';
      }

      updateGripperInteractivity();
    }

    // ---------- Drag helpers ----------
    const raycaster = new THREE.Raycaster();
    const ndc = new THREE.Vector2();

    const DRAG_SPECS = {
      front:       { axes: ['y','z'], normal: new THREE.Vector3(1,0,0) }, // lock X ‚Üí move on YZ
      left:        { axes: ['x','z'], normal: new THREE.Vector3(0,1,0) }, // lock Y ‚Üí move on XZ
      right:       { axes: ['x','z'], normal: new THREE.Vector3(0,1,0) }, // lock Y ‚Üí move on XZ
      perspective: { axes: ['x','y'], normal: new THREE.Vector3(0,0,1) }, // lock Z ‚Üí move on XY
    };

    function specForView(name){
      return DRAG_SPECS[name] || DRAG_SPECS.perspective;
    }

    function setNDCFromPointerEvent(evt, renderer){
      const rect = renderer.domElement.getBoundingClientRect();
      ndc.x =  ( (evt.clientX - rect.left) / rect.width ) * 2 - 1;
      ndc.y = -( (evt.clientY - rect.top)  / rect.height) * 2 + 1;
    }

    function clampToSlider(axis, v){
      const r = sliderRanges[axis];
      if (!r) return v;
      return Math.min(r.max, Math.max(r.min, v));
    }

    function updateSlidersDisplay(axes){
      axes.forEach(a => sliderCtrls[a]?.updateDisplay());
    }

    // Single shared drag state
    // Single shared drag state (translation or rotation)
    const dragState = {
      active: false,
      mode: null,                // 'translate' | 'rotate'
      view: null,
      plane: new THREE.Plane(),  // used both for translate & rotate
      axes: /** @type {('x'|'y'|'z')[]} */([]), // translation axes (two on a plane)
      axis: /** @type {'roll'|'pitch'|'yaw'|null} */(null), // rotation axis
      pointerId: null,

      // rotation-specific
      u: new THREE.Vector3(),
      v: new THREE.Vector3(),
      angle0: 0,
      param0: 0,
    };


    function attachDragHandlersToView(view){
      const el = view.renderer.domElement;

      function pickAll(evt) {
        setNDCFromPointerEvent(evt, view.renderer);
        raycaster.setFromCamera(ndc, view.camera);
        // Highest priority: wheel segments, then the dot proxy, then the dot itself
        const targets = [
          ...rotationPickables,
          marker.getObjectByName('marker_pick_proxy'),
          marker
        ].filter(Boolean);
        return raycaster.intersectObjects(targets, true);
      }

      // Hover: cursor + wheel highlight
      el.addEventListener('pointermove', (evt) => {
        if (dragState.active || calibrationMode) return;

        const hits = pickAll(evt);
        const wheelHit = hits.find(h => h.object?.userData?.axis);
        const dotHit   = hits.find(h => (h.object === marker) || (h.object?.name === 'marker_pick_proxy'));

        // Visual: highlight hovered wheel (others idle)
        resetAllWheelStates();
        if (wheelHit) {
          setWheelState(wheelHit.object.userData.axis, 'hover');
          el.style.cursor = 'grab';
        } else if (dotHit) {
          el.style.cursor = 'grab';
        } else {
          el.style.cursor = 'default';
        }
      });

      el.addEventListener('pointerdown', (evt) => {
        if (calibrationMode) return;

        const hits = pickAll(evt);
        if (!hits.length) return;

        // Decide mode by topmost hit
        const top = hits[0];
        const hitAxis = top.object?.userData?.axis || null;

        dragState.active    = true;
        dragState.view      = view;
        dragState.pointerId = evt.pointerId;
        el.setPointerCapture(dragState.pointerId);
        el.style.cursor = 'grabbing';

        currentViewName = view.name; // keep other UI in sync
        updateGripArrowVisibility();

        if (hitAxis) {
          // === ROTATION DRAG ===
          dragState.mode = 'rotate';
          dragState.axis = /** @type {'roll'|'pitch'|'yaw'} */(hitAxis);

          const { n, u, v } = planeBasisForAxis(dragState.axis);
          dragState.u.copy(u); dragState.v.copy(v);
          dragState.plane.setFromNormalAndCoplanarPoint(n, marker.position);

          const hitPt = new THREE.Vector3();
          raycaster.ray.intersectPlane(dragState.plane, hitPt);
          dragState.angle0 = angleOnPlaneFromPoint(hitPt, marker.position, dragState.u, dragState.v);
          dragState.param0 = params[dragState.axis];

          resetAllWheelStates();
          setWheelState(dragState.axis, 'active');
        } else {
          // === TRANSLATION DRAG === (dot)
          dragState.mode = 'translate';

          const spec = specForView(view.name);       // which axes to move in this view
          dragState.axes = spec.axes;
          dragState.plane.setFromNormalAndCoplanarPoint(spec.normal, marker.position);
        }

        evt.preventDefault();
      });

      el.addEventListener('pointermove', (evt) => {
        if (!dragState.active || dragState.view !== view) return;

        setNDCFromPointerEvent(evt, view.renderer);
        raycaster.setFromCamera(ndc, view.camera);

        const hitPoint = new THREE.Vector3();
        if (!raycaster.ray.intersectPlane(dragState.plane, hitPoint)) return;

        if (dragState.mode === 'translate') {
          // Move the two allowed axes directly
          dragState.axes.forEach(axis => {
            const v = axis === 'x' ? hitPoint.x : axis === 'y' ? hitPoint.y : hitPoint.z;
            params[axis] = clampToSlider(axis, v);
          });
          updateGoal();
          updateSlidersDisplay(dragState.axes);
        } else if (dragState.mode === 'rotate' && dragState.axis) {
          // Angle delta on plane
          const ang1 = angleOnPlaneFromPoint(hitPoint, marker.position, dragState.u, dragState.v);
          const dAng = normalizeAngle(ang1 - dragState.angle0);
          let newVal = dragState.param0 + dAng;
          newVal = clampToSlider(dragState.axis, newVal);

          params[dragState.axis] = newVal;
          updateGoal();
          sliderCtrls[dragState.axis]?.updateDisplay();
        }

        evt.preventDefault();
      });

      function endDrag(){
        if (!dragState.active) return;
        try { el.releasePointerCapture(dragState.pointerId); } catch(_) {}
        dragState.active = false;
        const endedAxis = dragState.axis;
        dragState.mode  = null;
        dragState.axis  = null;
        dragState.view  = null;
        dragState.axes  = [];
        el.style.cursor = 'default';

        // After drag, leave hover highlight if still under cursor
        const fakeEvt = { clientX: window._lastMouseX ?? 0, clientY: window._lastMouseY ?? 0 };
        // best-effort hover restore
        resetAllWheelStates();
        if (endedAxis) setWheelState(endedAxis, 'hover');
      }

      // Track mouse position globally to re-evaluate hover after drag end
      el.addEventListener('pointermove', (e)=> { window._lastMouseX = e.clientX; window._lastMouseY = e.clientY; });

      el.addEventListener('pointerup',       endDrag);
      el.addEventListener('pointercancel',   endDrag);
      el.addEventListener('pointerleave',    (e)=>{ if (dragState.active) endDrag(); });
    }



    /* ---------- camera-view buttons --------------------------- */
    function poseToMatrix(mat){
      return new THREE.Matrix4().set(
        mat[0][0], mat[0][1], mat[0][2], mat[0][3],
        mat[1][0], mat[1][1], mat[1][2], mat[1][3],
        mat[2][0], mat[2][1], mat[2][2], mat[2][3],
        mat[3][0], mat[3][1], mat[3][2], mat[3][3],
      );
    }

    function selectView(viewName) {
      // Remove selection from all views
      views.forEach(view => {
        view.container.classList.remove('selected');
      });
      
      // Select the new view
      const view = views.get(viewName);
      if (view) {
        // Only show visual selection highlighting in devMode
        if (devMode) {
          view.container.classList.add('selected');
        }
        currentViewName = viewName;
        
        // Update gripper arrow visibility based on selected view
        updateGripArrowVisibility();
        
        if (calibrationMode) {
          destroyCalibGUI();
          enterCalibration();
        }
      }
    }

    function initializeViews() {
      // Clear existing views
      views.clear();
      viewsGrid.innerHTML = '';
      
      // Get available camera poses and textures
      const availableViews = [];
      Object.keys(camPoses).forEach(poseKey => {
        const viewName = poseKey.replace('_pose', '');
        if (viewTextures[viewName] && cameraModels[viewName]) {
          availableViews.push({
            name: viewName,
            poseKey: poseKey,
            texture: viewTextures[viewName],
            model: cameraModels[viewName],
            pose: camPoses[poseKey]
          });
        }
      });
      
      console.log(`[DEBUG] availableViews:`, availableViews.map(v => v.name));
      
      if (availableViews.length === 0) return;
      
      // Setup grid layout
      setupViewportGrid(availableViews.length);
      
      // Create views
      availableViews.forEach((viewInfo, index) => {
        const view = createViewRenderer(viewInfo.name, viewInfo.model, viewInfo.texture);
        attachDragHandlersToView(view);
        
        // Set up camera pose and projection
        updateViewCamera(view, viewInfo.pose);
        applyProjectionFromK(view);
        
        // For 3 views, hide the 4th grid position
        if (availableViews.length === 3 && index === 2) {
          view.container.style.gridColumn = '1 / -1';
          view.container.style.justifySelf = 'center';
        }
      });
      
      // Update sizes and select first view
      updateViewSizes();
      if (availableViews.length > 0) {
        // In devMode, select the first view for visual feedback
        // In regular mode, just set currentViewName without visual selection
        if (devMode) {
          selectView(availableViews[0].name);
        } else {
          currentViewName = availableViews[0].name;
          console.log(`[DEBUG] Initial currentViewName set to: "${currentViewName}"`);
          updateGripArrowVisibility(); // Update arrow visibility for initial view
        }
      }
    }

    const btnBar   = document.createElement('div');
    btnBar.style.position = 'fixed';
    btnBar.style.top = '8px';
    btnBar.style.left = '8px';
    btnBar.style.zIndex = 10;
    btnBar.style.display = 'flex';
    btnBar.style.gap = '4px';
    document.body.appendChild( btnBar );

    /* add camera selection buttons (only if devMode enabled) */
    if (devMode) {
      Object.keys(camPoses).forEach(poseKey=>{
        const viewName = poseKey.replace('_pose', '');
        const b       = document.createElement('button');
        b.textContent = viewName; // "left", "right", ‚Ä¶
        b.onclick     = ()=> selectView(viewName);
        btnBar.appendChild( b );
      });
    }

    /* add calibrate toggle button (only if devMode enabled) */
    if (devMode) {
      const calibrateBtn = document.createElement('button');
      calibrateBtn.textContent = 'calibrate';
      calibrateBtn.onclick = () => {
        if (!calibrationMode) {
          if (!currentViewName) { alert('Pick a camera view first (front/left/right/...).'); return; }
          enterCalibration();
          calibrateBtn.textContent = 'exit calibration';
        } else {
          exitCalibration();
          calibrateBtn.textContent = 'calibrate';
        }
      };
      btnBar.appendChild(calibrateBtn);
    }

    /* add hide/show robot model button (bottom-left corner) (only if devMode enabled) */
    if (devMode) {
      toggleRobotBtn = document.createElement('button');
      toggleRobotBtn.textContent = 'show robot model';
      toggleRobotBtn.style.position = 'fixed';
      toggleRobotBtn.style.left     = '8px';
      toggleRobotBtn.style.bottom   = '8px';
      toggleRobotBtn.style.zIndex   = 10;
      document.body.appendChild(toggleRobotBtn);

      toggleRobotBtn.onclick = () => {
        robotVisible = !robotVisible;
        robot.visible = robotVisible;
        toggleRobotBtn.textContent = robotVisible
          ? 'hide robot model'
          : 'show robot model';
      };

      toggleRobotBtn.textContent = 'show robot model';
    }

    /* ---------- confirm button (lower-right corner) ------------------- */

    // Initialize the multi-view system
    initializeViews();

  /* ---------- confirm button (inside controls container) ------------------- */

    // Create confirm button to be added to controls container
    const confirmBtn = document.createElement('button');
    confirmBtn.textContent = 'Confirm';
    confirmBtn.className = 'confirm-button';

    confirmBtn.onclick = async () => {
      /* gather current joint values (radians / metres) */
      const jointMap = {};
      Object.entries(robot.joints).forEach(([name, joint]) => {
        jointMap[name] = joint.jointValue;
      });

      /* gather current end-effector pose (world frame) */
      robot.updateMatrixWorld(true);             // ensure transforms are fresh
      const eePos  = new THREE.Vector3();
      const eeQuat = new THREE.Quaternion();
      eeVis.getWorldPosition   (eePos);
      eeVis.getWorldQuaternion (eeQuat);
      const eeEuler = new THREE.Euler().setFromQuaternion(eeQuat, "XYZ");

      try {
        const response = await apiFetch(`/api/submit-goal`, {
          method: 'POST',
          headers: { 
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            joint_positions: jointMap,
            gripper:         gripDir,                // -1 / +1 / 0
            ee_pose: {                               // added  ‚§µ
              position:   [eePos.x,  eePos.y,  eePos.z],
              rpy: [eeEuler.x, eeEuler.y, eeEuler.z]
            },
            state_id: state.state_id,                // include state_id for tracking
            episode_id: state.episode_id             // include episode_id for proper routing
          })
        });
        
        if (response.ok) {
          console.log('‚úÖ goal sent');
          // Start 5-second countdown with progress bar before refreshing
          delayedRefresh(5000);
        } else {
          console.error('‚ùå failed to send goal - server error:', response.status);
        }
      } catch (err) {
        console.error('‚ùå failed to send goal', err);
      }
    };

    const spanDefs = [
      ['x',     0.20],   // meters
      ['y',     0.20],
      ['z',     0.20],
      ['roll',  1.0],   // radians
      ['pitch', 0.81],
      ['yaw',   0.81],
    ];

    // Keep references so dragging can clamp to slider ranges & update displays
    const sliderCtrls   = {};  // axis -> lil-gui controller
    const sliderCenters = {};  // axis -> center value
    const sliderRanges  = {};  // axis -> {min, max}

    spanDefs.forEach(([key, span])=>{
      if (!activeControls.includes(key)) return;
      const center = params[key];          // start-pose value
      const controller = gui.add(params, key, center - span, center + span)
        .onChange(updateGoal);

      // Save references for drag interaction
      sliderCtrls[key]   = controller;
      sliderCenters[key] = center;
      sliderRanges[key]  = { min: center - span, max: center + span };

      // Add reset button to each slider
      setTimeout(() => {
        const controllerEl = controller.domElement;
        if (controllerEl) {
          const resetBtn = document.createElement('button');
          resetBtn.textContent = '‚ü≤';
          resetBtn.className = 'reset-btn';
          resetBtn.title = `Reset ${key} to default`;
          resetBtn.onclick = (e) => {
            e.preventDefault();
            e.stopPropagation();
            params[key] = center; // Reset to initial center value
            controller.updateDisplay();
            updateGoal();
          };
          controllerEl.appendChild(resetBtn);
        }
      }, 0);
    });


    // Add gripper buttons after sliders
    if (gripperButtonsContainer) {
      controlsContainer.appendChild(gripperButtonsContainer);
      updateGripperButtonStates(); // Set initial button states
    }

    // Evaluate initial interactivity (usually enabled because sliders = defaults)
    updateGripperInteractivity();

    // Add confirm button at the bottom
    controlsContainer.appendChild(confirmBtn);

    // Create "Task Already Completed" button in a separate container
    const taskCompletedContainer = document.createElement('div');
    taskCompletedContainer.className = 'task-completed-container';

    // Add title/label above the button
    const taskCompletedTitle = document.createElement('div');
    taskCompletedTitle.textContent = 'In fact, no need to move because...';
    taskCompletedTitle.style.fontSize = '14px';
    taskCompletedTitle.style.fontWeight = '500';
    taskCompletedTitle.style.color = '#374151';
    taskCompletedTitle.style.marginBottom = '8px';
    taskCompletedTitle.style.textAlign = 'left';
    taskCompletedTitle.style.fontFamily = 'system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans"';

    const taskCompletedBtn = document.createElement('button');
    taskCompletedBtn.textContent = 'Task Already Completed';
    taskCompletedBtn.className = 'task-completed-button';

    taskCompletedBtn.onclick = async () => {
      try {
        const response = await apiFetch(`/api/task-already-completed`, {
          method: 'POST',
          headers: { 
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            state_id: state.state_id,  // Send the current state_id
            episode_id: state.episode_id,  // Send the current episode_id
            task_already_completed: true
          })
        });
        
        if (response.ok) {
          console.log('‚úÖ Task already completed response sent');
          // Start 5-second countdown with progress bar before refreshing
          delayedRefresh(5000);
        } else {
          const errorData = await response.json();
          console.error('‚ùå Failed to send task already completed response:', errorData);
          alert('Failed to submit response. Please try again.');
        }
      } catch (err) {
        console.error('‚ùå Failed to send task already completed response', err);
        alert('Failed to submit response. Please try again.');
      }
    };

    taskCompletedContainer.appendChild(taskCompletedTitle);
    taskCompletedContainer.appendChild(taskCompletedBtn);
    controlsWrapper.appendChild(taskCompletedContainer);

    // Update layout based on number of active controls
    function updateControlsLayout() {
      const numSliders = activeControls.filter(ctrl => ['x', 'y', 'z', 'roll', 'pitch', 'yaw'].includes(ctrl)).length;
      const hasGripper = activeControls.includes('gripper');
      const totalControls = numSliders + (hasGripper ? 1 : 0) + 1; // +1 for confirm button
      
      if (totalControls > 1) { // Always show if we have sliders + confirm
        controlsContainer.style.display = 'block';
        controlsWrapper.style.display = 'flex';
        taskCompletedContainer.style.display = 'block';
        
        if (totalControls === 2 && numSliders === 1) { // 1 slider + confirm
          mount.className = 'single-slider';
        } else {
          mount.className = 'multiple-sliders';
        }
      } else {
        controlsContainer.style.display = 'none';
        controlsWrapper.style.display = 'none';
        taskCompletedContainer.style.display = 'none';
        mount.className = '';
      }
    }
    
    updateControlsLayout();


    /* --- solver --- */
    const solver = new Solver(ikRoot);                // constructor takes root
    // (solver settings default to 5 iterations, etc.)

    /* --- animation loop --- */
    function animate() {
      requestAnimationFrame(animate);

      setIKFromUrdf(ikRoot, robot);   // URDF ‚ûú IK                                         :contentReference[oaicite:1]{index=1}
      solver.solve();                 // run DLS IK
      setUrdfFromIK(robot, ikRoot);   // IK ‚ûú URDF                                         :contentReference[oaicite:2]{index=2}

      // --- align the green line so its bottom sits on the ground ---
      eeVis.getWorldPosition(_eePosTmp);
      // Effective vertical length (Z-up), clamped to ‚â• 0 with a small gap from the floor
      let len = _eePosTmp.z - (floorZ + bottomPad);
      if (len <= 0) {
        line.visible = false;             // EE at/below floor ‚Üí hide
      } else {
        line.visible = true;
        // Scale along local Y (already rotated to world Z)
        line.scale.y = len / baseLineLen;
        // Center of cylinder should be midway between EE.z and floorZ+pad
        const midZ = (floorZ + bottomPad) + 0.5 * len;
        line.position.set(_eePosTmp.x + lineOffX, _eePosTmp.y, midZ);
      }

      function updateFingerLine(link, lineMesh, localTipVec){
        if (!link) { lineMesh.visible = false; return; }

        link.updateMatrixWorld(true);

        // World-space tip position from the calibrated local offset
        const tipWorld = localTipVec.clone().applyMatrix4(link.matrixWorld);

        const lenToFloor = tipWorld.z - (floorZ + fingerBottomPad);
        if (lenToFloor <= 0) {
          lineMesh.visible = false;
          return;
        }

        lineMesh.visible = true;
        lineMesh.scale.y = lenToFloor / baseLineLen;
        const midZ = (floorZ + fingerBottomPad) + 0.5 * lenToFloor;

        // Place directly under each finger tip
        lineMesh.position.set(tipWorld.x, tipWorld.y, midZ);
      }

      // Update both finger lines each frame
      updateFingerLine(leftFingerLink,  leftFingerLine,  fingerTipLocalLeft);
      updateFingerLine(rightFingerLink, rightFingerLine, fingerTipLocalRight);


      
      // Update gripper arrow positions based on robot link positions
      gripArrows.forEach(arrow => {
        const link = arrow.userData.targetLink;
        const originLocal = arrow.userData.originLocal;
        const dirLocal = arrow.userData.dirLocal;
        
        if (link) {
          // Get the world transform of the target link
          link.updateMatrixWorld(true);
          
          // Transform the local position to world coordinates
          const worldPos = originLocal.clone().applyMatrix4(link.matrixWorld);
          arrow.position.copy(worldPos);
          
          // Transform the local direction to world coordinates
          const worldDir = dirLocal.clone().transformDirection(link.matrixWorld);
          arrow.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), worldDir);
        }
      });
      
      // Update gripper arrow visibility based on current view
      updateGripArrowVisibility();

      (function updateWheels(){
        const pos = marker.position;
        const { xW, yW, zW } = localAxesWorld();

        if (rotationWheels.roll) {
          rotationWheels.roll.group.position.copy(pos);
          alignRingToNormal(rotationWheels.roll.group, xW);
        }
        if (rotationWheels.pitch) {
          rotationWheels.pitch.group.position.copy(pos);
          alignRingToNormal(rotationWheels.pitch.group, yW);
        }
        if (rotationWheels.yaw) {
          rotationWheels.yaw.group.position.copy(pos);
          alignRingToNormal(rotationWheels.yaw.group, zW);
        }
      })();
      
      // Render all views
      views.forEach(view => {
        // Set the background texture for this specific view
        scene.background = view.texture ?? defaultBg;
        view.renderer.render(scene, view.camera);
      });
    }
    animate();
  }
);

/* ---------- responsive canvas ---------- */
addEventListener('resize', () => {
  // Re-center the viewport and update view sizes
  updateViewSizes();
});
</script></body></html>
