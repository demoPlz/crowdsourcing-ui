<!-- wxai_min.html  –  minimal translate-only IK demo -->
<!DOCTYPE html><html lang="en"><head>
<meta charset="utf-8" />
<title>WidowX AI — position IK only</title>
<style>html,body{margin:0;height:100%;overflow:hidden}</style>

<!-- Polyfill so the import-map works everywhere -->
<script async src="https://cdn.jsdelivr.net/npm/es-module-shims@2/dist/es-module-shims.js"></script>

<script type="importmap">
{
  "imports": {
    "three":               "https://cdn.jsdelivr.net/npm/three@0.165/build/three.module.js",
    "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.165/examples/jsm/",
    "urdf-loader":         "https://cdn.jsdelivr.net/npm/urdf-loader@0.12.6/src/URDFLoader.js?module",
    "closed-chain-ik":     "https://cdn.jsdelivr.net/npm/closed-chain-ik@0.18.0/dist/index.module.js"
  }
}
</script></head><body>
<script type="module">
/* ---------- imports ---------- */
import * as THREE                    from 'three';
import { OrbitControls }             from 'three/examples/jsm/controls/OrbitControls.js';
import URDFLoader                    from 'urdf-loader';
import {
  urdfRobotToIKRoot,
  setIKFromUrdf,
  setUrdfFromIK,
  Goal,
  Solver,
  DOF
} from 'closed-chain-ik';

import {GUI} from 'three/examples/jsm/libs/lil-gui.module.min.js';

async function getInitialState() {
  try {
    const response = await fetch('http://127.0.0.1:9000/api/get-state');
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return await response.json();
  } catch (error) {
    console.error("Could not fetch initial state:", error);
    return {};
  }
}

/* ---------- scene ---------- */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xf5f5f5);
scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1));

const dir = new THREE.DirectionalLight(0xffffff, 1.2);
dir.position.set(2, 4, 2);
scene.add(dir);

/* ---------- floor / workspace visual -------------------- */
// light, neutral grid on the ground (y = 0)
const grid = new THREE.GridHelper(
  2.0,   // size in meters
  20,    // subdivisions
  0x888888, // center line
  0xb0b0b0  // grid lines
);
grid.position.y = 0;          // align with ground plane
scene.add(grid);

const axes = new THREE.AxesHelper(0.3);
scene.add(axes);

const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.01, 100);
camera.position.set(1.5, 1.5, 1.5);

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
document.body.appendChild(renderer.domElement);

const orbit = new OrbitControls(camera, renderer.domElement);
orbit.target.set(0, 0, 0)
orbit.update();
orbit.saveState();

/* ---------- load URDF ---------- */
const loader = new URDFLoader();
loader.packages = {                 // map package:// paths → server paths
  'trossen_arm_description': 'assets/trossen_arm_description'
};

loader.load(
  'assets/trossen_arm_description/urdf/generated/wxai/wxai_base.urdf',
  async robot => {

    scene.add(robot);

    /* --- build IK tree from URDF (limits copied automatically) --- */
    const ikRoot = urdfRobotToIKRoot(robot);          // :contentReference[oaicite:0]{index=0}

    ikRoot.clearDoF()

    const state = await getInitialState();
    const initialJointPositions = state.joint_positions ?? {};
    const activeControls        = state.controls ?? ['x','y','z','roll','pitch','yaw'];
    for (const [name, val] of Object.entries(initialJointPositions)) {
      robot.setJointValue(name, val);
    }

    /* ---------- gripper-motion arrows ---------------------------------- */
    const gripperMotion = state.gripper ?? 0;          // +1 open, –1 close, 0 none
    if (gripperMotion) {
      const colour = gripperMotion > 0 ? 0x00ff00 : 0xff0000;  // green ↔ red
      const len    = 0.08;       // arrow length  (m)
      const headLen   = 0.04;       // head length   (m)
      const shaftLen = len - headLen; // length of the shaft
      const shaftRad = 0.01;
      const offset = 0.00;       // how far the arrow sits from finger centre

      /** add one arrow to the given finger link.
       *  `outward` is +1 for left finger ( +Y ), −1 for right finger ( −Y ) */
      function addArrow(linkName, outward) {
        const link = robot.getObjectByName(linkName);
        if (!link) return;

        // direction in the *link’s local frame*
        const dirLocal    = new THREE.Vector3(0, gripperMotion * outward, 0).normalize();
        
        const tipX = 0.04; // Distance from tip of end-effector

        const baseDist = gripperMotion > 0 ? offset
                                           : offset + len
        const originLocal = new THREE.Vector3(tipX, outward * baseDist, 0);  // sit outside

        const arrow = new THREE.ArrowHelper(dirLocal, originLocal, len, colour,
                                            headLen, headLen * 0.6);
        /* build custom arrow so shaft thickness is under our control ---- */
        const grp  = new THREE.Group();

        // shaft (cylinder)
        const shaftGeo = new THREE.CylinderGeometry(shaftRad, shaftRad,
                                                    shaftLen, 8, 1, true);
        const mat      = new THREE.MeshBasicMaterial({ color: colour });
        const shaft    = new THREE.Mesh(shaftGeo, mat);
        shaft.position.y = shaftLen / 2;      // centre along +Y
        grp.add(shaft);

        // head (cone)
        const coneGeo  = new THREE.ConeGeometry(headLen * 0.6, headLen, 8);
        const cone     = new THREE.Mesh(coneGeo, mat);
        cone.position.y = shaftLen + headLen / 2;
        grp.add(cone);

        // orient whole arrow & attach to finger link
        grp.position.copy(originLocal);
        grp.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dirLocal);
        link.add(grp);
      }

      addArrow('gripper_left',  +1);   // left finger (+Y)
      addArrow('gripper_right', -1);   // right finger (−Y)
    }

    const camPoses = state.camera_poses ?? {}

    setIKFromUrdf(ikRoot, robot);
    ikRoot.updateMatrixWorld(true);

    /* --- locate the end-effector link inside IK tree --- */
    let ee = null;
    
    ikRoot.traverse(child => {                        // Frame.traverse
      if ( child.name === 'ee_gripper_link' ) { ee = child; return true; }
    });

    /* --- create a translation-only Goal --- */
    const goal = new Goal();
    goal.setDoF(DOF.X, DOF.Y, DOF.Z, DOF.EX, DOF.EY, DOF.EZ);

    goal.makeClosure( ee );                          // link goal ↔ ee

    /* ---- sample the **visual** EE pose after matrices are fresh */
    const startPos  = new THREE.Vector3();
    const startQuat = new THREE.Quaternion();

    robot.updateMatrixWorld( true );                 // propagate world mats
    const eeVis = robot.getObjectByName( 'ee_gripper_link' );
    eeVis.getWorldPosition   ( startPos  );
    eeVis.getWorldQuaternion ( startQuat );

    goal.setPosition   ( startPos.x, startPos.y, startPos.z );
    goal.setQuaternion ( startQuat.x, startQuat.y, startQuat.z, startQuat.w );

    /* ---- red sphere exactly at that pose ---------------------- */
    // const marker = new THREE.Mesh(
    //   new THREE.SphereGeometry( 0.02, 16, 16 ),
    //   new THREE.MeshStandardMaterial( { color: 0xff0000 } )
    // );
    // marker.position.copy    ( startPos  );
    // marker.quaternion.copy  ( startQuat );
    // scene.add( marker );

    /* 2) build lil-GUI sliders ----------------------------------- */
    const startEuler = new THREE.Euler().setFromQuaternion(startQuat, 'XYZ');
    const params = {
      x: startPos.x, y: startPos.y, z: startPos.z,
      roll:  startEuler.x,
      pitch: startEuler.y,
      yaw:   startEuler.z
    };

    function updateGoal() {
      /* position */
      goal.setPosition(params.x, params.y, params.z);
      // marker.position.set(params.x, params.y, params.z);

      /* orientation */
      const quat = new THREE.Quaternion().setFromEuler(
        new THREE.Euler(params.roll, params.pitch, params.yaw, 'XYZ')
      );
      goal.setQuaternion(quat.x, quat.y, quat.z, quat.w);
      // marker.quaternion.copy(quat);
    }

    /* ---------- camera-view buttons --------------------------- */
    function poseToMatrix(mat){
      return new THREE.Matrix4().set(
        mat[0][0], mat[0][1], mat[0][2], mat[0][3],
        mat[1][0], mat[1][1], mat[1][2], mat[1][3],
        mat[2][0], mat[2][1], mat[2][2], mat[2][3],
        mat[3][0], mat[3][1], mat[3][2], mat[3][3],
      );
    }

    function switchCamera (key){
      if (key === 'orbit') {
        orbit.enabled = true;
        orbit.reset();
        return;
      }
      if (!camPoses[key]) return;
      const m = poseToMatrix( camPoses[key] );
      const pos   = new THREE.Vector3();
      const quat  = new THREE.Quaternion();
      const scale = new THREE.Vector3();
      m.decompose( pos, quat, scale );
      camera.position.copy( pos );
      camera.quaternion.copy( quat );
      camera.updateMatrixWorld();
      orbit.enabled = false;
    }

    const btnBar   = document.createElement('div');
    btnBar.style.position = 'fixed';
    btnBar.style.top = '8px';
    btnBar.style.left = '8px';
    btnBar.style.zIndex = 10;
    btnBar.style.display = 'flex';
    btnBar.style.gap = '4px';
    document.body.appendChild( btnBar );

    Object.keys(camPoses).forEach(key=>{
      const b       = document.createElement('button');
      b.textContent = key.split('_')[0]; // "left", "right", …
      b.onclick     = ()=> switchCamera(key);
      btnBar.appendChild( b );
    });

    /* add orbit button */
    const orbitBtn = document.createElement('button');
    orbitBtn.textContent = 'orbit';
    orbitBtn.onclick = ()=> switchCamera('orbit');
    btnBar.appendChild(orbitBtn);

    /* --- visualise camera frusta ------------------------------ */
    Object.entries(camPoses).forEach(([key, mat])=>{
      const dummy = new THREE.PerspectiveCamera(56, 1, 0.1, 1000);
      dummy.matrix = poseToMatrix(mat);
      dummy.matrixAutoUpdate = false;
      dummy.updateMatrixWorld(true);
      const helper = new THREE.CameraHelper(dummy);
      scene.add(helper);
    });

    const gui = new GUI();
    const spanDefs = [
      ['x',     0.30],   // meters
      ['y',     0.30],
      ['z',     0.30],
      ['roll',  0.61],   // radians
      ['pitch', 0.61],
      ['yaw',   0.61],
    ];

    spanDefs.forEach(([key, span])=>{
      if (!activeControls.includes(key)) return;
      const centre = params[key];          // start-pose value
      gui.add(params, key, centre - span, centre + span)
         .onChange(updateGoal);
    });


    /* --- solver --- */
    const solver = new Solver(ikRoot);                // constructor takes root
    // (solver settings default to 5 iterations, etc.)

    /* --- animation loop --- */
    function animate() {
      requestAnimationFrame(animate);

      setIKFromUrdf(ikRoot, robot);   // URDF ➜ IK                                         :contentReference[oaicite:1]{index=1}
      solver.solve();                 // run DLS IK
      setUrdfFromIK(robot, ikRoot);   // IK ➜ URDF                                         :contentReference[oaicite:2]{index=2}

      renderer.render(scene, camera);
    }
    animate();
  }
);

/* ---------- responsive canvas ---------- */
addEventListener('resize', () => {
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script></body></html>
