<!-- wxai_min.html  ‚Äì  minimal translate-only IK demo -->
<!DOCTYPE html><html lang="en"><head>
<meta charset="utf-8" />
<title>WidowX AI - position IK only</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#f5f5f5}
  /* Multi-view container wrapper ‚Äì white card */
  #viewport{
    position:fixed; 
    top:50%; left:50%; 
    transform:translate(-50%, -50%);
    background: #ffffff;                 /* ‚¨ÖÔ∏è was #3b82f6 */
    border-radius: 12px;
    padding: 20px;
    box-shadow:0 4px 20px rgba(0,0,0,0.15);
    display: flex;
    flex-direction: column;
    gap: 16px;                            /* a touch tighter spacing */
  }

  /* Blue prompt bar at the top */
  #viewport .prompt-bar{
    background: #3b82f6;                 /* blue */
    color: #ffffff;
    border-radius: 8px;
    padding: 12px 16px;
  }

  
  /* Text prompt area */
  #viewport .prompt-text{
    color: white;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans";
    font-size: 18px;
    font-weight: 600;
    text-align: left;
    text-shadow: 0 2px 4px rgba(0,0,0,0.3);
    line-height: 1.4;
    min-height: auto;
    padding: 0;
    margin: 0;
  }

  /* Content container for views and controls */
  #viewport .content-container{
    display: flex;
    gap: 20px;
    align-items: center;
  }
  
  /* Grid container for camera views */
  #viewport .views-grid{
    display:grid; 
    gap:0px; 
    border-radius:4px;
    overflow:hidden;
    flex-shrink: 0;
  }

  /* Container for sliders with CAPTCHA styling */
  #viewport .controls-container{
    background: rgba(255, 255, 255, 0.95);
    border-radius: 8px;
    padding: 16px 16px 12px 16px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    border: 1px solid rgba(255,255,255,0.2);
    min-width: 200px;
    display: flex;
    flex-direction: column;
    gap: 20px;
  }

  /* Single slider layout (underneath views) */
  #viewport.single-slider{
    flex-direction: column;
  }
  #viewport.single-slider .content-container{
    flex-direction: column;
    align-items: center;
  }
  #viewport.single-slider .controls-container{
    align-self: center;
    max-width: 400px;
  }

  /* Multiple slider layout (to the right of views) */
  #viewport.multiple-sliders .content-container{
    flex-direction: row;
    align-items: center;
  }

  /* Position task completed container in multiple slider layout */
  #viewport.multiple-sliders .task-completed-container {
    margin-top: 12px;
    align-self: flex-start;
  }

  /* Position task completed container in single slider layout */
  #viewport.single-slider .task-completed-container {
    align-self: center;
    max-width: 400px;
    margin-top: 12px;
  }

  /* Style the lil-gui within controls container */
  .controls-container .lil-gui {
    --background-color: transparent;
    --widget-color: rgba(255,255,255,0.9);
    --hover-color: rgba(255,255,255,1);
    --focus-color: #3b82f6;
    --text-color: #374151;
    --text-color-disabled: #9ca3af;
    --border-color: rgba(0,0,0,0.1);
    --border-color-hover: rgba(0,0,0,0.2);
    border: none !important;
    box-shadow: none !important;
    font-size: 16px;
  }

  /* Hide any lil-gui title/header elements */
  .controls-container .lil-gui .title,
  .controls-container .lil-gui .lil-gui > .title {
    display: none !important;
  }

  .controls-container .lil-gui .controller {
    margin: 8px 0;
    height: 32px;
  }

  .controls-container .lil-gui .controller .name {
    font-size: 16px;
    font-weight: 500;
    min-width: 60px;
  }

  .controls-container .lil-gui .controller input[type="range"] {
    -webkit-appearance: none;
    appearance: none;
    background: linear-gradient(to right, #d1d5db 0%, #d1d5db 100%);
    border-radius: 8px;
    height: 16px;
    min-width: 140px;
    outline: none;
    border: 1px solid #9ca3af;
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
    pointer-events: auto !important;
    cursor: pointer;
  }

  /* Ensure calibration GUI sliders are interactive */
  .lil-gui input[type="range"] {
    pointer-events: auto !important;
    cursor: pointer;
    user-select: none;
  }

  /* Webkit slider thumb (Chrome, Safari, Edge) */
  .controls-container .lil-gui .controller input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 40px;
    height: 28px;
    background: linear-gradient(145deg, #cbd5e1 0%, #94a3b8 50%, #64748b 100%);
    border: 2px solid #475569;
    border-radius: 6px;
    cursor: pointer;
    box-shadow: 
      0 3px 8px rgba(0,0,0,0.4), 
      inset 0 1px 0 rgba(255,255,255,0.3);
    position: relative;
  }

  /* Firefox slider thumb */
  .controls-container .lil-gui .controller input[type="range"]::-moz-range-thumb {
    width: 40px;
    height: 28px;
    background: linear-gradient(145deg, #cbd5e1 0%, #94a3b8 50%, #64748b 100%);
    border: 2px solid #475569;
    border-radius: 6px;
    cursor: pointer;
    box-shadow: 
      0 3px 8px rgba(0,0,0,0.4), 
      inset 0 1px 0 rgba(255,255,255,0.3);
  }

  /* Hover effects */
  .controls-container .lil-gui .controller input[type="range"]::-webkit-slider-thumb:hover {
    background: linear-gradient(145deg, #e2e8f0 0%, #cbd5e1 50%, #94a3b8 100%);
    box-shadow: 
      0 4px 10px rgba(0,0,0,0.5), 
      inset 0 1px 0 rgba(255,255,255,0.5);
    border: 2px solid #334155;
  }

  .controls-container .lil-gui .controller input[type="range"]::-moz-range-thumb:hover {
    background: linear-gradient(145deg, #e2e8f0 0%, #cbd5e1 50%, #94a3b8 100%);
    box-shadow: 
      0 4px 10px rgba(0,0,0,0.5), 
      inset 0 1px 0 rgba(255,255,255,0.5);
    border: 2px solid #334155;
  }

  /* Track styling for Firefox */
  .controls-container .lil-gui .controller input[type="range"]::-moz-range-track {
    background: linear-gradient(to right, #d1d5db 0%, #d1d5db 100%);
    border-radius: 8px;
    height: 16px;
    border: 1px solid #9ca3af;
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
  }

  /* --- visual cue when the slider is exactly at the original center --- */
  .controls-container .lil-gui .controller input[type="range"].at-center::-webkit-slider-thumb {
    border-color: #3b82f6 !important;
    box-shadow:
      0 0 0 3px rgba(59,130,246,.25),
      0 3px 8px rgba(59,130,246,.35),
      inset 0 1px 0 rgba(255,255,255,.6) !important;
  }
  .controls-container .lil-gui .controller input[type="range"].at-center::-moz-range-thumb {
    border-color: #3b82f6 !important;
    box-shadow:
      0 0 0 3px rgba(59,130,246,.25),
      0 3px 8px rgba(59,130,246,.35),
      inset 0 1px 0 rgba(255,255,255,.6) !important;
  }

  /* Hide the number input/display by default */
  .controls-container .lil-gui .controller input[type="number"],
  .controls-container .lil-gui .controller .display {
    display: none !important;
  }

  /* Show numerical values in dev mode */
  body.dev-mode .controls-container .lil-gui .controller input[type="number"],
  body.dev-mode .controls-container .lil-gui .controller .display {
    display: block !important;
    width: 60px;
    font-size: 12px;
    margin-left: 8px;
  }

  /* Gripper button styling */
  .controls-container .gripper-section {
    margin: 0 0 12px 0;
  }

  .controls-container .gripper-label {
    font-size: 16px;
    font-weight: 500;
    color: #374151;
    margin-bottom: 8px;
    text-align: left;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans";
  }

  .controls-container .gripper-buttons {
    display: flex;
    gap: 8px;
    justify-content: center;
    margin: 0;
  }

  /* Reset button styling */
  .controls-container .lil-gui .controller .reset-btn {
    padding: 1px 0px;
    margin-left: 5px;
    border: 1px solid #d1d5db;
    background: #f3f4f6;
    border-radius: 1px;
    font-size: 8px;
    cursor: pointer;
    transition: background 0.2s ease;
    color: #374151;
    width: 30px;
    height: 20px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    user-select: none;
  }

  .controls-container .lil-gui .controller .reset-btn:hover {
    background: #e5e7eb;
    border-color: #9ca3af;
  }

  .controls-container .lil-gui .controller .reset-btn:active {
    background: #d1d5db;
  }

  .controls-container .gripper-buttons button,
  .controls-container .confirm-button {
    padding: 8px 16px;
    border: none;
    border-radius: 6px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    text-transform: capitalize;
  }

  .controls-container .gripper-buttons button.open-btn {
    background: #10b981;
    color: white;
    flex: 1;
  }

  .controls-container .gripper-buttons button.close-btn {
    background: #ef4444;
    color: white;
    flex: 1;
  }

  /* Inactive gripper button states */
  .controls-container .gripper-buttons button.open-btn.inactive {
    background: #e5e7eb;
    color: #6b7280;
    border: 2px solid #d1d5db;
  }

  .controls-container .gripper-buttons button.close-btn.inactive {
    background: #e5e7eb;
    color: #6b7280;
    border: 2px solid #d1d5db;
  }

  /* Active gripper button states (enhanced) */
  .controls-container .gripper-buttons button.open-btn.active {
    background: #10b981;
    color: white;
    border: 2px solid #059669;
    box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.2);
  }

  .controls-container .gripper-buttons button.close-btn.active {
    background: #ef4444;
    color: white;
    border: 2px solid #dc2626;
    box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.2);
  }

  .controls-container .confirm-button {
    background: #3b82f6;
    color: white;
    width: 100%;
    font-size: 16px;
    font-weight: 600;
    padding: 12px 16px;
  }

  /* Task Already Completed button styling */
  .task-completed-container {
    background: rgba(255, 255, 255, 0.95);
    border-radius: 8px;
    padding: 16px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    border: 1px solid rgba(255,255,255,0.2);
    min-width: 200px;
    align-self: flex-start;
  }

  /* Task Already Completed - explicit inactive/active states (parity with gripper buttons) */
  .controls-container .task-completed-button {
    background: #fbbf24;        /* lighter orange when NOT selected */
    color: #ffffff;
    width: 100%;
    box-sizing: border-box;      /* borders won't change width/height */
    font-size: 14px;
    font-weight: 600;
    padding: 10px 16px;
    border-radius: 6px;
    border: 2px solid transparent;  /* reserve space in ALL states */
    cursor: pointer;
    opacity: .85;
    transition: all .15s ease;
    margin-bottom: 12px;
  }

  /* Hover (unchanged) */
  .controls-container .task-completed-button:hover {
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(245, 158, 11, 0.30);
    opacity: 1;
  }

  /* Selected */
  .controls-container .task-completed-button.active {
    background: #f59e0b;
    /* keep the same 2px border thickness so size doesn't change */
    border-color: transparent;
    box-shadow: 0 0 0 3px rgba(245, 158, 11, 0.25), 0 8px 18px rgba(0,0,0,.18);
    opacity: 1;
  }

  /* Explicit unselected */
  .controls-container .task-completed-button.inactive {
    background: #fbbf24;
    color: #ffffff;
    border-color: transparent;   /* DO NOT remove the border */
    box-shadow: none;
    opacity: .85;
  }

  /* Disabled / blocked */
  .controls-container .task-completed-button:disabled {
    background: #e5e7eb;
    color: #9ca3af;
    border: 2px dashed #d1d5db;  /* same thickness as base ‚Üí same size */
    cursor: not-allowed;
    box-shadow: none;
    transform: none;
    opacity: 1;
  }


  .controls-container button:hover {
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    transition: all 0.2s ease;
  }

  .controls-container button:active {
    transform: translateY(0);
  }

  .view-container{
    position:relative;
    display:grid;
    place-items:center;
    overflow:hidden;
  }
  .view-container.selected{border:2px solid #60a5fa;box-shadow:0 0 15px rgba(96,165,250,.6)}
  canvas{display:block;object-fit:cover;width:100%;height:100%}
  /* (no width/height forcing on canvas; renderer controls it) */
 /* --- nice full-screen status overlay + spinner --- */
  #statusOverlay{
    position:fixed; inset:0; display:none; place-items:center;
    background: radial-gradient(1200px 800px at 50% 30%, #111827 0%, #0b0d12 60%, #000 100%);
    color:#e5e7eb; padding:24px; text-align:center;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
  }
  #statusOverlay .card{
    max-width: 720px; width: min(92vw, 720px);
    background: rgba(17,24,39,0.55);
    border: 1px solid rgba(255,255,255,0.08);
    box-shadow: 0 10px 30px rgba(0,0,0,0.5), inset 0 1px 0 rgba(255,255,255,0.04);
    border-radius: 20px; padding: 26px 28px;
    backdrop-filter: blur(8px);
  }
  #statusOverlay .title{ font-size:20px; letter-spacing:.02em; margin:0 0 8px }
  #statusOverlay .msg  { font-size:16px; line-height:1.5; opacity:.9; margin:0 }
  #statusOverlay .row  { display:flex; align-items:center; gap:14px; justify-content:center; margin-bottom:10px }
  #statusOverlay .spinner{
    width:22px; height:22px; border-radius:50%;
    border:3px solid rgba(255,255,255,.25);
    border-top-color:#60a5fa; border-right-color:#93c5fd;
    animation: spin 1s linear infinite;
    box-shadow: 0 0 20px rgba(96,165,250,.35);
  }
  @keyframes spin{ to { transform: rotate(360deg); } }
  
  /* Auto-refresh progress bar styles */
  #refreshProgressBar {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    height: 4px;
    background: rgba(255, 255, 255, 0.2);
    z-index: 10000;
    opacity: 0;
    transition: opacity 0.3s ease;
  }
  
  #refreshProgressBar.visible {
    opacity: 1;
  }
  
  #refreshProgressBar .progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #3b82f6, #1d4ed8);
    width: 0%;
    transition: width 0.1s linear;
    box-shadow: 0 0 10px rgba(59, 130, 246, 0.6);
  }
  
  #refreshCountdown {
    position: fixed;
    top: 20px;
    right: 20px;
    background: rgba(17, 24, 39, 0.9);
    color: white;
    padding: 12px 20px;
    border-radius: 25px;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans";
    font-size: 14px;
    font-weight: 600;
    z-index: 10001;
    backdrop-filter: blur(8px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    opacity: 0;
    transform: translateY(-10px);
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  
  #refreshCountdown.visible {
    opacity: 1;
    transform: translateY(0);
  }
  
  #refreshCountdown .countdown-icon {
    display: inline-block;
    animation: pulse 1s ease-in-out infinite;
  }

  /* Disabled gripper buttons look inert + show not-allowed cursor */
  .controls-container .gripper-buttons button:disabled {
    background: #e5e7eb;
    color: #9ca3af;
    border: 2px dashed #d1d5db;
    cursor: not-allowed;
    box-shadow: none;
  }

  /* Animate button styling */
  .controls-container .animate-button {
    background: #f65c5c;
    color: white;
    width: 100%;
    font-size: 15px;
    font-weight: 600;
    padding: 10px 16px;
    border-radius: 6px;
    border: none;
    cursor: pointer;
    opacity: .85;
    transition: all .15s ease;
    margin-bottom: 12px; /* ‚Üê add a bit of breathing room */
  }
  .controls-container .animate-button:hover {
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(139, 92, 246, .35);
    opacity: 1;
  }
  .controls-container .animate-button.active {
    background: #ed3a3a; /* brighter while active */
    box-shadow: 0 0 0 3px rgba(124, 58, 237, .25), 0 8px 18px rgba(0,0,0,.18);
    opacity: 1;
  }

  .controls-container .task-completed-button { 
    margin-bottom: 12px; /* matches .animate-button‚Äôs bottom margin */
    font-weight: 600;
  }

  /* --- disabled slider look --- */
  .controls-container .lil-gui .controller input[type="range"]:disabled {
    opacity: 0.55;
    cursor: not-allowed;
  }
  .controls-container .lil-gui .controller .reset-btn:disabled {
    opacity: 0.55;
    cursor: not-allowed;
  }

  .controls-container .lil-gui.locked {
    opacity: 0.75;
  }
    
  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.6; }
  }

  /* --- Gripper force widget -------------------------------------------------- */
  .controls-container .force-widget{
    background: #ffffff;
    border: 1px solid #e5e7eb;
    border-radius: 8px;
    padding: 10px 12px;
    box-shadow: 0 1px 4px rgba(0,0,0,.06);
    display: flex; flex-direction: column; gap: 8px;
  }
  .controls-container .force-row{
    display:flex; justify-content:space-between; align-items:center;
    font: 600 13px / 1.2 system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
    color:#374151;
  }
  .controls-container .force-pill{
    padding: 4px 8px; border-radius: 999px; font-weight: 700; color: #fff;
  }
  .controls-container .force-pill.free{     background:#9ca3af; }
  .controls-container .force-pill.contact{  background:#f59e0b; }
  .controls-container .force-pill.grasped{  background:#22c55e; }
  .controls-container .force-bar{ height:8px; width:100%; background:#e5e7eb; border-radius:999px; overflow:hidden; }
  .controls-container .force-bar .fill{
    height:100%; width:0%;
    background:linear-gradient(90deg, #60a5fa, #1d4ed8);
    transition: width .25s ease;
  }

  /* optional: subtle pulse when grasped */
  @keyframes forcePulse { 0%,100%{opacity:.95} 50%{opacity:.6} }

  .controls-container .force-bar {
    margin-top: 12px;  /* adjust to taste: 12‚Äì16px works nicely */
  }

  /* Reset All button (same rhythm as Animate / TAC) */
  .controls-container .reset-all-button{
    background:#22c55e;          /* green */
    color:#ffffff;
    width:100%;
    font-size:15px;
    font-weight:600;
    padding:10px 16px;
    border-radius:6px;
    border:1px solid #16a34a;    /* darker green edge */
    margin-bottom:12px;           /* same cadence as others */
    cursor:pointer;               /* show hand cursor */
  }

  .controls-container .reset-all-button:hover{
    transform:translateY(-1px);
    box-shadow:0 2px 8px rgba(34,197,94,.30);
  }

  .controls-container .reset-all-button:active{
    transform:translateY(0);
    filter:brightness(.95);
  }

  /* Accessible focus ring to match the green theme */
  .controls-container .reset-all-button:focus{
    outline:none;
    box-shadow:0 0 0 3px rgba(34,197,94,.25), 0 2px 8px rgba(0,0,0,.15);
  }

  /* Optional: disabled state if you ever disable it */
  .controls-container .reset-all-button:disabled{
    background:#e5e7eb;
    color:#9ca3af;
    border:1px dashed #d1d5db;
    cursor:not-allowed;
    box-shadow:none;
    transform:none;
  }

  /* === In-view Grip HUD (glass) ============================================= */
  .view-container .grip-hud{
    position:absolute;
    z-index:2;
    transform:translate(-50%,-50%);
    /* force a vertical stack regardless of earlier rules */
    display:flex !important;
    flex-direction:column !important;
    align-items:center !important;
    gap:6px !important;

    padding:8px 10px;
    border-radius:14px;
    background: linear-gradient(135deg, rgba(255,255,255,.28), rgba(255,255,255,.12));
    border: 1px solid rgba(255,255,255,.35);
    box-shadow: 0 8px 24px rgba(0,0,0,.20);
    backdrop-filter: blur(14px) saturate(1.2);
    -webkit-backdrop-filter: blur(14px) saturate(1.2);
    color:#111827;
    user-select:none;
    pointer-events:auto;
    transition: transform .15s ease, box-shadow .15s ease, opacity .15s ease;
    opacity:.92;
  }

  .view-container .grip-hud .badge,
  .view-container .grip-hud .toggle{
    display:block !important;   /* ensure each occupies its own row */
  }

  .view-container .grip-hud:hover{
    transform:translate(-50%,-50%) translateY(-1px);
    box-shadow: 0 14px 32px rgba(0,0,0,.26);
    opacity:1;
  }

  .view-container .grip-hud .badge{
    padding:4px 8px;
    border-radius:999px;
    font:700 11px/1 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, "Helvetica Neue", Arial;
    color:#fff;
    text-transform: none;
    white-space:nowrap;
  }
  .view-container .grip-hud .badge.free    { background:#9ca3af; }  /* gray */
  .view-container .grip-hud .badge.contact { background:#f59e0b; }  /* amber */
  .view-container .grip-hud .badge.grasped { background:#22c55e; }  /* green */

  .view-container .grip-hud .toggle{
    appearance:none; border:0; border-radius:9px;
    padding:6px 10px;
    font:700 12px/1 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, "Helvetica Neue", Arial;
    color:#fff; cursor:pointer;
    transition: transform .12s ease, box-shadow .12s ease, filter .12s ease, background .12s ease;
    box-shadow: 0 2px 10px rgba(0,0,0,.20);
    border:1px solid transparent;
  }
  .view-container .grip-hud .toggle:hover{ transform: translateY(-1px); }
  .view-container .grip-hud .toggle:active{ transform: translateY(0); }

  /* Toggle tints (current commanded state) */
  .view-container .grip-hud .toggle.open {
    background:#10b981;              /* green */
    border-color:#059669;
  }
  .view-container .grip-hud .toggle.close{
    background:#ef4444;              /* red */
    border-color:#dc2626;
  }

  /* Disabled gating */
  .view-container .grip-hud.disabled{
    opacity:.85;
    cursor:not-allowed;
    box-shadow: 0 6px 18px rgba(0,0,0,.14);
  }
  .view-container .grip-hud.disabled .toggle{
    background: rgba(255,255,255,.55);
    color:#6b7280;
    border:1px dashed #d1d5db;
    cursor:not-allowed;
    box-shadow:none;
  }

  /* Compact workbar anchored to the views */
  #viewport .workbar {
    position: absolute;
    left: 16px;
    bottom: 16px;
    display: flex;
    gap: 8px;
    align-items: center;
    background: rgba(255,255,255,0.85);
    border: 1px solid rgba(0,0,0,0.08);
    border-radius: 10px;
    padding: 8px 10px;
    box-shadow: 0 4px 16px rgba(0,0,0,0.12);
    backdrop-filter: blur(6px);
    z-index: 9;
  }

  /* Secondary compact buttons for workbar */
  .workbar .btn-compact {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    border: 1px solid #d1d5db;
    background: #ffffff;
    color: #374151;
    padding: 6px 10px;
    border-radius: 8px;
    font: 600 13px/1 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial;
    cursor: pointer;
    transition: transform .12s ease, box-shadow .12s ease, background .12s ease;
  }
  .workbar .btn-compact:hover { transform: translateY(-1px); box-shadow: 0 2px 8px rgba(0,0,0,0.12); }
  .workbar .btn-compact:active { transform: translateY(0); }

  .workbar .btn-compact[disabled] {
    background: #f3f4f6;
    color: #9ca3af;
    border-style: dashed;
    cursor: not-allowed;
    box-shadow: none;
  }

  /* Visual states that match your existing theme */
  .workbar .btn-animate.active { border-color: #dc2626; box-shadow: 0 0 0 3px rgba(239,68,68,.18); }
  .workbar .btn-reset { border-color: #16a34a; }

  /* Icon / label behavior for tight screens */
  .workbar .icon { font-size: 14px; }
  .workbar .label { white-space: nowrap; }
  @media (max-width: 900px) {
    .workbar .label { display: none; }
    .workbar .btn-compact { padding: 8px; }
  }

  /* Keep Confirm prominent; pin it lower-right in the controls column */
  .controls-container .confirm-button {
    position: sticky;   /* stays visible at the end of the column */
    bottom: 0;
  }

  /* TAC next to Confirm: compact pill */
  .controls-container .tac-inline {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    margin: 8px 0 6px 0;
  }
  .controls-container .tac-toggle {
    background: #fbbf24;
    color: #fff;
    border: 2px solid transparent;
    border-radius: 999px;
    padding: 8px 12px;
    font: 700 13px/1 system-ui, -apple-system, Segoe UI, Roboto;
    cursor: pointer;
    transition: box-shadow .15s ease, transform .12s ease;
  }
  .controls-container .tac-toggle.active {
    background: #f59e0b;
    box-shadow: 0 0 0 3px rgba(245,158,11,.25);
  }
  .controls-container .tac-toggle:disabled {
    background: #e5e7eb; color: #9ca3af; border-style: dashed; cursor: not-allowed;
  }

  /* Confirm bar under the views (lower-right) */
  #viewport .confirm-bar{
    display:flex;
    justify-content:flex-end;
  }

  #viewport .confirm-bar .confirm-button{
    background:#3b82f6;
    color:#fff;
    border:none;
    border-radius:6px;
    padding:12px 16px;
    font-size:16px;
    font-weight:600;
    cursor:pointer;
    transition:all .2s ease;
  }

  #viewport .confirm-bar .confirm-button:hover{
    transform:translateY(-1px);
    box-shadow:0 2px 8px rgba(0,0,0,.15);
  }

  #viewport .confirm-bar .confirm-button:active{
    transform:translateY(0);
  }

  /* --- Full-bleed blue header inside the #viewport card --- */
  #viewport .prompt-bar{
    /* cancel the card's 20px padding on the top & sides */
    margin: -20px -20px 0 -20px;
    border-radius: 0; /* square corners */
  }

  /* --- Square corners (90¬∞) across the UI --- */
  #viewport,
  #viewport .prompt-bar,
  #viewport .content-container,
  #viewport .controls-container,
  #viewport .task-completed-container,
  #statusOverlay .card,
  #refreshCountdown,
  #viewport .workbar,
  #viewport .workbar .btn-compact,          /* Animate & Reset buttons */
  #viewport .confirm-bar .confirm-button,    /* lower-right Confirm */
  .controls-container .gripper-buttons button,
  .controls-container .confirm-button,       /* (dev-mode confirm) */
  .controls-container .tac-toggle,
  .controls-container .task-completed-button,
  .controls-container .animate-button,
  .controls-container .reset-all-button,
  .controls-container .force-widget,
  .controls-container .force-pill,
  .controls-container .lil-gui .controller input[type="range"],
  .controls-container .lil-gui .controller input[type="range"]::-webkit-slider-thumb,
  .controls-container .lil-gui .controller input[type="range"]::-moz-range-thumb {
    border-radius: 0 !important;
  }

  /* === Force square corners everywhere you asked (place LAST in <style>) === */

  /* Square the white card itself (all four corners) */
  #viewport {
    border-radius: 0 !important;
    border-top-left-radius: 0 !important;
    border-top-right-radius: 0 !important;
    border-bottom-left-radius: 0 !important;
    border-bottom-right-radius: 0 !important;
  }

  /* Square the compact workbar and its buttons (Animate / Reset) */
  #viewport .workbar,
  #viewport .workbar .btn-compact,
  #viewport .workbar .btn-animate,
  #viewport .workbar .btn-reset {
    border-radius: 0 !important;
    border-top-left-radius: 0 !important;
    border-top-right-radius: 0 !important;
    border-bottom-left-radius: 0 !important;
    border-bottom-right-radius: 0 !important;
  }

  /* Square the lower-right Confirm button (and its bar) */
  #viewport .confirm-bar,
  #viewport .confirm-bar .confirm-button,
  .controls-container .confirm-button {
    border-radius: 0 !important;
    border-top-left-radius: 0 !important;
    border-top-right-radius: 0 !important;
    border-bottom-left-radius: 0 !important;
    border-bottom-right-radius: 0 !important;
  }

  /* Belt-and-suspenders: catch any other buttons in those bars */
  #viewport .workbar button,
  #viewport .confirm-bar button {
    border-radius: 0 !important;
  }

  /* === Keep the gripper HUD rounded (unchanged) === */
  .view-container .grip-hud {
    border-radius: 14px !important;          /* as designed */
  }
  .view-container .grip-hud .toggle {
    border-radius: 9px !important;
  }
  .view-container .grip-hud .badge {
    border-radius: 999px !important;
  }

  /* Segmentation overlay sits over the camera texture and moves with the gripper */
  .view-container .seg-overlay{
    position:absolute;
    left: 0; top: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    user-select: none;
    mix-blend-mode: normal;     /* ensure normal compositing */
    will-change: transform;     /* smoother translate() updates */
    image-rendering: auto;
    transform-origin: 0 0;      /* predictable transform origin for scaling */
  }

  /* Layering: camera bg < segmentation < WebGL < HUD */
  .view-container { position: relative; }

  .view-container .seg-overlay {
    z-index: 1;            /* below the canvas */
  }

  .view-container canvas {
    position: relative;    /* z-index needs positioned element */
    z-index: 2;            /* above the segmentation */
  }

  /* Keep HUD above everything */
  .view-container .grip-hud {
    z-index: 3 !important; /* bump over the canvas */
  }


</style>

<!-- Polyfill so the import-map works everywhere -->
<script async src="https://cdn.jsdelivr.net/npm/es-module-shims@2/dist/es-module-shims.js"></script>

<script type="importmap">
{
  "imports": {
    "three":               "https://cdn.jsdelivr.net/npm/three@0.165/build/three.module.js",
    "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.165/examples/jsm/",
    "urdf-loader":         "https://cdn.jsdelivr.net/npm/urdf-loader@0.12.6/src/URDFLoader.js?module",
    "closed-chain-ik":     "https://cdn.jsdelivr.net/npm/closed-chain-ik@0.18.0/dist/index.module.js"
  }
}
</script></head><body>
  <!-- Centering mount for the WebGL canvas; avoids CSS stretching -->
  <div id="viewport"></div>
  
  <!-- Auto-refresh progress bar -->
  <div id="refreshProgressBar">
    <div class="progress-fill"></div>
  </div>
  
  <!-- Auto-refresh countdown display -->
  <div id="refreshCountdown">
    <span class="countdown-icon">üîÑ</span>
    <span>Loading next task in <span id="countdownTime">5</span>s</span>
  </div>
<script type="module">

/* ---------- stable per-browser session id + fetch helper ---------- */
const SID_STORAGE_KEY = 'crowd_sid';
function getStableSID() {
  try {
    const existing = localStorage.getItem(SID_STORAGE_KEY);
    if (existing) return existing;
  } catch (_) { /* localStorage blocked? proceed with ephemeral */ }

  let sid;
  try {
    sid = (crypto && crypto.randomUUID) ? crypto.randomUUID() : null;
  } catch (_) { sid = null; }
  if (!sid) sid = 'sid-' + Math.random().toString(36).slice(2) + '-' + Date.now();

  try { localStorage.setItem(SID_STORAGE_KEY, sid); } catch (_) {}
  return sid;
}
const SID = getStableSID();
console.log('[SID]', SID);

/** Like fetch(), but always sends X-Session-ID and expands relative API paths */
function apiFetch(path, options = {}) {
  const url = path.startsWith('http') ? path : `${API_BASE_URL}${path}`;
  const headers = { ...(options.headers || {}), 'X-Session-ID': SID };
  return fetch(url, { ...options, headers });
}

/* ---------- imports ---------- */
import * as THREE                    from 'three';
import { OrbitControls }             from 'three/examples/jsm/controls/OrbitControls.js';
import URDFLoader                    from 'urdf-loader';
import {
  urdfRobotToIKRoot,
  setIKFromUrdf,
  setUrdfFromIK,
  Goal,
  Solver,
  DOF
} from 'closed-chain-ik';

import {GUI} from 'three/examples/jsm/libs/lil-gui.module.min.js';

// Simple API Configuration - use appropriate proxy based on environment
async function getCurrentCloudflaredUrl() {
  try {
    // For production (Netlify), always use the function proxy to avoid CORS issues
    if (location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
      return '/.netlify/functions/api';
    }
    
    // For local development, try to get the actual cloudflared URL from Netlify function
    // This only works if running netlify dev, otherwise fallback to hardcoded URL
    try {
      const response = await fetch('/.netlify/functions/get-backend-url');
      if (response.ok) {
        const data = await response.json();
        return data.backend_url;
      }
    } catch (netlifyError) {
      // Netlify functions not available (running on pure Vite dev server)
      console.log('Netlify functions not available, using fallback Tailscale URL');
    }
    
    // Fallback to hardcoded Tailscale URL for local development
    return 'https://ztclab-1.tail503d36.ts.net';
  } catch (error) {
    console.error('Error getting backend URL:', error);
    // Fallback based on environment
    if (location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
      return '/.netlify/functions/api'; // Use proxy for production
    }
    return 'https://reconstruction-parker-put-push.trycloudflare.com'; // Direct for local dev
  }
}

// Initialize API_BASE_URL - will be set dynamically in the loader
let API_BASE_URL = '/.netlify/functions/api'; // Default to proxy

// Function to check if we're in async collection mode
async function isAsyncCollectionMode() {
  try {
    const response = await fetch(`${API_BASE_URL}/api/monitor/latest-state`);
    if (!response.ok) {
      console.warn('Could not check async collection mode, defaulting to false');
      return false;
    }
    const data = await response.json();
    return data.is_async_collection === true;
  } catch (error) {
    console.warn('Error checking async collection mode:', error);
    return false;
  }
}

// Auto-refresh with progress bar function
async function delayedRefresh(delay = 5000) {
  // Check if we're in async collection mode
  const isAsync = await isAsyncCollectionMode();
  
  // If in async collection mode, refresh immediately
  if (isAsync) {
    console.log('üîÑ Async collection mode detected - refreshing immediately');
    // Hard refresh the page to load the next task (equivalent to Ctrl+Shift+R)
    // This forces a bypass of all caches
    window.location.replace(window.location.href.split('?')[0] + '?_=' + Date.now());
    return;
  }
  
  const progressBar = document.getElementById('refreshProgressBar');
  const countdown = document.getElementById('refreshCountdown');
  const countdownTime = document.getElementById('countdownTime');
  const progressFill = progressBar.querySelector('.progress-fill');
  
  // Show progress bar and countdown
  progressBar.classList.add('visible');
  countdown.classList.add('visible');
  
  let timeLeft = delay / 1000; // Convert to seconds
  let elapsed = 0;
  
  const updateInterval = 100; // Update every 100ms for smooth progress
  
  const timer = setInterval(() => {
    elapsed += updateInterval;
    timeLeft = Math.max(0, (delay - elapsed) / 1000);
    
    // Update progress bar
    const progress = (elapsed / delay) * 100;
    progressFill.style.width = `${Math.min(progress, 100)}%`;
    
    // Update countdown display
    countdownTime.textContent = Math.ceil(timeLeft);
    
    // Check if time is up
    if (elapsed >= delay) {
      clearInterval(timer);
      
      // Hide progress elements
      progressBar.classList.remove('visible');
      countdown.classList.remove('visible');
      
      // Perform the refresh after a brief delay to allow animations
      setTimeout(() => {
        // Hard refresh the page to load the next task (equivalent to Ctrl+Shift+R)
        // This forces a bypass of all caches
        window.location.replace(window.location.href.split('?')[0] + '?_=' + Date.now());
      }, 300);
    }
  }, updateInterval);
}

async function getInitialState() {
  try {
    console.log('[DEBUG] Fetching initial state from:', `${API_BASE_URL}/api/get-state`);
    const response = await apiFetch(`/api/get-state`, {
      headers: {
        'Accept': 'application/json'
      }
    });
    console.log('[DEBUG] Response status:', response.status, response.statusText);
    
    if (!response.ok) {
      const responseText = await response.text();
      console.error('[DEBUG] Response error body:', responseText.substring(0, 500));
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const data = await response.json();
    console.log('[DEBUG] Successfully fetched initial state');
    return data;
  } catch (error) {
    console.error("Could not fetch initial state:", error);
    showServerNotStarted();
    // Hide interactive UI when server is not running
    const uiElems = document.querySelectorAll("button, .lil-gui, #viewport");
    uiElems.forEach(el=>{
      el.style.display = "none";
    });
    return {};
  }
}


// Build a THREE.Texture from a base64 JPEG data URL
async function makeTextureFromDataURL(url) {
  const loader = new THREE.TextureLoader();
  return await new Promise((resolve, reject) => {
    loader.load(
      url,
      tex => {
        tex.flipY = true;
        tex.generateMipmaps = false;
        tex.minFilter = THREE.LinearFilter;
        tex.magFilter = THREE.LinearFilter;
        tex.needsUpdate = true;
        resolve(tex);
      },
      undefined,
      err => reject(err)
    );
  });
}

/* ---------- scene ---------- */
const defaultBg = new THREE.Color(0xf5f5f5);
const scene = new THREE.Scene();
scene.background = defaultBg;
scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1));

const dir = new THREE.DirectionalLight(0xffffff, 1.2);
dir.position.set(2, 4, 2);
scene.add(dir);


const GRASP_THRESHOLD_N = 50; // N

/* ---------- floor / workspace visual -------------------- */
// light, neutral grid on the ground (y = 0)

// Default camera (will be cloned for each view)
const templateCamera = new THREE.PerspectiveCamera(45, 1, 0.01, 100);
templateCamera.position.set(0.2, -2, 0).applyAxisAngle(new THREE.Vector3(0, -1, 1), Math.PI);

// Render everything at a more compact size for captcha-style layout
const VIEW_SCALE = 0.8;

// Multi-view system
const views = new Map(); // viewName -> {camera, renderer, container, name}
let currentViewName = null;
let calibrationMode = false; // Calibration mode (UI & per-camera params)

// When true, pose sliders + scene dragging are locked (after gripper changed)
let slidersLocked = false;

const mount = document.getElementById('viewport');

// Create a blue prompt bar that contains the prompt text
const promptBar = document.createElement('div');
promptBar.className = 'prompt-bar';

const promptText = document.createElement('div');
promptText.className = 'prompt-text';
promptText.textContent = 'Pick up the red block.'; // Default text, will be updated from server

promptBar.appendChild(promptText);
mount.appendChild(promptBar);

// Create the content container for views and controls
const contentContainer = document.createElement('div');
contentContainer.className = 'content-container';
mount.appendChild(contentContainer);

const workbar = document.createElement('div');
workbar.className = 'workbar';
mount.appendChild(workbar);

const confirmBar = document.createElement('div');
confirmBar.className = 'confirm-bar';
mount.appendChild(confirmBar);

// Create the views grid container
const viewsGrid = document.createElement('div');
viewsGrid.className = 'views-grid';
contentContainer.appendChild(viewsGrid);

// Create a wrapper for controls and task completed button
const controlsWrapper = document.createElement('div');
controlsWrapper.style.display = 'flex';
controlsWrapper.style.flexDirection = 'column';
controlsWrapper.style.gap = '0px';
contentContainer.appendChild(controlsWrapper);

// Create the controls container for sliders
const controlsContainer = document.createElement('div');
controlsContainer.className = 'controls-container';
controlsContainer.style.display = 'none'; // Hidden initially
controlsWrapper.appendChild(controlsContainer);

// Multi-view grid layout helper
function calculateGridLayout(numViews) {
  if (numViews === 1) return { rows: 1, cols: 1 };
  if (numViews === 2) return { rows: 1, cols: 2 };
  if (numViews === 3) return { rows: 2, cols: 2 }; // 2 on top, 1 on bottom
  if (numViews === 4) return { rows: 2, cols: 2 };
  // For more views, calculate a reasonable grid
  const cols = Math.ceil(Math.sqrt(numViews));
  const rows = Math.ceil(numViews / cols);
  return { rows, cols };
}

function setupViewportGrid(numViews) {
  const { rows, cols } = calculateGridLayout(numViews);
  viewsGrid.style.gridTemplateRowsz = `repeat(${rows}, 1fr)`;
  viewsGrid.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
}

function createViewRenderer(viewName, cameraModel, texture, imageSrc) {
  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setPixelRatio(devicePixelRatio);
  renderer.setClearColor(0x000000, 0); // fully transparent canvas
  
  const camera = templateCamera.clone();
  
  const container = document.createElement('div');
  container.className = 'view-container';
  container.dataset.viewName = viewName;
  // Camera feed as CSS background, centered and cropped like the canvas
  if (imageSrc) {
    container.style.background = `center / cover no-repeat url("${imageSrc}")`;
  }
  
  container.appendChild(renderer.domElement);
  viewsGrid.appendChild(container);
  
  const view = {
    camera,
    renderer,
    container,
    name: viewName,
    model: cameraModel,
    texture: texture
  };
  
  views.set(viewName, view);
  return view;
}

function updateViewSizes() {
  const viewContainers = viewsGrid.querySelectorAll('.view-container');
  if (viewContainers.length === 0) return;
  
  // Define compact view dimensions based on number of views (increased by 87.5% total: 1.25 * 1.5)
  const numViews = viewContainers.length;
  let targetWidth, targetHeight;
  
  if (numViews === 1) {
    targetWidth = 600;  // 400 * 1.5
    targetHeight = 450; // 300 * 1.5
  } else if (numViews === 2) {
    targetWidth = 450;  // 300 * 1.5
    targetHeight = 338; // 225 * 1.5
  } else if (numViews === 3 || numViews === 4) {
    targetWidth = 375;  // 250 * 1.5
    targetHeight = 282; // 188 * 1.5
  } else {
    targetWidth = 300;  // 200 * 1.5
    targetHeight = 225; // 150 * 1.5
  }
  
  // Apply sizing to views grid - no gaps or padding now
  const { rows, cols } = calculateGridLayout(numViews);
  const totalWidth = cols * targetWidth; // no gaps
  const totalHeight = rows * targetHeight; // no gaps
  
  viewsGrid.style.width = totalWidth + 'px';
  viewsGrid.style.height = totalHeight + 'px';
  
  views.forEach(view => {
    const model = view.model;
    if (!model) return;
    
    const W = model.width | 0;
    const H = model.height | 0;
    
    // Make canvas fill the entire container
    const containerAspect = targetWidth / targetHeight;
    const imageAspect = W / H;
    
    let renderWidth = targetWidth;
    let renderHeight = targetHeight;
    
    // Fill the container completely (may crop image slightly)
    if (containerAspect > imageAspect) {
      // Container is wider than image aspect - fit to width
      renderHeight = Math.round(targetWidth / imageAspect);
    } else {
      // Container is taller than image aspect - fit to height  
      renderWidth = Math.round(targetHeight * imageAspect);
    }
    
    view.renderer.setSize(renderWidth, renderHeight);
    
    // Set container size to match target exactly
    view.container.style.width = targetWidth + 'px';
    view.container.style.height = targetHeight + 'px';
  });
}


// --- status overlay (initially hidden) ---
const statusOverlay = document.createElement('div');
statusOverlay.id = 'statusOverlay';
document.body.appendChild(statusOverlay);

function showServerNotStarted(){
  statusOverlay.innerHTML = `
    <div class="card">
      <div class="row">
        <div class="spinner" aria-hidden="true"></div>
        <h2 class="title">Connecting to data collection server‚Ä¶</h2>
      </div>
      <p class="msg">
        Data collection server hasn't started yet.<br/>
        Please wait for further communications.
      </p>
    </div>`;
  statusOverlay.style.display = 'grid';
}

// ================================ devMode ===================================
const devMode = false;
// Apply dev-mode class to body if devMode is enabled
if (devMode) {
  document.body.classList.add('dev-mode');
}
// ================================ devMode ===================================


let calibGUI = null;                       // lil-gui instance for calibration
const calibState = {};                     // name -> {tx,ty,tz,rx,ry,rz,fx,fy,cx,cy}
const calibDefaults = {};                  // snapshot at calibration start (per camera)

/* ---------- load URDF ---------- */
const loader = new URDFLoader();
loader.packages = {                 // map package:// paths ‚Üí server paths
  'trossen_arm_description': 'assets/trossen_arm_description'
};

loader.load(
  'assets/trossen_arm_description/urdf/generated/wxai/wxai_base.urdf',
  async robot => {

    // Set API_BASE_URL dynamically based on environment
    if (location.hostname === 'localhost' || location.hostname === '127.0.0.1') {
      if (location.port === '5173' || location.port === '5174') {
        // Running on Vite dev server - get direct cloudflared URL
        API_BASE_URL = await getCurrentCloudflaredUrl();
        console.log('[DEBUG] Using direct cloudflared URL for Vite dev server:', API_BASE_URL);
      } else {
        // Running on production build locally
        API_BASE_URL = 'http://127.0.0.1:9000';
      }
    } else {
      // Running on deployed Netlify - use function proxy to avoid CORS
      API_BASE_URL = '/.netlify/functions/api';
      console.log('[DEBUG] Using Netlify function proxy for production:', API_BASE_URL);
    }

    console.log('Using API Base URL:', API_BASE_URL);

    scene.add(robot);

    // Which links should be visible outside animation:
    const MINIMAL_LINKS = ['link_6', 'gripper_left', 'gripper_right'];

    // Start in minimal mode
    showOnlySpecifiedLinks(robot, MINIMAL_LINKS);

    // Helpers to flip visibility modes
    function showAllRobotMeshes() {
      robot.traverse(o => { if (o.isMesh) o.visible = true; });
    }
    function showMinimalRobotMeshes() {
      showOnlySpecifiedLinks(robot, MINIMAL_LINKS);
    }

    // ---- Ghosting (semi-transparent) ------------------------------------------
    const GHOST = {
      opacity: 0.42,                 // tweak ghost strength here (0..1)
      origMat: new WeakMap(),        // Mesh -> original material (or array)
      ghostFor: new WeakMap()        // Material -> ghost clone (shared)
    };

    // Utility: is `obj` under any of the given roots?
    function isUnderAny(obj, rootSet) {
      let p = obj;
      while (p) {
        if (rootSet.has(p)) return true;
        p = p.parent;
      }
      return false;
    }

    // Get (or build once) a ghost clone for a material
    function getGhostMaterial(mat) {
      let gm = GHOST.ghostFor.get(mat);
      if (!gm) {
        gm = mat.clone();
        gm.transparent = true;
        gm.opacity = GHOST.opacity;
        gm.depthWrite = false;     // helps avoid z-fighting with opaque parts
        // keep depthTest = true so ghosts still sort reasonably
        if (gm.needsUpdate !== undefined) gm.needsUpdate = true;
        GHOST.ghostFor.set(mat, gm);
      }
      return gm;
    }

    function applyGhostToMesh(mesh) {
      if (!mesh.isMesh || GHOST.origMat.has(mesh)) return;
      const orig = mesh.material;
      GHOST.origMat.set(mesh, orig);
      mesh.material = Array.isArray(orig) ? orig.map(getGhostMaterial) : getGhostMaterial(orig);
    }

    function restoreMeshMaterial(mesh) {
      if (!mesh.isMesh) return;
      const orig = GHOST.origMat.get(mesh);
      if (orig) {
        mesh.material = orig;
        GHOST.origMat.delete(mesh);
        if (mesh.material.needsUpdate !== undefined) mesh.material.needsUpdate = true;
      }
    }

    /**
     * Turn ghosting on/off for everything NOT in MINIMAL_LINKS.
     * Assumes the robot is already visible. Call after showAllRobotMeshes()
     * when enabling, and before showMinimalRobotMeshes() when disabling.
     */
    function setGhostMode(on) {
      // Collect roots for the minimal (fully opaque) subtree(s)
      const minimalRoots = new Set(
        MINIMAL_LINKS.map(n => robot.getObjectByName(n)).filter(Boolean)
      );

      robot.traverse(o => {
        if (!o.isMesh) return;
        const keepOpaque = isUnderAny(o, minimalRoots);
        if (on) {
          if (keepOpaque) {
            restoreMeshMaterial(o);
          } else {
            applyGhostToMesh(o);
            o.visible = true; // ensure non-minimal parts are actually shown
          }
        } else {
          // Turn ghosting off everywhere
          restoreMeshMaterial(o);
        }
      });
    }

    let robotVisible = false; // toggle visibility of the robot model
    robot.visible = false;     // hide arm until user moves a slider
    let toggleRobotBtn = null;

    // --- Visibility policy: show minimal meshes only after *pose* changes ---
    let userHasAdjustedPose = false; // set to true on first translation/rotation change

    function revealMinimalRobotFromPose() {
      // Idempotent ‚Äî call when the user actually adjusts the pose (drag/slider)
      if (!userHasAdjustedPose) userHasAdjustedPose = true;
      if (userHasAdjustedPose && !robotVisible) {
        robotVisible = true;
        robot.visible = true;
        if (toggleRobotBtn) toggleRobotBtn.textContent = 'hide robot model';
      }
    }

    function hideRobotCompletely() {
      robotVisible = false;
      robot.visible = false;
    }

    function applyPostAnimationVisibility() {
      // After animation stops, respect the "only after pose change" rule
      if (userHasAdjustedPose) {
        robotVisible = true;
        robot.visible = true;
        showMinimalRobotMeshes();
      } else {
        hideRobotCompletely();
      }
    }

    function attachSegOverlay(view, maskDataUrl) {
      const img = document.createElement('img');
      img.className = 'seg-overlay';
      img.src = maskDataUrl;
      // Stretch to the renderer size (CSS handles scaling)
      img.style.width = '100%';
      img.style.height = '100%';
      img.style.transform = 'translate(0px, 0px)';
      view.container.appendChild(img);

      // Keep per-view segmentation state
      view.seg = {
        el: img
        // base position is implied (0,0) since mask was extracted on the snapshot itself
      };
    }


    /* --- build IK tree from URDF (limits copied automatically) --- */
    const ikRoot = urdfRobotToIKRoot(robot);          // :contentReference[oaicite:0]{index=0}

    ikRoot.clearDoF()

    const state = await getInitialState();
    const cameraModels = state.camera_models ?? {};
    // If the data collection server isn't available, stop building UI
    if (!state || Object.keys(state).length === 0 || !cameraModels) {
      // Ensure the status overlay is visible and abort UI construction
      showServerNotStarted();
      return; // ‚Üê prevents creating sliders/buttons and starting animation
    }

    /* ---------- build textures from JPEG base64 views --------------- */
    const viewTextures = {}; // 'front' ‚Üí THREE.Texture
    for (const [key, dataUrl] of Object.entries(state.views ?? {})) {
      viewTextures[key] = await makeTextureFromDataURL(dataUrl);
    }

    /* ---------- segmentation masks (data URLs) ---------------------- */
    const segmentsByView = state.segments ?? {};  // { front: "data:image/png;base64,...", ... }

    const initialJointPositions = state.joint_positions ?? {};
    const activeControls        = state.controls ?? ['x','y','z','roll','pitch','yaw'];

    /* ---------- gripper finger-tip calibration (load + state) ---------- */
    const TIP_CAL_LS_KEY = 'wxai_gripper_tip_calib';

    function loadTipCalibFromLS() {
      try { const txt = localStorage.getItem(TIP_CAL_LS_KEY); return txt ? JSON.parse(txt) : null; } catch { return null; }
    }
    function saveTipCalibToLS(obj) {
      try { localStorage.setItem(TIP_CAL_LS_KEY, JSON.stringify(obj)); } catch {}
    }

    // Server-provided values take priority, then localStorage, then defaults
    let tipCalib = (state.gripper_tip_calib && state.gripper_tip_calib.left && state.gripper_tip_calib.right)
      ? JSON.parse(JSON.stringify(state.gripper_tip_calib))
      : (loadTipCalibFromLS() ?? {
          left:  { x: 0.03, y: 0.00, z: 0.00 },
          right: { x: 0.03, y: 0.00, z: 0.00 }
        });

    saveTipCalibToLS(tipCalib); // mirror locally so it's never lost client‚Äëside

    // Calibratable local offsets (per finger) that the renderer uses
    const fingerTipLocalLeft  = new THREE.Vector3(tipCalib.left.x,  tipCalib.left.y,  tipCalib.left.z);
    const fingerTipLocalRight = new THREE.Vector3(tipCalib.right.x, tipCalib.right.y, tipCalib.right.z);

    function applyTipCalibToVectors(){
      fingerTipLocalLeft.set (tipCalib.left.x,  tipCalib.left.y,  tipCalib.left.z);
      fingerTipLocalRight.set(tipCalib.right.x, tipCalib.right.y, tipCalib.right.z);
    }

    
    // Update prompt text from server state
    const promptFromServer = state.prompt || 'Pick up the red block.';
    promptText.textContent = promptFromServer;
    
    for (const [name, val] of Object.entries(initialJointPositions)) {
      robot.setJointValue(name, val);
    }

    /* ---------- gripper-motion arrows ---------------------------------- */
    let gripArrows = [];                       // keeps currently-shown arrow meshes
    let gripDir    = state.gripper ?? 0;

    let gripHUDs = []; // [{ view, el, badge, btn }]

    let hudHiddenForAnimation = false;
    function setHUDHiddenForAnimation(hidden) {
      hudHiddenForAnimation = hidden;
      gripHUDs.forEach(({ el }) => {
        if (hidden) {
          // Force it off even against CSS '!important'
          el.style.setProperty('display', 'none', 'important');
        } else {
          // Let the stylesheet's 'display:flex !important' win again
          el.style.removeProperty('display');
        }
      });
    }

    function drawGripArrows(dir /* +1 open | ‚Äì1 close */) {
      /* remove previous arrows */
      gripArrows.forEach(a => scene.remove(a));
      gripArrows.length = 0;

      if (dir !== undefined && dir !== null) {
        gripDir = dir;     // remember last request only if dir is explicitly provided
      }
      
      // Always create arrows, use current gripDir if no direction specified
      const effectiveDir = (dir !== undefined && dir !== null) ? dir : gripDir || 1; // default to open arrows if no direction available
      const colour   = effectiveDir > 0 ? 0x00ff00 : 0xff0000;
      const len      = 0.04, headLen = 0.02;
      const shaftLen = len - headLen, shaftRad = 0.005, offset = 0.03;
      const tipX     = 0.02;

      function addArrow(linkName, outward) {
        const link = robot.getObjectByName(linkName); if (!link) return;
        const dirLocal    = new THREE.Vector3(0, effectiveDir * outward, 0).normalize();
        const baseDist    = effectiveDir > 0 ? offset : offset + len;
        const originLocal = new THREE.Vector3(tipX, outward * baseDist, 0);

        /* geometry ---------------------------------------------------- */
        const mat = new THREE.MeshBasicMaterial({
          color: colour, transparent: true, opacity: 0.95,
          depthTest: false, depthWrite: false
        });
        const grp       = new THREE.Group();
        grp.renderOrder = 1000;
        grp.userData.mat = mat;

        const shaftGeo  = new THREE.CylinderGeometry(shaftRad, shaftRad,
                                                     shaftLen, 8, 1, true);
        const shaft     = new THREE.Mesh(shaftGeo, mat);
        shaft.position.y = shaftLen / 2;
        grp.add(shaft);

        const coneGeo   = new THREE.ConeGeometry(headLen * 0.6, headLen, 8);
        const cone      = new THREE.Mesh(coneGeo, mat);
        cone.position.y = shaftLen + headLen / 2;
        grp.add(cone);

        grp.position.copy(originLocal);
        grp.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dirLocal);
        
        // Add arrows to scene instead of robot links so they're visible even when robot is hidden
        scene.add(grp);
        
        // Store link reference to update arrow position in animation loop
        grp.userData.targetLink = link;
        grp.userData.originLocal = originLocal.clone();
        grp.userData.dirLocal = dirLocal.clone();
        
        gripArrows.push(grp);
      }
      addArrow('gripper_left',  +1);
      addArrow('gripper_right', -1);
    }

    let animating = false;

    function updateGripArrowVisibility() {
      // Visible unless we are animating
      const showArrows = !animating;
      gripArrows.forEach(arrow => {
        if (arrow) arrow.visible = showArrows;
      });
    }

    drawGripArrows(state.gripper ?? 0);        // render initial arrows from server
    updateGripArrowVisibility();               // set initial visibility based on current view

    const initialGripDir = gripDir;

    /* ================== Grip force -> UI + 3D feedback ================== */

    // 1) Read value (Newtons). Missing? We‚Äôll hide the widget.
    let lastGripForceN = (typeof state.left_carriage_external_force === 'number')
      ? state.left_carriage_external_force
      : null;

    function setGripForceN(newN){
      if (typeof newN !== 'number' || !Number.isFinite(newN)) return;
      lastGripForceN = newN;
      updateGripHUDState();
    }

    let forcePollTimer = null;

    function extractForceN(s){
      // Prefer left carriage; fall back to other likely names if your backend differs
      const candidates = [
        s?.left_carriage_external_force,
        s?.right_carriage_external_force,
        s?.gripper_force_n,
        s?.gripper_force,
        s?.force_n,
        s?.forceN
      ];
      return candidates.find(v => typeof v === 'number' && Number.isFinite(v));
    }

    function startForcePolling(intervalMs = 250){
      stopForcePolling();
      forcePollTimer = setInterval(async ()=>{
        try{
          const resp = await apiFetch(`/api/monitor/latest-state`, { headers: { 'Accept':'application/json' } });
          if (!resp.ok) return;
          const s = await resp.json();
          const v = extractForceN(s);
          if (typeof v === 'number') setGripForceN(v);
        }catch(_){ /* ignore transient errors */ }
      }, intervalMs);
    }

    function stopForcePolling(){
      if (forcePollTimer){ clearInterval(forcePollTimer); forcePollTimer = null; }
    }

    window.addEventListener('visibilitychange', ()=>{
      if (document.hidden) stopForcePolling(); else startForcePolling();
    });
    window.addEventListener('beforeunload', stopForcePolling);

    function clamp01(x){ return Math.max(0, Math.min(1, x)); }

    // 3) Minimal widget in the controls column
    function createForceWidget(parent){
      const box = document.createElement('div');
      box.className = 'force-widget';
      const row = document.createElement('div'); row.className = 'force-row';
      const label = document.createElement('div'); label.textContent = 'Grip Pressure';
      const pill = document.createElement('div'); pill.className = 'force-pill free'; pill.textContent = 'free';
      row.append(label, pill);
      const bar = document.createElement('div'); bar.className = 'force-bar';
      const fill = document.createElement('div'); fill.className = 'fill';
      bar.appendChild(fill);
      const val = document.createElement('div'); val.style.font = '600 12px system-ui'; val.style.color = '#4b5563';

      box.append(row, bar, val);
      parent.insertBefore(box, parent.firstChild); // show above sliders

      function setBadge(status){
        pill.classList.remove('free','contact','grasped');
        pill.classList.add(status);
        pill.textContent = (status === 'grasped' ? 'grasped' : status);
        box.style.animation = (status === 'grasped') ? 'forcePulse 1.5s ease-in-out infinite' : 'none';
      }

      return {
        hide(){ box.style.display = 'none'; },
        show(){ box.style.display = 'block'; },
        update(forceN, status){
          const absF = Math.abs(forceN || 0);
          setBadge(status);
          // Scale bar to ~1.4√ó the single grasp threshold
          const denom = Math.max(GRASP_THRESHOLD_N * 1.4, 1);
          fill.style.width = `${clamp01(absF / denom) * 100}%`;
          val.textContent = `${absF.toFixed(1)} N`;
        }
      };
    }
    const forceUI = createForceWidget(controlsContainer);

    if (!devMode && forceUI) forceUI.hide();

    // 4) Classification + 3D adornment
    function classifyGrip(forceN){
      const f = forceN ?? 0;
      if (!Number.isFinite(f)) return 'free';
      return (f < -GRASP_THRESHOLD_N) ? 'grasped' : 'free';
    }

    // Visuals: keep arrow color tied to commanded state (open/close).
    function applyGripVisual(status, forceN){
      const baseColor = (gripDir > 0 ? 0x00ff00 : 0xff0000); // open=green, close=red
      const opacity   = 0.95;
      const strength  = (status === 'grasped') ? 1 : 0;       // simple 0/1

      gripArrows.forEach(a => {
        if (!a) return;
        const lenScale = 1 + 0.6 * strength;  // emphasize when grasped
        a.scale.set(1, lenScale, 1);
        const mat = a.userData?.mat;
        if (mat){
          mat.color.setHex(baseColor);
          mat.opacity = opacity;
          mat.needsUpdate = true;
        }
      });
    }

    // 5) Drive UI from this state (and record to history)
    (function initGripForce(){
      updateGripHUDState();

      const _origOnGripperChange = onGripperChange;
      onGripperChange = function(newDir){
        _origOnGripperChange(newDir);
        updateGripHUDState();
      };
    })();

    let gui = null;
    if (devMode) {
      gui = new GUI({ container: controlsContainer });
      gui.domElement.style.position = 'static';
      gui.domElement.style.width = '100%';
    }

    let guiShield = null;  // invisible overlay to block pointer input on lil-gui
    
    // Create gripper controls container (will be added after sliders)
    let gripperButtonsContainer = null;
    let openBtn = null, closeBtn = null; // Store button references for state updates
    
    function updateGripperButtonStates() {
      if (!openBtn || !closeBtn) return;
      
      // Remove all state classes first
      openBtn.classList.remove('active', 'inactive');
      closeBtn.classList.remove('active', 'inactive');
      
      // Apply states based on current gripper direction
      if (gripDir > 0) { // Open
        openBtn.classList.add('active');
        closeBtn.classList.add('inactive');
      } else { // Close
        openBtn.classList.add('inactive');
        closeBtn.classList.add('active');
      }
    }

    function updateGripperInteractivity() {
      if (!openBtn || !closeBtn) return;

      if (taskCompletedSelected) {
        openBtn.disabled = true;
        closeBtn.disabled = true;

        const msg = 'Gripper disabled: "Task Already Completed" is selected.';
        openBtn.title = msg;
        closeBtn.title = msg;

        openBtn.classList.add('inactive'); openBtn.classList.remove('active');
        closeBtn.classList.add('inactive'); closeBtn.classList.remove('active');
        return;
      }

      const atDefault = slidersAtDefault();
      openBtn.disabled = !atDefault;
      closeBtn.disabled = !atDefault;

      const changed = getChangedAxes();
      const hoverMsg = atDefault
        ? 'You can change the gripper state.'
        : `Gripper locked: pose sliders changed (${changed.join(', ')}). Reset sliders to their starting values to change the gripper.`;

      openBtn.title = hoverMsg;
      closeBtn.title = hoverMsg;

      const label = document.querySelector('.gripper-label');
      if (label) label.title = hoverMsg;

      if (!atDefault) {
        openBtn.classList.add('inactive'); openBtn.classList.remove('active');
        closeBtn.classList.add('inactive'); closeBtn.classList.remove('active');
      } else {
        updateGripperButtonStates();
      }

      updateGripHUDInteractivity();
    }


    // --- Task Already Completed availability + global lock orchestration ---
    let taskCompletedBlocked = false;  // becomes true if any slider or gripper is changed

    function setTaskCompletedBlocked(blocked){
      taskCompletedBlocked = blocked;
      if (taskCompletedBtn){
        taskCompletedBtn.disabled = blocked;
        taskCompletedBtn.classList.toggle('blocked', blocked);

        // Update hover/title text to explain why it‚Äôs blocked/available
        const changed = getChangedAxes();
        const gripperChanged = (gripDir !== initialGripDir);
        if (blocked){
          const parts = [];
          if (changed.length) parts.push(`slider changes: ${changed.join(', ')}`);
          if (gripperChanged) parts.push('gripper changed');
          taskCompletedBtn.title = `Blocked - ${parts.join(' & ')}. Reset sliders and gripper to enable.`;
        }else{
          taskCompletedBtn.title = taskCompletedSelected
            ? 'Selected--task already completed--press Confirm to submit'
            : 'Not selected. Press to select, then press Confirm to submit.';
        }
      }
    }

    function updateTaskCompletedAvailability(){
      // Block if any user change from the original state
      const shouldBlock = !slidersAtDefault() || (gripDir !== initialGripDir);
      setTaskCompletedBlocked(shouldBlock);
    }

    function recomputeLocks(){
      // Sliders are locked if TAC is selected OR the gripper is not at its original state
      const lock = taskCompletedSelected || (gripDir !== initialGripDir);
      setSlidersLocked(lock);

      // Explain why the panel is locked
      if (controlsContainer){
        controlsContainer.title = taskCompletedSelected
          ? 'Pose sliders are locked because ‚ÄúTask Already Completed‚Äù is selected.'
          : (gripDir !== initialGripDir ? 'Pose sliders are locked because the gripper state was changed.' : '');
      }

      // Gripper buttons disabled when TAC is selected (regardless of sliders)
      updateGripperInteractivity();
    }


    function setSlidersLocked(locked) {
      slidersLocked = locked;

      // Disable lil-gui range + number inputs (if visible in dev mode)
      const ranges  = controlsContainer.querySelectorAll('.lil-gui input[type="range"]');
      const numbers = controlsContainer.querySelectorAll('.lil-gui input[type="number"]');
      ranges.forEach(el  => { el.disabled = locked; });
      numbers.forEach(el => { el.disabled = locked; });

      // Disable the tiny reset buttons we append to each controller
      const resetBtns = controlsContainer.querySelectorAll('.lil-gui .reset-btn');
      resetBtns.forEach(btn => { btn.disabled = locked; });

      // Dim the panel
      if (gui && gui.domElement) {
        gui.domElement.classList.toggle('locked', locked);

        // Create an invisible shield that catches all pointer events
        if (!guiShield) {
          guiShield = document.createElement('div');
          Object.assign(guiShield.style, {
            position: 'absolute',
            inset: '0',
            zIndex: '2',
            cursor: 'not-allowed',
            background: 'transparent',
            display: 'none',
          });
          // Ensure the lil-gui container is positioned for absolute child
          const s = gui.domElement.style;
          if (!s.position || s.position === 'static') s.position = 'relative';
          gui.domElement.appendChild(guiShield);
        }
        guiShield.style.display = locked ? 'block' : 'none';
      }

      // Panel tooltip
      controlsContainer.title = locked
        ? 'Pose sliders are locked because the gripper state was changed.'
        : '';
    }
    
    
    function onGripperChange(newDir) {
      cancelAnimationIfRunning('gripper changed');
      gripDir = newDir;                         // Update the current gripper direction
      drawGripArrows(newDir);
      updateGripArrowVisibility();
      updateGripperButtonStates();

      // Any gripper change blocks "Task Already Completed" until reset
      updateTaskCompletedAvailability();

      // Lock/unlock sliders considering both gripper change and TAC selection
      recomputeLocks();
      updateGripHUDState();
      updateGripHUDInteractivity();
    }

    
    if (activeControls.includes('gripper')) {
      gripperButtonsContainer = document.createElement('div');
      gripperButtonsContainer.className = 'gripper-section';
      
      const gripperLabel = document.createElement('div');
      gripperLabel.className = 'gripper-label';
      gripperLabel.textContent = 'gripper';
      gripperButtonsContainer.appendChild(gripperLabel);
      
      const buttonsContainer = document.createElement('div');
      buttonsContainer.className = 'gripper-buttons';
      
      openBtn = document.createElement('button');
      openBtn.textContent = 'Open';
      openBtn.className = 'open-btn';
      openBtn.onclick = () => {
        onGripperChange(+1);
      };
      
      closeBtn = document.createElement('button');
      closeBtn.textContent = 'Close';
      closeBtn.className = 'close-btn';
      closeBtn.onclick = () => {
        onGripperChange(-1);
      };
      
      buttonsContainer.appendChild(openBtn);
      buttonsContainer.appendChild(closeBtn);
      gripperButtonsContainer.appendChild(buttonsContainer);
    }

    const camPoses = state.camera_poses ?? {}

    // --- Intrinsics ‚Üí projection helper (use Knew from backend) ---
    function applyProjectionFromK(view) {
      const model = view.model;
      const camera = view.camera;
      if (!model || !model.Knew || !model.width || !model.height) {
        return false;
      }
      const K = model.Knew;       // 3x3 (row-major)
      const W = model.width|0;
      const H = model.height|0;
      const near = camera.near, far = camera.far;

      // Scale intrinsics to current viewport (CSS) size
      const sz = new THREE.Vector2();
      view.renderer.getDrawingBufferSize(sz);
      const vw = sz.x, vh = sz.y;
      const sx = vw / W, sy = vh / H;

      const fx = K[0][0] * sx, fy = K[1][1] * sy;
      const cx = K[0][2] * sx, cy = K[1][2] * sy;

      // OpenCV pixels (origin top-left, +y down) ‚Üí Three frustum (y up)
      const left   = -cx * near / fx;
      const right  =  (vw - cx) * near / fx;
      const top    =  cy * near / fy;
      const bottom = -(vh - cy) * near / fy;

      const P = new THREE.Matrix4().makePerspective(left, right, top, bottom, near, far);
      camera.projectionMatrix.copy(P);
      camera.projectionMatrixInverse.copy(P).invert();
      camera.projectionMatrixAutoUpdate = false;
      return true;
    }

    function applyDefaultPerspective(view) {
      const camera = view.camera;
      camera.projectionMatrixAutoUpdate = true;
      camera.fov = 45;
      camera.aspect = 1; // Will be updated when renderer size is set
      camera.updateProjectionMatrix();
    }

    function updateViewCamera(view, pose) {
      if (!pose) return false;
      
      const m = poseToMatrix(pose);
      const pos   = new THREE.Vector3();
      const quat  = new THREE.Quaternion();
      const scale = new THREE.Vector3();
      m.decompose(pos, quat, scale);

      view.camera.position.copy(pos);
      view.camera.quaternion.copy(quat);
      view.camera.updateMatrixWorld();
      
      return true;
    }

    /* ---------- calibration helpers (intrinsics & extrinsics) ------- */
    function poseKeyForName(name) {
      // camPoses keys look like "front_pose", "left_pose", ...
      for (const k of Object.keys(camPoses)) if (k.startsWith(name)) return k;
      return null;
    }

    function ensureCalibStateFor(name) {
      if (calibState[name]) return;
      // Seed from current view's camera transform & model K
      const view = views.get(name);
      if (!view) return;
      
      const pos = new THREE.Vector3();
      const quat = new THREE.Quaternion();
      view.camera.updateMatrixWorld();
      view.camera.getWorldPosition(pos);
      view.camera.getWorldQuaternion(quat);
      const eul = new THREE.Euler().setFromQuaternion(quat, 'XYZ');
      const model = cameraModels?.[name];
      const K = model?.Knew;
      calibState[name] = {
        tx: pos.x, ty: pos.y, tz: pos.z,
        rx: eul.x, ry: eul.y, rz: eul.z,
        fx: K ? K[0][0] : 800,
        fy: K ? K[1][1] : 800,
        cx: K ? K[0][2] : (model?.width ?? 640) / 2,
        cy: K ? K[1][2] : (model?.height ?? 480) / 2,
        zoom: 1.0,  // multiplicative scale for fx, fy
      };
    }

    function destroyCalibGUI() { if (calibGUI) { calibGUI.destroy(); calibGUI = null; } }

    function applyExtrinsicsFromParams(name) {
      const s = calibState[name]; if (!s) return;
      const view = views.get(name); if (!view) return;
      
      const q = new THREE.Quaternion().setFromEuler(new THREE.Euler(s.rx, s.ry, s.rz, 'XYZ'));
      view.camera.position.set(s.tx, s.ty, s.tz);
      view.camera.quaternion.copy(q);
      view.camera.updateMatrixWorld(true);
      
      // Update camPoses so switching away/back keeps edited pose
      const key = poseKeyForName(name);
      if (key) {
        const m = new THREE.Matrix4().compose(view.camera.position.clone(), view.camera.quaternion.clone(), new THREE.Vector3(1,1,1));
        const e = m.elements; // row-major in Three (column-major storage)
        camPoses[key] = [
          [e[0], e[4], e[8],  e[12]],
          [e[1], e[5], e[9],  e[13]],
          [e[2], e[6], e[10], e[14]],
          [e[3], e[7], e[11], e[15]],
        ];
      }
    }

    function applyIntrinsicsFromParams(name) {
      const s = calibState[name]; if (!s) return;
      const model = cameraModels?.[name]; if (!model) return;
      const view = views.get(name); if (!view) return;
      
      const z = (s.zoom ?? 1.0);
      const fx_eff = s.fx * z;
      const fy_eff = s.fy * z;
      model.Knew = [
        [fx_eff, 0,     s.cx],
        [0,      fy_eff, s.cy],
        [0,    0,    1   ],
      ];
      applyProjectionFromK(view);
    }

    // tiny helper: add a slider **and** a matching "revert" button for it
    function addParamWithRevert(folder, stateObj, key, range, step, label, onChange, camName){
      const [min, max] = range;
      const ctrl = folder.add(stateObj, key, min, max, step).name(label).onChange((value) => {
        onChange(camName);
      });
      
      const revertObj = {};
      const revertLabel = `revert ${label}`;
      revertObj[revertLabel] = () => {
        // restore from snapshot taken when entering calibration
        stateObj[key] = calibDefaults[camName][key];
        ctrl.updateDisplay();
        onChange(camName);
      };
      folder.add(revertObj, revertLabel);
      return ctrl;
    }

    function enterCalibration() {
      if (!currentViewName) { console.warn('Pick a camera view before calibrating.'); return; }
      calibrationMode = true;
      destroyCalibGUI();
      ensureCalibStateFor(currentViewName);
      const s = calibState[currentViewName];
      calibDefaults[currentViewName] = { ...s };
      calibGUI = new GUI();
      // Position panel top-right with higher z-index and ensure it's interactive
      calibGUI.domElement.style.position = 'fixed';
      calibGUI.domElement.style.top = '8px';
      calibGUI.domElement.style.right = '8px';
      calibGUI.domElement.style.zIndex = 9999;
      calibGUI.domElement.style.pointerEvents = 'auto';
      calibGUI.domElement.style.userSelect = 'none';
      
      // Intrinsics controls (no folder)
      const model = cameraModels[currentViewName];
      const W = model?.width  ?? 640;
      const H = model?.height ?? 480;
      addParamWithRevert(calibGUI, s, 'zoom', [0.1, 5.0], 0.1, 'zoom', applyIntrinsicsFromParams, currentViewName);
      addParamWithRevert(calibGUI, s, 'fx', [50, 8000], 1,   'fx', applyIntrinsicsFromParams, currentViewName);
      addParamWithRevert(calibGUI, s, 'fy', [50, 8000], 1,   'fy', applyIntrinsicsFromParams, currentViewName);
      addParamWithRevert(calibGUI, s, 'cx', [0, W],     0.1, 'cx', applyIntrinsicsFromParams, currentViewName);
      addParamWithRevert(calibGUI, s, 'cy', [0, H],     0.1, 'cy', applyIntrinsicsFromParams, currentViewName);
      
      // Extrinsics controls (no folder)
      addParamWithRevert(calibGUI, s, 'tx', [s.tx - 0.25, s.tx + 0.25], 0.0005, 'tx (m)',   applyExtrinsicsFromParams, currentViewName);
      addParamWithRevert(calibGUI, s, 'ty', [s.ty - 0.25, s.ty + 0.25], 0.0005, 'ty (m)',   applyExtrinsicsFromParams, currentViewName);
      addParamWithRevert(calibGUI, s, 'tz', [s.tz - 0.25, s.tz + 0.25], 0.0005, 'tz (m)',   applyExtrinsicsFromParams, currentViewName);
      addParamWithRevert(calibGUI, s, 'rx', [s.rx - 1.0,  s.rx + 1.0 ], 0.0005, 'roll rx',  applyExtrinsicsFromParams, currentViewName);
      addParamWithRevert(calibGUI, s, 'ry', [s.ry - 1.0,  s.ry + 1.0 ], 0.0005, 'pitch ry', applyExtrinsicsFromParams, currentViewName);
      addParamWithRevert(calibGUI, s, 'rz', [s.rz - 1.0,  s.rz + 1.0 ], 0.0005, 'yaw rz',   applyExtrinsicsFromParams, currentViewName);
      
      // ---- Save calibration action (writes to backend) ----
      const actions = {
        async save_calibration() {
          try {
            // build 4x4 from current cam pose (tx,ty,tz + rx,ry,rz)
            const q = new THREE.Quaternion().setFromEuler(new THREE.Euler(s.rx, s.ry, s.rz, 'XYZ'));
            const Tm = new THREE.Matrix4().compose(
              new THREE.Vector3(s.tx, s.ty, s.tz),
              q,
              new THREE.Vector3(1,1,1)
            );
            // convert to row-major list-of-lists like the rest of the app
            const e = Tm.elements;
            const T_three = [
              [e[0], e[4], e[8],  e[12]],
              [e[1], e[5], e[9],  e[13]],
              [e[2], e[6], e[10], e[14]],
              [e[3], e[7], e[11], e[15]],
            ];
            const model = cameraModels[currentViewName];
            // Use effective fx/fy that include zoom
            const z = (s.zoom ?? 1.0);
            const fx_eff = s.fx * z;
            const fy_eff = s.fy * z;
            const payload = {
              camera: currentViewName,
              intrinsics: {
                width:  model?.width  ?? 640,
                height: model?.height ?? 480,
                Knew: [
                  [fx_eff, 0,    s.cx],
                  [0,    fy_eff, s.cy],
                  [0,    0,    1   ],
                ],
                zoom: z
              },
              extrinsics: { T_three }
            };
            const resp = await apiFetch(`/api/save-calibration`, {
              method: 'POST',
              headers: { 
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(payload)
            });
            const out = await resp.json();
            if (!resp.ok) throw new Error(out?.error || 'save failed');
            console.log('‚úÖ saved calibration:', out);
            alert(`Saved calibration for '${currentViewName}' to ${out.path}`);
          } catch (err) {
            console.error('‚ùå save calibration failed', err);
            alert('Save calibration failed. See console for details.');
          }
        }
      };
      calibGUI.add(actions, 'save_calibration').name('Save calibration');

      /* --------- Gripper tip calibration (dev panel) --------- */
      // Working copy for sliders
      const tipDev = JSON.parse(JSON.stringify(tipCalib));

      // When sliders move: commit to live calib, update vectors, persist locally
      function onTipDevChange(){
        tipCalib.left.x  = tipDev.left.x;  tipCalib.left.y  = tipDev.left.y;  tipCalib.left.z  = tipDev.left.z;
        tipCalib.right.x = tipDev.right.x; tipCalib.right.y = tipDev.right.y; tipCalib.right.z = tipDev.right.z;
        applyTipCalibToVectors();
        saveTipCalibToLS(tipCalib);
      }

      const tipFolderDev = calibGUI.addFolder('gripper tips');
      const rng = [-0.10, 0.10], step = 0.0005; // 0.5 mm step; widen if needed

      tipFolderDev.add(tipDev.left,  'x', rng[0], rng[1], step).name('left x (m)').onChange(onTipDevChange);
      tipFolderDev.add(tipDev.left,  'y', rng[0], rng[1], step).name('left y (m)').onChange(onTipDevChange);
      tipFolderDev.add(tipDev.left,  'z', rng[0], rng[1], step).name('left z (m)').onChange(onTipDevChange);

      tipFolderDev.add(tipDev.right, 'x', rng[0], rng[1], step).name('right x (m)').onChange(onTipDevChange);
      tipFolderDev.add(tipDev.right, 'y', rng[0], rng[1], step).name('right y (m)').onChange(onTipDevChange);
      tipFolderDev.add(tipDev.right, 'z', rng[0], rng[1], step).name('right z (m)').onChange(onTipDevChange);

      // Save to backend (same pattern as camera)
      const tipActions = {
        async save_gripper_tips(){
          const payload = {
            gripper_tip_calib: tipCalib,
            state_id: state.state_id,
            episode_id: state.episode_id
          };
          try {
            // Prefer a generic calibration endpoint (like cameras)
            let resp = await apiFetch(`/api/save-calibration`, {
              method: 'POST',
              headers: { 'Content-Type':'application/json' },
              body: JSON.stringify({ type: 'gripper_tips', ...payload })
            });

            // Fallback: dedicated route if your backend uses one
            if (!resp.ok) {
              resp = await apiFetch(`/api/save-gripper-tips`, {
                method: 'POST',
                headers: { 'Content-Type':'application/json' },
                body: JSON.stringify(payload)
              });
            }

            const out = await resp.json();
            if (!resp.ok) throw new Error(out?.error || 'save failed');
            console.log('‚úÖ saved gripper tip calibration', out);
            alert(`Saved gripper tip calibration${out.path ? ` to ${out.path}` : ''}.`);
          } catch (err) {
            console.error('‚ùå failed to save gripper tip calibration', err);
            alert('Saved locally. Server save failed (check console).');
          }
        }
      };
      tipFolderDev.add(tipActions, 'save_gripper_tips').name('Save gripper tips');

      // Initial apply so the matrices reflect slider defaults
      applyIntrinsicsFromParams(currentViewName);
      applyExtrinsicsFromParams(currentViewName);

    }

    function exitCalibration() {
      destroyCalibGUI();
      calibrationMode = false;
    }

    function showOnlySpecifiedLinks(robot, keepNames /* array of link names */) {
      const keep = new Set(keepNames);

      // 1) Hide every mesh under the robot (visual + collision)
      robot.traverse(o => {
        if (o.isMesh) o.visible = false;
      });

      // 2) Re‚Äëenable meshes that live under the allowed link groups
      keep.forEach(name => {
        const link = robot.getObjectByName(name);
        if (!link) {
          console.warn(`[showOnlySpecifiedLinks] link "${name}" not found`);
          return;
        }
        link.traverse(o => {
          if (o.isMesh) o.visible = true;
        });
      });

      // Important: DO NOT set .visible=false on any parent links in the chain.
      // We only hide their meshes so children (e.g., link_6 ‚Üí carriages ‚Üí grippers)
      // still receive correct transforms from the kinematics.
    }

    setIKFromUrdf(ikRoot, robot);
    ikRoot.updateMatrixWorld(true);

    /* --- locate the end-effector link inside IK tree --- */
    let ee = null;
    
    ikRoot.traverse(child => {                        // Frame.traverse
      if ( child.name === 'ee_gripper_link' ) { ee = child; return true; }
    });

    /* --- create a translation-only Goal --- */
    const goal = new Goal();
    goal.setDoF(DOF.X, DOF.Y, DOF.Z, DOF.EX, DOF.EY, DOF.EZ);

    goal.makeClosure( ee );                          // link goal ‚Üî ee

    /* ---- sample the **visual** EE pose after matrices are fresh */
    const startPos  = new THREE.Vector3();
    const startQuat = new THREE.Quaternion();

    robot.updateMatrixWorld( true );                 // propagate world mats
    const eeVis = robot.getObjectByName( 'ee_gripper_link' );
    eeVis.getWorldPosition   ( startPos  );
    eeVis.getWorldQuaternion ( startQuat );

    goal.setPosition   ( startPos.x, startPos.y, startPos.z );
    goal.setQuaternion ( startQuat.x, startQuat.y, startQuat.z, startQuat.w );

    /* ===== Animate button + loop state ===== */
    const animState = {
      enabled: false,
      t: 0,
      duration: 2000,     // ms start ‚Üí target
      lastTs: 0,
      phase: 'forward',   // 'forward' | 'hold'
      holdMs: 250,        // 0.25 s at goal
      holdElapsed: 0
    };

    let cancelAnimationIfRunning = () => {};

    // Reusable temporaries for interpolation (avoid per‚Äëframe allocations)
    const _interpPos  = new THREE.Vector3();
    const _interpQuat = new THREE.Quaternion();

    // Compute the *target* pose from current user params.
    // We purposely derive orientation from baseQuat + (roll,pitch,yaw)
    // instead of reusing currentQuat to avoid drift.
    function getTargetPose() {
      // Always return the latest interactive target (local-frame orientation)
      return { pos: targetPose.pos, quat: targetPose.quat };
    }

    // Toggle animation ON/OFF.
    function toggleAnimation() {
      animState.enabled = !animState.enabled;

      animating = true;
      updateGripArrowVisibility();

      if (animState.enabled) {
        // Reset the arm to the initial joint configuration (the "initial positions" you have)
        // so the animation starts exactly from there.
        if (initialJointPositions) {
          for (const [name, val] of Object.entries(initialJointPositions)) {
            robot.setJointValue(name, val);
          }
          robot.updateMatrixWorld(true);
          // Resample the initial EE pose in case anything drifted
          eeVis.getWorldPosition(startPos);
          eeVis.getWorldQuaternion(startQuat);
        }

        // Start timeline
        animState.t = 0;
        animState.lastTs = performance.now();
        animateBtn.classList.add('active');
        animState.phase = 'forward';
        animState.holdElapsed = 0;

        // Snap goal to the initial pose (no first-frame lag)
        goal.setPosition(startPos.x, startPos.y, startPos.z);
        goal.setQuaternion(startQuat.x, startQuat.y, startQuat.z, startQuat.w);

        // Make sure robot is visible
        if (!robotVisible) {
          robotVisible = true;
          robot.visible = true;
          if (toggleRobotBtn) toggleRobotBtn.textContent = 'hide robot model';
        }
        // Hide pose gizmos while animating (rotation wheels + red dot)
        setPoseGizmosVisible(false);
        showAllRobotMeshes();
        setGhostMode(true);

        setHUDHiddenForAnimation(true);

      } else {
        animateBtn.classList.remove('active');
        // If stopped mid-way, snap directly to the current target
        const { pos, quat } = getTargetPose();
        goal.setPosition(pos.x, pos.y, pos.z);
        goal.setQuaternion(quat.x, quat.y, quat.z, quat.w);
        // Restore pose gizmos when animation is off
        setPoseGizmosVisible(true);
        setGhostMode(false);
        applyPostAnimationVisibility();

        animating = false;
        updateGripArrowVisibility();

        setHUDHiddenForAnimation(false);
      }
    }


    /* ---------- semi-transparent alignment line -------------------- */
    const lineLen = 0.80;      // meters
    const lineRad = 0.002;     // thickness
    const lineOffX = - 0.01;
    // --- cache & helpers for fast updates (no per-frame allocs) ---
    const baseLineLen = lineLen; // baseline length for scaling helper lines
    const floorZ      = 0.0;      // ground plane (Z-up)
    const bottomPad   = 0.0005;   // tiny lift to avoid z-fighting
    const _eePosTmp   = new THREE.Vector3();

    /* ---------- two yellow drop lines from gripper finger tips ---------- */

    // If you want the lines to end at exactly z=0, keep this at 0.0.
    // If you see z-fighting flicker, bump it up slightly (e.g., 0.0005).
    const fingerBottomPad = 0.0;

    // Shared yellow material (semi‚Äëtransparent)
    const fingerLineMat = new THREE.MeshBasicMaterial({
      color: 0xffcc00, transparent: true, opacity: 0.95
    });

    // Helper to build a vertical cylinder whose local Y maps to world Z (like the green line)
    function makeDownLine(material){
      const m = new THREE.Mesh(
        new THREE.CylinderGeometry(lineRad, lineRad, lineLen, 8, 1, true),
        material
      );
      m.rotation.x = Math.PI / 2;   // align cylinder Y ‚Üí world Z
      m.visible = false;
      scene.add(m);
      return m;
    }

    const leftFingerLine  = makeDownLine(fingerLineMat);
    const rightFingerLine = makeDownLine(fingerLineMat);

    // Cache references to the finger links in the URDF
    // (Rename here if your URDF uses different link names)
    const leftFingerLink  = robot.getObjectByName('gripper_left');
    const rightFingerLink = robot.getObjectByName('gripper_right');


    /* ---- XY cross at the target pose (keeps the same drag proxy) --------- */
    // === CROSS MARKER (visual only; keeps your existing drag proxy) =============

    // Use your existing Group that represents the goal/marker. If you do not have
    // one, create it and keep your existing drag "proxy" mesh as-is.
    const marker = new THREE.Group();

    // If you created a new one, ensure it's added and positioned at your initial target.
    if (!marker.parent) {
      marker.position.copy(startPos);        // <- replace with your initial
      marker.quaternion.copy(startQuat);    // <- replace with your initial
      scene.add(marker);
    }

    // Remove any old cross meshes if you had them:
    const oldCross = marker.getObjectByName('marker_cross');
    if (oldCross) oldCross.parent.remove(oldCross);

    // New cross: two thin bars along local X and Y; always-on-top over camera textures
    const CROSS_LEN   = 0.10;    // 10 cm total length
    const CROSS_THICK = 0.005;   // 5 mm thickness
    const crossMat = new THREE.MeshBasicMaterial({
      color: 0xff0000, transparent: true, opacity: 0.85, depthTest: false, depthWrite: false
    });

    const xBar = new THREE.Mesh(new THREE.BoxGeometry(CROSS_THICK, CROSS_THICK, CROSS_LEN), crossMat);
    const yBar = new THREE.Mesh(new THREE.BoxGeometry(CROSS_THICK, CROSS_LEN,  CROSS_THICK), crossMat);

    // IMPORTANT: Do not let the cross be pickable. Keep your existing invisible sphere/mesh as the
    // drag "hit area" (proxy).
    xBar.raycast = () => {};
    yBar.raycast = () => {};

    const crossGroup = new THREE.Group();
    crossGroup.name = 'marker_cross';
    crossGroup.renderOrder = 1001; // above wheels (999) and arrows (1000)
    crossGroup.add(xBar, yBar);
    marker.add(crossGroup);

    // Keep (or create) your pick proxy:
    let pickProxy = marker.getObjectByName('marker_pick_proxy');
    if (!pickProxy) {
      pickProxy = new THREE.Mesh(
        new THREE.SphereGeometry(0.04, 16, 16), // ~4 cm hit radius
        new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0, depthWrite: false })
      );
      pickProxy.name = 'marker_pick_proxy';
      marker.add(pickProxy);
    }

    // === ROTATION WHEELS (world-space radii; scale visually with distance) =====

    const rotationWheels = {};   // { roll:{group, segments:Mesh[]}, pitch:{...}, yaw:{...} }
    let rotationPickables = [];  // flat array of the segment meshes for raycasting

    // Opacity states for visual feedback
    const WHEEL_OPACITY = {
      idle:   { even: 0.44, odd: 0.24 },
      hover:  { even: 0.64, odd: 0.44 },
      active: { even: 0.84, odd: 0.64 },
    };

    // Build one ring ("striped annulus") in world units (meters)
    function makeWheel(axisName, colorHex, innerR = 0.085, outerR = 0.105, strips = 48) {
      const group = new THREE.Group();
      group.name = `wheel_${axisName}`;
      group.userData.axis = axisName;
      group.renderOrder = 999; // always on top

      const segments = [];
      const segAngle = (Math.PI * 2) / strips;
      const gap = segAngle * 0.08;
      const thetaLen = segAngle - gap;

      for (let i = 0; i < strips; i++) {
        const thetaStart = i * segAngle + gap * 0.5;
        const geom = new THREE.RingGeometry(innerR, outerR, 18, 1, thetaStart, thetaLen);
        const mat  = new THREE.MeshBasicMaterial({
          color: colorHex, transparent: true,
          opacity: (i % 2 === 0 ? WHEEL_OPACITY.idle.even : WHEEL_OPACITY.idle.odd),
          side: THREE.DoubleSide,
          depthTest: false
        });
        const seg = new THREE.Mesh(geom, mat);
        seg.userData.axis = axisName;
        group.add(seg);
        segments.push(seg);
      }

      return { group, segments };
    }

    function setWheelState(axis, state) {
      const w = rotationWheels[axis]; if (!w) return;
      const cfg = WHEEL_OPACITY[state] || WHEEL_OPACITY.idle;
      w.segments.forEach((seg, i) => {
        seg.material.opacity = (i % 2 === 0 ? cfg.even : cfg.odd);
        seg.material.needsUpdate = true;
      });
    }
    function resetAllWheelStates() {
      ['roll', 'pitch', 'yaw'].forEach(a => setWheelState(a, 'idle'));
    }

    // Build wheels for the controls you actually expose
    function buildRotationWheels() {
      // Clear any existing wheels first
      Object.values(rotationWheels).forEach(w => {
        if (w && w.group && w.group.parent) {
          w.group.parent.remove(w.group);
        }
      });
      
      // Reset the rotationWheels object
      Object.keys(rotationWheels).forEach(key => delete rotationWheels[key]);
      rotationPickables.length = 0;

      // Feel free to reuse these axis colors
      const colorFor = { roll: 0xff5b5b, pitch: 0x22cc88, yaw: 0x4f8cff };

      // Only create wheels for rotation axes that are actually enabled
      const rotationAxes = ['roll','pitch','yaw'].filter(axis => 
        activeControls && activeControls.includes(axis)
      );
      
      console.log('Building rotation wheels for axes:', rotationAxes);
      
      rotationAxes.forEach(axis => {
        const { group, segments } = makeWheel(axis, colorFor[axis]);
        scene.add(group);
        rotationWheels[axis] = { group, segments };
        rotationPickables.push(...segments);
        console.log(`Created wheel for ${axis} with ${segments.length} segments`);
      });

      resetAllWheelStates();
    }

    // === math helpers to align wheels to marker local axes ======================

    function localAxesWorld(q /* THREE.Quaternion */) {
      return {
        xW: new THREE.Vector3(1,0,0).applyQuaternion(q).normalize(),
        yW: new THREE.Vector3(0,1,0).applyQuaternion(q).normalize(),
        zW: new THREE.Vector3(0,0,1).applyQuaternion(q).normalize(),
      };
    }

    function planeBasisForAxis(axis /* 'roll'|'pitch'|'yaw' */, q) {
      const { xW, yW, zW } = localAxesWorld(q || marker.quaternion);
      if (axis === 'roll')   return { n: xW, u: yW, v: zW }; // rotate about local X ‚Üí YZ plane
      if (axis === 'pitch')  return { n: yW, u: zW, v: xW }; // rotate about local Y ‚Üí XZ plane
      /* yaw */              return { n: zW, u: xW, v: yW }; // rotate about local Z ‚Üí XY plane
    }

    function alignRingToNormal(group, n) {
      const from = new THREE.Vector3(0,0,1); // RingGeometry faces +Z by default
      const q = new THREE.Quaternion().setFromUnitVectors(from, n);
      group.quaternion.copy(q);
      group.updateMatrixWorld(true);
    }

    function angleOnPlaneFromPoint(p, center, u, v) {
      const r = p.clone().sub(center);
      return Math.atan2(r.dot(v), r.dot(u));
    }
    function normalizeAngle(a) {
      while (a >  Math.PI) a -= Math.PI * 2;
      while (a < -Math.PI) a += Math.PI * 2;
      return a;
    }

    // Build them once, after the marker exists:
    buildRotationWheels();

    function createGripHUDForView(view){
      const hud = document.createElement('div');
      hud.className = 'grip-hud';
      hud.setAttribute('role','group');
      hud.setAttribute('aria-label','Grip control');

      const badge = document.createElement('span');
      badge.className = 'badge free';
      badge.textContent = 'free';
      badge.setAttribute('aria-live','polite');

      const btn = document.createElement('button');
      btn.className = 'toggle';
      btn.setAttribute('aria-pressed','false');
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        if (hud.classList.contains('disabled')) return;
        onGripperChange(gripDir > 0 ? -1 : +1);
      });

      // No meter element anymore
      hud.append(badge, btn);

      view.container.appendChild(hud);
      // No meterFill in the stored object
      gripHUDs.push({ view, el: hud, badge, btn });

      updateGripHUDState();
      updateGripHUDInteractivity();
    }

    /* Update texts/colors based on gripDir + force classification */
    function updateGripHUDState(){
      const status = classifyGrip(lastGripForceN);
      const absF   = Math.abs(lastGripForceN || 0);
      const isOpen = gripDir > 0;

      gripHUDs.forEach(({ el, badge, btn }) => {
        badge.classList.remove('free','contact','grasped');
        badge.classList.add(status);
        badge.textContent = status;

        btn.textContent = isOpen ? 'Open' : 'Close';
        btn.classList.toggle('open',  isOpen);
        btn.classList.toggle('close', !isOpen);
        btn.setAttribute('aria-pressed', String(isOpen));

        el.title  = (lastGripForceN != null) ? `${absF.toFixed(1)} N` : 'Grip force unavailable';
        btn.title = `Click to ${isOpen ? 'Close' : 'Open'} gripper.`;
      });

      applyGripVisual(status, lastGripForceN);

      if (forceUI) {
        if (devMode && lastGripForceN != null) {
          forceUI.show();
          forceUI.update(lastGripForceN, status);
        } else {
          forceUI.hide();
        }
      }
    }


    /* Enable/disable HUD with same gating rules as before */
    function updateGripHUDInteractivity(){
      const disabled = taskCompletedSelected || !slidersAtDefault();
      const hoverMsg = disabled
        ? (taskCompletedSelected
            ? 'Disabled: ‚ÄúTask Already Completed‚Äù is selected.'
            : 'Disabled: pose changed. Reset to default to change gripper.')
        : `Click to ${gripDir > 0 ? 'Close' : 'Open'} gripper.`;

      gripHUDs.forEach(({ el, btn }) => {
        el.classList.toggle('disabled', disabled);
        btn.title = hoverMsg;
      });
    }

    const WHEEL_OUTER_RADIUS_M = 0.105; // keep in sync with makeWheel(... outerR=0.105 ...)
    const HUD_MARGIN_PX = 20;           // constant 2D gap above the wheel (increase/decrease as desired)

    // Base geometry sizes you already use
    const WHEEL_BASE_OUTER_RADIUS_M = 0.105;  // same value you pass to makeWheel(.. outerR)
    const CROSS_BASE_LEN_M = 0.10;            // your CROSS_LEN

    // Target pixel sizes (tune to taste)
    // const TARGET_WHEEL_RADIUS_PX = 64;        // ‚Üê no longer used
    const TARGET_CROSS_LEN_PX    = 24;        // long arm of the red cross ~24 px

    const _hudTmpA = new THREE.Vector3();
    const _hudTmpB = new THREE.Vector3();
    const _hudTmpC = new THREE.Vector3(); // NEW: for screen-right computations
    const _hudTmpD = new THREE.Vector3(); // NEW: for projected positions

    function projectWorldToViewPx(view, worldVec3) {
      const cam  = view.camera;
      const rect = view.renderer.domElement.getBoundingClientRect();
      const ndc  = worldVec3.clone().project(cam);
      const visible = (ndc.z >= -1 && ndc.z <= 1);
      return {
        x: (ndc.x * 0.5 + 0.5) * rect.width,
        y: (-ndc.y * 0.5 + 0.5) * rect.height,
        visible
      };
    }

    // Camera-space depth (|z|). Three's camera looks down -Z, so use abs().
    function cameraDepth(view, worldPoint){
      const p = worldPoint.clone().applyMatrix4(view.camera.matrixWorldInverse);
      return Math.abs(p.z);
    }

    function pixelsPerMeterAt(view, worldPoint){
      const cam  = view.camera;
      const rect = view.renderer.domElement.getBoundingClientRect();
      const M = 0.10; // 10 cm sampling baseline

      const up    = new THREE.Vector3(0,1,0).applyQuaternion(cam.quaternion).normalize();
      const right = new THREE.Vector3(1,0,0).applyQuaternion(cam.quaternion).normalize();

      const p0 = worldPoint.clone();
      const p0N = p0.clone().project(cam);
      if (p0N.z < -1 || p0N.z > 1) return null;

      const x0 = (p0N.x * .5 + .5) * rect.width;
      const y0 = (-p0N.y * .5 + .5) * rect.height;

      const px = p0.clone().addScaledVector(right, M).project(cam);
      const py = p0.clone().addScaledVector(up,    M).project(cam);

      const x1 = (px.x * .5 + .5) * rect.width;
      const y1 = (-py.y * .5 + .5) * rect.height;

      const ppmX = Math.abs(x1 - x0) / M;
      const ppmY = Math.abs(y1 - y0) / M;
      return { mean: (ppmX + ppmY) * 0.5 };
    }

    function updateSegOverlayForView(view){
      if (!view.seg || !view.seg.el) return;

      // Project the original EE (startPos) and the current target (marker.position)
      const base = projectWorldToViewPx(view, startPos);
      const curr = projectWorldToViewPx(view, marker.position);
      if (!base.visible || !curr.visible) return;

      // 1) Translate: same as before
      const dx = Math.round(curr.x - base.x);
      const dy = Math.round(curr.y - base.y);

      // 2) Scale: ratio of camera-space depth (f / z -> pixel scale)
      const zBase = cameraDepth(view, startPos);
      const zCurr = cameraDepth(view, marker.position);
      const s = (zBase > 1e-9 && zCurr > 1e-9) ? (zBase / zCurr) : 1;

      // Anchor scale around the original EE pixel so translation remains correct
      view.seg.el.style.transformOrigin = `${Math.round(base.x)}px ${Math.round(base.y)}px`;

      // Order matters: translate *after* scale so dx/dy aren't scaled
      view.seg.el.style.transform = `translate(${dx}px, ${dy}px) scale(${s})`;
    }

    function positionGripHUDs(){
      gripHUDs.forEach(({ view, el }) => {
        const cam  = view.camera;
        const rect = view.renderer.domElement.getBoundingClientRect();

        if (hudHiddenForAnimation) {
          el.style.setProperty('display', 'none', 'important');
          return;
        } else {
          el.style.removeProperty('display');
        }

        // project marker center to screen
        _hudTmpA.copy(marker.position).project(cam);
        if (_hudTmpA.z < -1 || _hudTmpA.z > 1) { el.style.display = 'none'; return; }
        el.style.display = 'block';

        const baseX = (_hudTmpA.x * 0.5 + 0.5) * rect.width;
        const baseY = (-_hudTmpA.y * 0.5 + 0.5) * rect.height;

        // --- compute px-per-meter along screen up/right (local to *this* view) ---
        const upWorld    = _hudTmpB.set(0,1,0).applyQuaternion(cam.quaternion).normalize();
        const rightWorld = _hudTmpC.set(1,0,0).applyQuaternion(cam.quaternion).normalize();
        const p0 = marker.position;
        const M  = 0.10; // sample baseline (meters)

        // Y scale: move a little along world "screen-up", project, measure Œîpx
        const p1y  = _hudTmpD.copy(p0).addScaledVector(upWorld, M);
        const sp1y = _hudTmpD.clone().project(cam);
        const py1  = (-sp1y.y * 0.5 + 0.5) * rect.height;
        const pxPerMeterY = Math.abs(py1 - baseY) / M || 0;

        // X scale: move a little along world "screen-right", project, measure Œîpx
        const p1x  = _hudTmpD.copy(p0).addScaledVector(rightWorld, M);
        const sp1x = _hudTmpD.clone().project(cam);
        const px1  = (sp1x.x * 0.5 + 0.5) * rect.width;
        const pxPerMeterX = Math.abs(px1 - baseX) / M || 0;

        // Fallback to mean px/m if either direction is degenerate (very rare)
        const ppmMean = pixelsPerMeterAt(view, marker.position)?.mean || 0;
        const effPxPerMeterX = pxPerMeterX || ppmMean || 0;
        const effPxPerMeterY = pxPerMeterY || ppmMean || 0;

        // --- NEW: wheel radius in pixels from actual projection (edge-aware offset) ---
        // Keep this in sync with makeWheel(... outerR = 0.105 ...)
        const wheelPxRadiusX = Math.max(0, effPxPerMeterX * WHEEL_OUTER_RADIUS_M);
        const wheelPxRadiusY = Math.max(0, effPxPerMeterY * WHEEL_OUTER_RADIUS_M);

        // Distance from the *edge* of the ring, not its center
        const offsetPxX = Math.round(wheelPxRadiusX + HUD_MARGIN_PX); // right
        const offsetPxY = Math.round(wheelPxRadiusY + HUD_MARGIN_PX); // up

        // position with a small screen-edge clamp
        const edge = 8;
        const x = Math.round(baseX + offsetPxX);   // move right from center by ringEdge + margin
        const y = Math.round(baseY - offsetPxY);   // move up    from center by ringEdge + margin

        el.style.left = `${Math.max(edge, Math.min(rect.width  - edge, x))}px`;
        el.style.top  = `${Math.max(edge, Math.min(rect.height - edge, y))}px`;
      });
    }

    // World-space local axes from the marker‚Äôs orientation
    function localAxesWorld() {
      const q = marker.quaternion;
      return {
        xW: new THREE.Vector3(1,0,0).applyQuaternion(q).normalize(),
        yW: new THREE.Vector3(0,1,0).applyQuaternion(q).normalize(),
        zW: new THREE.Vector3(0,0,1).applyQuaternion(q).normalize(),
      };
    }

    // For a given axis name, return plane normal n and in-plane orthonormal basis u,v
    function planeBasisForAxis(axis) {
      const { xW, yW, zW } = localAxesWorld();
      if (axis === 'roll')   return { n: xW, u: yW, v: zW }; // rotate about local X ‚Üí YZ plane
      if (axis === 'pitch')  return { n: yW, u: zW, v: xW }; // rotate about local Y ‚Üí XZ plane
      /* yaw */              return { n: zW, u: xW, v: yW }; // rotate about local Z ‚Üí XY plane
    }
    function alignRingToNormal(group, n) {
      const from = new THREE.Vector3(0,0,1); // RingGeometry faces +Z by default
      const q = new THREE.Quaternion().setFromUnitVectors(from, n);
      group.quaternion.copy(q);
      group.updateMatrixWorld(true);
    }

    function angleOnPlaneFromPoint(p, center, u, v) {
      const r = p.clone().sub(center);
      return Math.atan2(r.dot(v), r.dot(u));
    }
    function normalizeAngle(a) {
      while (a >  Math.PI) a -= Math.PI * 2;
      while (a < -Math.PI) a += Math.PI * 2;
      return a;
    }

    // --- helper to show/hide pose gizmos (red dot + rotation wheels) ---
    function setPoseGizmosVisible(visible) {
      if (marker) marker.visible = visible;
      Object.values(rotationWheels).forEach(w => {
        if (w && w.group) w.group.visible = visible;
      });
    }


    /* 2) build lil-GUI sliders ----------------------------------- */
    // ---- absolute hard limits (same for all users) ----
    const ABS_LIMITS = {
      x:     { min: 0.10,  max: 0.43  },
      y:     { min: -0.30, max: 0.30  },
      z:     { min: 0.005, max: 0.30  },
      roll:  { min: -1.00, max: 1.00  },
      pitch: { min: -0.60, max: 0.75  },
      yaw:   { min: -0.81, max: 0.81  },
    };

    const startEuler = new THREE.Euler().setFromQuaternion(startQuat, 'XYZ');
    // --- interactive target pose (driven by sliders/marker) ---
    const targetPose = {
      pos: startPos.clone(),
      quat: startQuat.clone()
    };
    const params = {
      x: startPos.x, y: startPos.y, z: startPos.z,
      // roll:  startEuler.x,
      // pitch: startEuler.y,
      // yaw:   startEuler.z
      roll:  0.0,
      pitch: 0.0,
      yaw:   0.0
    };

    // Keep last angles so we can apply *incremental* local rotations
    const prevAngles = {
      roll:  params.roll,
      pitch: params.pitch,
      yaw:   params.yaw
    };

    // Record the starting values once; used to detect "pose unchanged"
    const initialParams = {
      x: params.x, y: params.y, z: params.z,
      roll: params.roll, pitch: params.pitch, yaw: params.yaw
    };

    const lastGoodParams = { ...params };
    function recordLastGood(keys = poseAxes) {
      keys.forEach(k => { lastGoodParams[k] = params[k]; });
    }

    // Only check the controls that are present
    const poseAxes = ['x','y','z','roll','pitch','yaw'].filter(k => activeControls.includes(k));
    const EPS = 1e-6; // tolerance for float comparisons
    function approximatelyEqual(a,b,eps=EPS){ return Math.abs(a - b) <= eps; }
    function getChangedAxes(){ return poseAxes.filter(k => !approximatelyEqual(params[k], initialParams[k])); }
    function slidersAtDefault(){ return getChangedAxes().length === 0; }

    function updateGoal() {
      cancelAnimationIfRunning('pose changed');

      // 1) Absolute position from sliders/drag
      targetPose.pos.set(params.x, params.y, params.z);

      // 2) Orientation: compose *incremental* rotation in the gripper's local frame
      const dRoll  = params.roll  - prevAngles.roll;
      const dPitch = params.pitch - prevAngles.pitch;
      const dYaw   = params.yaw   - prevAngles.yaw;

      if (Math.abs(dRoll) > EPS || Math.abs(dPitch) > EPS || Math.abs(dYaw) > EPS) {
        const dQ = new THREE.Quaternion().setFromEuler(
          new THREE.Euler(dRoll, dPitch, dYaw, 'XYZ')
        );
        // local-frame: post-multiply onto the current target orientation
        targetPose.quat.multiply(dQ).normalize();

        prevAngles.roll  = params.roll;
        prevAngles.pitch = params.pitch;
        prevAngles.yaw   = params.yaw;
      }

      // 3) Marker always shows the desired target immediately
      marker.position.copy(targetPose.pos);
      marker.quaternion.copy(targetPose.quat);

      // 4) Push to IK only when NOT animating
      if (!animState.enabled) {
        goal.setPosition(targetPose.pos.x, targetPose.pos.y, targetPose.pos.z);
        goal.setQuaternion(
          targetPose.quat.x, targetPose.quat.y, targetPose.quat.z, targetPose.quat.w
        );
      }

      // Existing reveal/locking UI
      if (!slidersLocked) recordLastGood();
      updateGripperInteractivity();
    }



    // ---------- Drag helpers ----------
    const raycaster = new THREE.Raycaster();
    const ndc = new THREE.Vector2();

    function clampToSlider(axis, v){
      // Clamp to the effective slider range (span‚à©ABS_LIMITS) and also
      // to the absolute limits for extra safety.
      const r = sliderRanges[axis] || {};
      const abs = ABS_LIMITS[axis];
      let min = r.min ?? -Infinity;
      let max = r.max ?? +Infinity;
      if (abs) {
        min = Math.max(min, abs.min);
        max = Math.min(max, abs.max);
      }
      return Math.min(max, Math.max(min, v));
    }

    function updateSlidersDisplay(axes){
      axes.forEach(a => {
        sliderCtrls[a]?.updateDisplay();
        updateSliderDecor(a);
      });
     }

    // --- UI decoration: center tick + invalid shading + center detent glow ---
    function clamp01(x){ return Math.max(0, Math.min(1, x)); }
    function updateSliderDecor(axis){
      const ctrl = sliderCtrls[axis]; if (!ctrl) return;
      const input = ctrl.domElement.querySelector('input[type="range"]'); if (!input) return;
      const abs = ABS_LIMITS[axis]; if (!abs) return;
      const {min, max} = sliderRanges[axis];        // full centered track (center ¬± span)
      const center = sliderCenters[axis];
      const span = (max - min);
      if (span <= 0) return;

      // Positions along the track (0..100%)
      const pct = v => 100 * clamp01((v - min) / span);
      const absMinPct = pct(abs.min);
      const absMaxPct = pct(abs.max);
      const centerPct = 50; // by construction (center ¬± span)

      // Layered gradients: left OOB, right OOB, center tick, base
      const leftOOB  = absMinPct > 0
        ? `linear-gradient(to right, rgba(239,68,68,.26) 0%, rgba(239,68,68,.26) ${absMinPct}%, transparent ${absMinPct}%, transparent 100%)`
        : '';
      const rightOOB = absMaxPct < 100
        ? `linear-gradient(to right, transparent 0%, transparent ${absMaxPct}%, rgba(239,68,68,.26) ${absMaxPct}%, rgba(239,68,68,.26) 100%)`
        : '';
      const centerTick = `linear-gradient(to right,
        transparent calc(${centerPct}% - 1px),
        #3b82f6    calc(${centerPct}% - 1px),
        #3b82f6    calc(${centerPct}% + 1px),
        transparent calc(${centerPct}% + 1px)
      )`;
      const base = 'linear-gradient(to right, #d1d5db, #d1d5db)';
      input.style.background = [leftOOB, rightOOB, centerTick, base].filter(Boolean).join(',');

      // Snap-to-center detent (~2% of span) + visual glow
      const detent = 0.02 * span;
      const atCenter = Math.abs(params[axis] - center) <= detent;
      input.classList.toggle('at-center', atCenter);
    }

    // Single shared drag state
    const dragState = {
      active: false,
      mode: null,                // 'translate' | 'rotate'
      viewName: null,
      plane: new THREE.Plane(),
      axes: /** @type {('x'|'y'|'z')[]} */([]),          // for translation
      axis: /** @type {'roll'|'pitch'|'yaw'|null} */(null), // for rotation
      pointerId: null,

      // rotation-specific
      u: new THREE.Vector3(),
      v: new THREE.Vector3(),
      angle0: 0,
      param0: 0,
    };

    // Utility: which 2D plane to drag for translation in a given view
    const DRAG_SPECS = {
      front:       { axes: ['y','z'], normal: new THREE.Vector3(1,0,0) }, // lock X ‚Üí drag YZ
      left:        { axes: ['x','z'], normal: new THREE.Vector3(0,1,0) }, // lock Y ‚Üí drag XZ
      right:       { axes: ['x','z'], normal: new THREE.Vector3(0,1,0) },
      perspective: { axes: ['x','y'], normal: new THREE.Vector3(0,0,1) }, // lock Z ‚Üí drag XY
    };
    function specForView(name){ return DRAG_SPECS[name] || DRAG_SPECS.perspective; }

    // Helper used in both translate & rotate picking
    function setNDCFromPointerEvent(evt, renderer){
      const rect = renderer.domElement.getBoundingClientRect();
      ndc.x =  ( (evt.clientX - rect.left) / rect.width ) * 2 - 1;
      ndc.y = -( (evt.clientY - rect.top)  / rect.height) * 2 + 1;
    }

    // Clamp helpers (reuse your own ABS_LIMITS/sliderRanges if you have them)
    function clampAngleToLimits(axis, val) {
      return clampToSlider(axis, val);
    }
    function clampLinearToLimits(axis, val) {
      return clampToSlider(axis, val);
    }

    // Attach to each view/canvas
    function attachPoseGizmoHandlers(renderer, camera, viewName) {
      const el = renderer.domElement;

      function pickAll(evt) {
        setNDCFromPointerEvent(evt, renderer);
        raycaster.setFromCamera(ndc, camera);
        const targets = [
          ...rotationPickables,                            // wheel segments
          marker.getObjectByName('marker_pick_proxy'),     // drag proxy
          marker                                          // (fallback)
        ].filter(Boolean);
        return raycaster.intersectObjects(targets, true);
      }

      // Hover: cursor + wheel highlight
      el.addEventListener('pointermove', (evt) => {
        if (slidersLocked) {                // ‚Üê block hover affordances while locked
          el.style.cursor = 'not-allowed';
          return;
        }
        if (dragState.active || calibrationMode) return;
        const hits = pickAll(evt);
        const wheelHit = hits.find(h => h.object?.userData?.axis);
        const dotHit   = hits.find(h => (h.object === marker) || (h.object?.name === 'marker_pick_proxy'));

        resetAllWheelStates();
        if (wheelHit) {
          setWheelState(wheelHit.object.userData.axis, 'hover');
          el.style.cursor = 'grab';
        } else if (dotHit) {
          el.style.cursor = 'grab';
        } else {
          el.style.cursor = 'default';
        }
      });

      // Press: start rotation or translation drag
      el.addEventListener('pointerdown', (evt) => {
        if (slidersLocked) {                // ‚Üê block starting a drag while locked
          el.style.cursor = 'not-allowed';
          return;
        }
        if (calibrationMode) return;

        const hits = pickAll(evt);
        if (!hits.length) return;

        cancelAnimationIfRunning('drag start');

        const top = hits[0];
        const hitAxis = top.object?.userData?.axis || null;

        dragState.active    = true;
        dragState.viewName  = viewName;
        dragState.pointerId = evt.pointerId;
        el.setPointerCapture(dragState.pointerId);
        el.style.cursor = 'grabbing';

        // Update current view and gripper visibility
        currentViewName = viewName;
        updateGripArrowVisibility();

        if (hitAxis) {
          // ROTATION
          dragState.mode = 'rotate';
          dragState.axis = /** @type {'roll'|'pitch'|'yaw'} */(hitAxis);

          const { n, u, v } = planeBasisForAxis(dragState.axis, marker.quaternion);
          dragState.u.copy(u); dragState.v.copy(v);
          dragState.plane.setFromNormalAndCoplanarPoint(n, marker.position);

          const hitPt = new THREE.Vector3();
          raycaster.ray.intersectPlane(dragState.plane, hitPt);
          dragState.angle0 = angleOnPlaneFromPoint(hitPt, marker.position, dragState.u, dragState.v);
          dragState.param0 = params[dragState.axis];

          resetAllWheelStates();
          setWheelState(dragState.axis, 'active');
        } else {
          // TRANSLATION
          dragState.mode = 'translate';
          const spec = specForView(viewName);
          dragState.axes = spec.axes;
          dragState.plane.setFromNormalAndCoplanarPoint(spec.normal, marker.position);
        }

        evt.preventDefault();
      });

      // Dragging
      el.addEventListener('pointermove', (evt) => {
        if (!dragState.active || dragState.viewName !== viewName) return;

        setNDCFromPointerEvent(evt, renderer);
        raycaster.setFromCamera(ndc, camera);

        const hitPoint = new THREE.Vector3();
        if (!raycaster.ray.intersectPlane(dragState.plane, hitPoint)) return;

        if (dragState.mode === 'translate') {
          dragState.axes.forEach(axis => {
            const v = (axis === 'x') ? hitPoint.x : (axis === 'y') ? hitPoint.y : hitPoint.z;
            params[axis] = clampLinearToLimits(axis, v);
          });
          updateGoal(); // your function that copies params ‚Üí marker/goal
          // Update sliders display and UI state
          revealMinimalRobotFromPose();
          updateGripHUDInteractivity();
          dragState.axes.forEach(axis => {
            if (sliderCtrls[axis]) sliderCtrls[axis].updateDisplay();
          });
          updateSlidersDisplay(dragState.axes);
        } else if (dragState.mode === 'rotate' && dragState.axis) {
          const ang1 = angleOnPlaneFromPoint(hitPoint, marker.position, dragState.u, dragState.v);
          const dAng = normalizeAngle(ang1 - dragState.angle0);
          let newVal = dragState.param0 + dAng;
          newVal = clampAngleToLimits(dragState.axis, newVal);

          params[dragState.axis] = newVal;
          updateGoal();
          // Update slider display and UI state
          revealMinimalRobotFromPose();
          updateGripHUDInteractivity();
          if (sliderCtrls[dragState.axis]) sliderCtrls[dragState.axis].updateDisplay();
        }

        updateTaskCompletedAvailability();

        evt.preventDefault();
      });

      function endDrag(){
        if (!dragState.active) return;
        try { el.releasePointerCapture(dragState.pointerId); } catch(_) {}
        dragState.active   = false;
        const endedAxis    = dragState.axis;
        dragState.mode     = null;
        dragState.axis     = null;
        dragState.viewName = null;
        dragState.axes     = [];
        el.style.cursor    = 'default';

        resetAllWheelStates();
        if (endedAxis) setWheelState(endedAxis, 'hover');
      }

      // Track mouse position globally to re-evaluate hover after drag end
      el.addEventListener('pointermove', (e)=> { window._lastMouseX = e.clientX; window._lastMouseY = e.clientY; });

      el.addEventListener('pointerup',     endDrag);
      el.addEventListener('pointercancel', endDrag);
      el.addEventListener('pointerleave',  () => { if (dragState.active) endDrag(); });
    }

    /* ---------- camera-view buttons --------------------------- */

    /* ---------- camera-view buttons --------------------------- */
    function poseToMatrix(mat){
      return new THREE.Matrix4().set(
        mat[0][0], mat[0][1], mat[0][2], mat[0][3],
        mat[1][0], mat[1][1], mat[1][2], mat[1][3],
        mat[2][0], mat[2][1], mat[2][2], mat[2][3],
        mat[3][0], mat[3][1], mat[3][2], mat[3][3],
      );
    }

    function selectView(viewName) {
      // Remove selection from all views
      views.forEach(view => {
        view.container.classList.remove('selected');
      });
      
      // Select the new view
      const view = views.get(viewName);
      if (view) {
        // Only show visual selection highlighting in devMode
        if (devMode) {
          view.container.classList.add('selected');
        }
        currentViewName = viewName;
        
        // Update gripper arrow visibility based on selected view
        updateGripArrowVisibility();
        
        if (calibrationMode) {
          destroyCalibGUI();
          enterCalibration();
        }
      }
    }

    function initializeViews() {
      // Clear existing views
      views.clear();
      viewsGrid.innerHTML = '';
      
      // Get available camera poses and textures
      const availableViews = [];
      Object.keys(camPoses).forEach(poseKey => {
        const viewName = poseKey.replace('_pose', '');
        if (viewTextures[viewName] && cameraModels[viewName]) {
          availableViews.push({
            name: viewName,
            poseKey,
            texture: viewTextures[viewName],      // keep if you need size/aspect
            imageSrc: state.views?.[viewName],     // <‚Äî add the base64 JPEG for CSS bg
            model: cameraModels[viewName],
            pose: camPoses[poseKey]
          });
        }
      });
      
      console.log(`[DEBUG] availableViews:`, availableViews.map(v => v.name));
      
      if (availableViews.length === 0) return;
      
      // Setup grid layout
      setupViewportGrid(availableViews.length);
      
      // Create views
      availableViews.forEach((viewInfo, index) => {
        const view = createViewRenderer(
          viewInfo.name,
          viewInfo.model,
          viewInfo.texture,
          viewInfo.imageSrc
        );
        attachPoseGizmoHandlers(view.renderer, view.camera, view.name);
        createGripHUDForView(view);

        // --- NEW: if a mask exists for this view, mount the overlay ---
        const segUrl = segmentsByView[viewInfo.name];
        if (segUrl) {
          attachSegOverlay(view, segUrl);
        }
        
        // Set up camera pose and projection
        updateViewCamera(view, viewInfo.pose);
        applyProjectionFromK(view);
        
        // For 3 views, hide the 4th grid position
        if (availableViews.length === 3 && index === 2) {
          view.container.style.gridColumn = '1 / -1';
          view.container.style.justifySelf = 'center';
        }
      });
      
      // Update sizes and select first view
      updateViewSizes();
      if (availableViews.length > 0) {
        // In devMode, select the first view for visual feedback
        // In regular mode, just set currentViewName without visual selection
        if (devMode) {
          selectView(availableViews[0].name);
        } else {
          currentViewName = availableViews[0].name;
          console.log(`[DEBUG] Initial currentViewName set to: "${currentViewName}"`);
          updateGripArrowVisibility(); // Update arrow visibility for initial view
        }
      }
    }

    const btnBar   = document.createElement('div');
    btnBar.style.position = 'fixed';
    btnBar.style.top = '8px';
    btnBar.style.left = '8px';
    btnBar.style.zIndex = 10;
    btnBar.style.display = 'flex';
    btnBar.style.gap = '4px';
    document.body.appendChild( btnBar );

    /* add camera selection buttons (only if devMode enabled) */
    if (devMode) {
      Object.keys(camPoses).forEach(poseKey=>{
        const viewName = poseKey.replace('_pose', '');
        const b       = document.createElement('button');
        b.textContent = viewName; // "left", "right", ‚Ä¶
        b.onclick     = ()=> selectView(viewName);
        btnBar.appendChild( b );
      });
    }

    /* add calibrate toggle button (only if devMode enabled) */
    if (devMode) {
      const calibrateBtn = document.createElement('button');
      calibrateBtn.textContent = 'calibrate';
      calibrateBtn.onclick = () => {
        if (!calibrationMode) {
          if (!currentViewName) { alert('Pick a camera view first (front/left/right/...).'); return; }
          enterCalibration();
          calibrateBtn.textContent = 'exit calibration';
        } else {
          exitCalibration();
          calibrateBtn.textContent = 'calibrate';
        }
      };
      btnBar.appendChild(calibrateBtn);
    }

    /* add hide/show robot model button (bottom-left corner) (only if devMode enabled) */
    if (devMode) {
      toggleRobotBtn = document.createElement('button');
      toggleRobotBtn.textContent = 'show robot model';
      toggleRobotBtn.style.position = 'fixed';
      toggleRobotBtn.style.left     = '8px';
      toggleRobotBtn.style.bottom   = '8px';
      toggleRobotBtn.style.zIndex   = 10;
      document.body.appendChild(toggleRobotBtn);

      toggleRobotBtn.onclick = () => {
        robotVisible = !robotVisible;
        robot.visible = robotVisible;
        toggleRobotBtn.textContent = robotVisible
          ? 'hide robot model'
          : 'show robot model';
      };

      toggleRobotBtn.textContent = 'show robot model';
    }

    let taskCompletedSelected = false;
    let taskCompletedBtn = null;

    /* ---------- confirm button (lower-right corner) ------------------- */

    // Initialize the multi-view system
    initializeViews();

    // Keep canvas sizes and per-view projection matrices in sync
    window.addEventListener('resize', () => {
      updateViewSizes();
      // Recompute projection for each view after its canvas size changes
      views.forEach(v => applyProjectionFromK(v));
    });

  /* ---------- confirm button (inside controls container) ------------------- */

    // Create confirm button to be added to controls container
    const confirmBtn = document.createElement('button');
    confirmBtn.textContent = 'Confirm';
    confirmBtn.className = 'confirm-button';

    confirmBtn.onclick = async () => {
      // 0) Freeze any ongoing animation (unchanged)
      if (animState.enabled) {
        animState.enabled = false;
        animating = false;
        updateGripArrowVisibility();
        if (animateBtn) animateBtn.classList.remove('active');
        setPoseGizmosVisible(true);
        setGhostMode(false);
        applyPostAnimationVisibility();
      }

      // NEW: If "Task Already Completed" is selected, POST that and exit early.
      if (taskCompletedSelected) {
        try {
          const response = await apiFetch(`/api/task-already-completed`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              state_id: state.state_id,
              episode_id: state.episode_id,
              task_already_completed: true
            })
          });

          if (response.ok) {
            console.log('‚úÖ Task already completed response sent');
            delayedRefresh(6000);
          } else {
            const errorData = await response.json().catch(() => ({}));
            console.error('‚ùå Failed to send task already completed response:', errorData);
            alert('Failed to submit response. Please try again.');
          }
        } catch (err) {
          console.error('‚ùå Failed to send task already completed response', err);
          alert('Failed to submit response. Please try again.');
        }
        return; // IMPORTANT: do NOT run the normal submit-goal flow.
      }

      // ===== Normal submit-goal flow (unchanged below) =====

      // 1) Use the intended goal pose
      const { pos: tgtPos, quat: tgtQuat } = getTargetPose();

      // 2) Snap the IK goal to that target and explicitly solve to it now
      goal.setPosition(tgtPos.x, tgtPos.y, tgtPos.z);
      goal.setQuaternion(tgtQuat.x, tgtQuat.y, tgtQuat.z, tgtQuat.w);

      setIKFromUrdf(ikRoot, robot);
      for (let i = 0; i < 25; i++) solver.solve();
      setUrdfFromIK(robot, ikRoot);

      // 3) Read joints
      const jointMap = {};
      Object.entries(robot.joints).forEach(([name, joint]) => {
        jointMap[name] = joint.jointValue;
      });

      // 4) Build ee_pose
      const eeEuler = new THREE.Euler().setFromQuaternion(tgtQuat, "XYZ");

      const poseResetToDefault = slidersAtDefault();
      const slidersChangedAxes = getChangedAxes();

      try {
        const response = await apiFetch(`/api/submit-goal`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            joint_positions: jointMap,
            gripper: gripDir,
            ee_pose: {
              position: [tgtPos.x, tgtPos.y, tgtPos.z],
              rpy: [eeEuler.x, eeEuler.y, eeEuler.z]
            },
            state_id: state.state_id,
            episode_id: state.episode_id,
            pose_reset_to_default: poseResetToDefault,
            sliders_changed_axes: slidersChangedAxes
          })
        });

        if (response.ok) {
          console.log('‚úÖ goal sent (final goal joints)');
          delayedRefresh(6000);
        } else {
          console.error('‚ùå failed to send goal - server error:', response.status);
        }
      } catch (err) {
        console.error('‚ùå failed to send goal', err);
      }
    };



    // Animate toggle button (appears above Confirm)
    const animateBtn = document.createElement('button');
    animateBtn.className = 'btn-compact btn-animate';
    animateBtn.innerHTML = '<span class="icon">‚èØ</span><span class="label">Animate</span>';
    animateBtn.onclick = toggleAnimation;

    // --- cancel helper + global listeners ---------------------------------
    cancelAnimationIfRunning = (reason = '') => {
      if (!animState.enabled) return;

      // Turn OFF animation (same as clicking "Animate" again to stop)
      animState.enabled = false;
      animateBtn.classList.remove('active');

      animating = false;
      updateGripArrowVisibility();

      // Snap the goal to the current target to avoid jumps
      const { pos, quat } = getTargetPose();
      goal.setPosition(pos.x, pos.y, pos.z);
      goal.setQuaternion(quat.x, quat.y, quat.z, quat.w);

      // Restore normal visuals
      setPoseGizmosVisible(true);
      setGhostMode(false);
      applyPostAnimationVisibility();
      setHUDHiddenForAnimation(false);

      if (reason) console.log('‚èπÔ∏è Animate cancelled:', reason);
    };

    // Stop animation if the user presses anywhere on the page
    // (ignore clicks on the Animate button itself so it can toggle ON/OFF normally)
    window.addEventListener('pointerdown', (e) => {
      const t = e.target;
      if (t === animateBtn || (animateBtn && animateBtn.contains && animateBtn.contains(t))) return;
      cancelAnimationIfRunning('pointerdown anywhere');
    }, { capture: true });

    const resetAllBtn = document.createElement('button');
    resetAllBtn.className = 'btn-compact btn-reset';
    resetAllBtn.innerHTML = '<span class="icon">‚Ü∫</span><span class="label">Reset</span>';

    resetAllBtn.onclick = () => {
      // Stop any animation and show gizmos again
      if (animState.enabled) {
        animState.enabled = false;
        animateBtn.classList.remove('active');
        animating = false;
        updateGripArrowVisibility();
        setPoseGizmosVisible(true);
        setGhostMode(false);
        applyPostAnimationVisibility();
      }

      // Reset policy state: back to "not revealed"
      userHasAdjustedPose = false;
      hideRobotCompletely();

      // Pose ‚Üí back to initial
      params.x = initialParams.x; params.y = initialParams.y; params.z = initialParams.z;
      params.roll = initialParams.roll; params.pitch = initialParams.pitch; params.yaw = initialParams.yaw;
      prevAngles.roll = params.roll; prevAngles.pitch = params.pitch; prevAngles.yaw = params.yaw;

      targetPose.pos.copy(startPos);
      targetPose.quat.copy(startQuat);

      goal.setPosition(startPos.x, startPos.y, startPos.z);
      goal.setQuaternion(startQuat.x, startQuat.y, startQuat.z, startQuat.w);

      // Marker
      marker.position.copy(startPos);
      marker.quaternion.copy(startQuat);

      // Robot joints ‚Üí initial
      if (initialJointPositions) {
        for (const [name, val] of Object.entries(initialJointPositions)) {
          robot.setJointValue(name, val);
        }
        robot.updateMatrixWorld(true);
      }

      // Gripper ‚Üí initial (and visuals)
      gripDir = initialGripDir;
      drawGripArrows(gripDir);
      updateGripArrowVisibility();
      updateGripperButtonStates();

      // Dev-only: refresh slider UI if present
      if (devMode && gui) {
        Object.keys(sliderCtrls).forEach(k => sliderCtrls[k]?.updateDisplay());
        ['x','y','z','roll','pitch','yaw'].forEach(updateSliderDecor);
      }

      // Task Already Completed ‚Üí clear selection (back to neutral)
      if (taskCompletedSelected) {
        taskCompletedSelected = false;
        if (taskCompletedBtn) {
          taskCompletedBtn.classList.remove('active');
          taskCompletedBtn.classList.add('inactive');
          taskCompletedBtn.setAttribute('aria-pressed', 'false');
        }
      }

      // Locks / availability reflect "reset to default"
      recordLastGood(poseAxes);
      updateTaskCompletedAvailability();
      recomputeLocks();

      updateGripHUDState();
      updateGripHUDInteractivity();

      // Force widget + arrow accent recolor
      if (lastGripForceN != null) {
        const status = classifyGrip(lastGripForceN);
        forceUI.update(lastGripForceN, status);
        applyGripVisual(status, lastGripForceN);
      }
    };

    const spanDefs = [
      ['x',     0.20],   // meters
      ['y',     0.40],
      ['z',     0.20],
      ['roll',  1.0],   // radians
      ['pitch', 0.81],
      ['yaw',   0.81],
    ];

    // Keep references so dragging can clamp to slider ranges & update displays
    const sliderCtrls   = {};  // axis -> lil-gui controller
    const sliderCenters = {};  // axis -> center value
    const sliderRanges  = {};  // axis -> {min, max}

    if (devMode && gui) {
      spanDefs.forEach(([key, span])=>{
        if (!activeControls.includes(key)) return;
        const center = params[key];                // original pose
        const min = center - span;
        const max = center + span;
        const controller = gui.add(params, key, min, max); // keep track centered visually
        controller.onChange(() => {
          cancelAnimationIfRunning('slider change');
          revealMinimalRobotFromPose();
          if (slidersLocked) {
            // Revert the bound value and refresh the UI; do not push to IK
            params[key] = lastGoodParams[key];
            controller.updateDisplay();
            return;
          }
          // Invisible barrier: clamp to ABS within the (center¬±span) track
          // Also apply a small snap detent to the exact center.
          const { min: smin, max: smax } = sliderRanges[key];
          const abs = ABS_LIMITS[key];
          const spanNow = smax - smin;
          const detent = 0.02 * spanNow;
          if (Math.abs(params[key] - sliderCenters[key]) <= detent) {
            params[key] = sliderCenters[key];
          } else {
            params[key] = clampToSlider(key, params[key]); // (track ‚à© ABS)
          }
          updateGoal();
          updateGripHUDInteractivity();
          updateTaskCompletedAvailability();
          updateSliderDecor(key);
        });

        // Save references for drag interaction
        sliderCtrls[key]   = controller;
        sliderCenters[key] = center;
        sliderRanges[key]  = { min, max };  // full centered track (not pre‚Äëclamped to ABS)

        // Add reset button to each slider
        setTimeout(() => {
          const controllerEl = controller.domElement;
          if (controllerEl) {
            const resetBtn = document.createElement('button');
            resetBtn.textContent = '‚ü≤';
            resetBtn.className = 'reset-btn';
            resetBtn.title = `Reset ${key} to default`;
            resetBtn.onclick = (e) => {
              e.preventDefault();
              e.stopPropagation();
              // Reset EXACTLY to the original center, even if out-of-bounds.
              // Slider track stays clamped; first user interaction will snap back into the valid range.
              params[key] = sliderCenters[key];
              controller.updateDisplay();
              updateGoal();
              updateGripHUDInteractivity();
              updateTaskCompletedAvailability();
              updateSliderDecor(key);
            };
            controllerEl.appendChild(resetBtn);
          }
          // Initial decoration
          updateSliderDecor(key);
        }, 0);
      });
    }

    setSlidersLocked(false);
    // Ensure marker/goal reflect params (and any implicit clamping from controller init)
    updateGoal();
    updateGripHUDInteractivity();

    // Add gripper buttons after sliders
    if (gripperButtonsContainer && devMode) {
      controlsContainer.appendChild(gripperButtonsContainer);
      updateGripperButtonStates(); // Set initial button states
    }

    // Evaluate initial interactivity (usually enabled because sliders = defaults)
    updateGripperInteractivity();

    workbar.appendChild(animateBtn);

    workbar.appendChild(resetAllBtn);

    // Add confirm button at the bottom
    confirmBar.appendChild(confirmBtn);

    /* === NEW: keep workbar buttons in sync with TAC / locks === */
    function reflectWorkbarInteractivity(){
      const tacOn = taskCompletedSelected === true;
      if (animateBtn) {
        animateBtn.disabled = tacOn;         // disable Animate when TAC is on
        if (tacOn) animateBtn.classList.remove('active');
      }
      if (resetAllBtn) resetAllBtn.disabled = false; // Reset stays enabled
    }

    // Patch recomputeLocks to also update the workbar
    (function patchRecomputeLocks(){
      const _recomputeLocks = recomputeLocks;
      recomputeLocks = function(){
        _recomputeLocks();
        reflectWorkbarInteractivity();
      };
      reflectWorkbarInteractivity(); // initialize once
    })();


    updateTaskCompletedAvailability();

    // Update layout based on number of active controls
    function updateControlsLayout() {
      // We‚Äôre not showing a right column anymore.
      controlsContainer.style.display = 'none';
      controlsWrapper.style.display = 'none';

      // Remove layout classing meant for slider columns.
      mount.classList.remove('single-slider', 'multiple-sliders');
    }


    updateControlsLayout();


    /* --- solver --- */
    const solver = new Solver(ikRoot);                // constructor takes root
    // (solver settings default to 5 iterations, etc.)

    /* --- animation loop --- */
    function animate(now) {
      requestAnimationFrame(animate);

      // If Animate is ON: forward (start‚Üítarget) ‚Üí hold at target ‚Üí restart.
      if (animState.enabled) {
        if (!animState.lastTs) animState.lastTs = now;
        const dt = Math.min(100, now - animState.lastTs); // clamp spikes
        animState.lastTs = now;

        // Always sample the *current* target from sliders/drags
        const { pos: tgtPos, quat: tgtQuat } = getTargetPose();

        if (animState.phase === 'forward') {
          animState.t += (dt / animState.duration);
          if (animState.t >= 1) {
            animState.t = 1;
            animState.phase = 'hold';
            animState.holdElapsed = 0;
          }
          _interpPos.copy(startPos).lerp(tgtPos, animState.t);
          _interpQuat.copy(startQuat).slerp(tgtQuat, animState.t);
          goal.setPosition  (_interpPos.x,  _interpPos.y,  _interpPos.z);
          goal.setQuaternion(_interpQuat.x, _interpQuat.y, _interpQuat.z, _interpQuat.w);
        } else { // 'hold'
          animState.holdElapsed += dt;
          // Stay exactly at the (live) goal during the hold window
          goal.setPosition  (tgtPos.x,  tgtPos.y,  tgtPos.z);
          goal.setQuaternion(tgtQuat.x, tgtQuat.y, tgtQuat.z, tgtQuat.w);
          if (animState.holdElapsed >= animState.holdMs) {
            // Teleport robot back to the *initial joint configuration*
            if (initialJointPositions) {
              for (const [name, val] of Object.entries(initialJointPositions)) {
                robot.setJointValue(name, val);
              }
              robot.updateMatrixWorld(true);
            }

            // Reset the IK goal to the original EE pose (start)
            goal.setPosition(startPos.x, startPos.y, startPos.z);
            goal.setQuaternion(startQuat.x, startQuat.y, startQuat.z, startQuat.w);

            // Begin a fresh forward pass
            animState.phase = 'forward';
            animState.t = 0;
            animState.holdElapsed = 0;
          }

        }
      }

      // Solve IK for this frame
      setIKFromUrdf(ikRoot, robot);
      solver.solve();
      setUrdfFromIK(robot, ikRoot);

      // ----- yellow drop lines from finger tips -----
      function updateFingerLine(link, lineMesh, localTipVec) {
        if (!link) { lineMesh.visible = false; return; }
        link.updateMatrixWorld(true);
        const tipWorld = localTipVec.clone().applyMatrix4(link.matrixWorld);
        const lenToFloor = tipWorld.z - (floorZ + fingerBottomPad);
        if (lenToFloor <= 0) { lineMesh.visible = false; return; }
        lineMesh.visible = true;
        lineMesh.scale.y = lenToFloor / baseLineLen;
        const midZ = (floorZ + fingerBottomPad) + 0.5 * lenToFloor;
        lineMesh.position.set(tipWorld.x, tipWorld.y, midZ);
      }
      updateFingerLine(leftFingerLink,  leftFingerLine,  fingerTipLocalLeft);
      updateFingerLine(rightFingerLink, rightFingerLine, fingerTipLocalRight);

      // ----- gripper arrows track the two finger links -----
      gripArrows.forEach(arrow => {
        const link = arrow.userData.targetLink;
        const originLocal = arrow.userData.originLocal;
        const dirLocal = arrow.userData.dirLocal;
        if (!link) return;
        link.updateMatrixWorld(true);
        const worldPos = originLocal.clone().applyMatrix4(link.matrixWorld);
        arrow.position.copy(worldPos);
        const worldDir = dirLocal.clone().transformDirection(link.matrixWorld);
        arrow.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), worldDir);
      });
      updateGripArrowVisibility();

      // ----- rotation wheels follow marker orientation -----
      (function updateWheels(){
        const pos = marker.position;
        const q = marker.quaternion;
        const xW = new THREE.Vector3(1,0,0).applyQuaternion(q).normalize();
        const yW = new THREE.Vector3(0,1,0).applyQuaternion(q).normalize();
        const zW = new THREE.Vector3(0,0,1).applyQuaternion(q).normalize();
        if (rotationWheels.roll) {
          rotationWheels.roll.group.position.copy(pos);
          alignRingToNormal(rotationWheels.roll.group, xW);
        }
        if (rotationWheels.pitch) {
          rotationWheels.pitch.group.position.copy(pos);
          alignRingToNormal(rotationWheels.pitch.group, yW);
        }
        if (rotationWheels.yaw) {
          rotationWheels.yaw.group.position.copy(pos);
          alignRingToNormal(rotationWheels.yaw.group, zW);
        }
      })();

      positionGripHUDs();

      // ----- render all views -----
      views.forEach(view => {
        // 1) Move the segmentation with the gripper (unchanged)
        updateSegOverlayForView(view);

        // 2) Render this view
        scene.background = null; // canvas stays transparent; camera is the CSS bg
        view.renderer.render(scene, view.camera);
      });
    }


    animate();
  }
);

</script></body></html>
