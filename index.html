<!-- wxai_min.html  ‚Äì  minimal translate-only IK demo -->
<!DOCTYPE html><html lang="en"><head>
<meta charset="utf-8" />
<title>WidowX AI - position IK only</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#f5f5f5}
  /* Multi-view container wrapper with blue background */
  #viewport{
    position:fixed; 
    top:50%; left:50%; 
    transform:translate(-50%, -50%);
    background: #3b82f6;
    border-radius: 12px;
    padding: 20px;
    box-shadow:0 4px 20px rgba(0,0,0,0.15);
    display: flex;
    flex-direction: column;
    gap: 20px;
  }
  
  /* Text prompt area */
  #viewport .prompt-text{
    color: white;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans";
    font-size: 18px;
    font-weight: 600;
    text-align: left;
    text-shadow: 0 2px 4px rgba(0,0,0,0.3);
    line-height: 1.4;
    min-height: auto;
    padding: 0;
    margin: 0;
  }

  /* Content container for views and controls */
  #viewport .content-container{
    display: flex;
    gap: 20px;
    align-items: center;
  }
  
  /* Grid container for camera views */
  #viewport .views-grid{
    display:grid; 
    gap:0px; 
    border-radius:4px;
    overflow:hidden;
    flex-shrink: 0;
  }

  /* Container for sliders with CAPTCHA styling */
  #viewport .controls-container{
    background: rgba(255, 255, 255, 0.95);
    border-radius: 8px;
    padding: 16px 16px 12px 16px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    border: 1px solid rgba(255,255,255,0.2);
    min-width: 200px;
    display: flex;
    flex-direction: column;
    gap: 20px;
  }

  /* Single slider layout (underneath views) */
  #viewport.single-slider{
    flex-direction: column;
  }
  #viewport.single-slider .content-container{
    flex-direction: column;
    align-items: center;
  }
  #viewport.single-slider .controls-container{
    align-self: center;
    max-width: 400px;
  }

  /* Multiple slider layout (to the right of views) */
  #viewport.multiple-sliders .content-container{
    flex-direction: row;
    align-items: center;
  }

  /* Position task completed container in multiple slider layout */
  #viewport.multiple-sliders .task-completed-container {
    margin-top: 12px;
    align-self: flex-start;
  }

  /* Position task completed container in single slider layout */
  #viewport.single-slider .task-completed-container {
    align-self: center;
    max-width: 400px;
    margin-top: 12px;
  }

  /* Style the lil-gui within controls container */
  .controls-container .lil-gui {
    --background-color: transparent;
    --widget-color: rgba(255,255,255,0.9);
    --hover-color: rgba(255,255,255,1);
    --focus-color: #3b82f6;
    --text-color: #374151;
    --text-color-disabled: #9ca3af;
    --border-color: rgba(0,0,0,0.1);
    --border-color-hover: rgba(0,0,0,0.2);
    border: none !important;
    box-shadow: none !important;
    font-size: 16px;
  }

  /* Hide any lil-gui title/header elements */
  .controls-container .lil-gui .title,
  .controls-container .lil-gui .lil-gui > .title {
    display: none !important;
  }

  .controls-container .lil-gui .controller {
    margin: 8px 0;
    height: 32px;
  }

  .controls-container .lil-gui .controller .name {
    font-size: 16px;
    font-weight: 500;
    min-width: 60px;
  }

  .controls-container .lil-gui .controller input[type="range"] {
    -webkit-appearance: none;
    appearance: none;
    background: linear-gradient(to right, #d1d5db 0%, #d1d5db 100%);
    border-radius: 8px;
    height: 16px;
    min-width: 140px;
    outline: none;
    border: 1px solid #9ca3af;
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
    pointer-events: auto !important;
    cursor: pointer;
  }

  /* Ensure calibration GUI sliders are interactive */
  .lil-gui input[type="range"] {
    pointer-events: auto !important;
    cursor: pointer;
    user-select: none;
  }

  /* Webkit slider thumb (Chrome, Safari, Edge) */
  .controls-container .lil-gui .controller input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 40px;
    height: 28px;
    background: linear-gradient(145deg, #cbd5e1 0%, #94a3b8 50%, #64748b 100%);
    border: 2px solid #475569;
    border-radius: 6px;
    cursor: pointer;
    box-shadow: 
      0 3px 8px rgba(0,0,0,0.4), 
      inset 0 1px 0 rgba(255,255,255,0.3);
    position: relative;
  }

  /* Firefox slider thumb */
  .controls-container .lil-gui .controller input[type="range"]::-moz-range-thumb {
    width: 40px;
    height: 28px;
    background: linear-gradient(145deg, #cbd5e1 0%, #94a3b8 50%, #64748b 100%);
    border: 2px solid #475569;
    border-radius: 6px;
    cursor: pointer;
    box-shadow: 
      0 3px 8px rgba(0,0,0,0.4), 
      inset 0 1px 0 rgba(255,255,255,0.3);
  }

  /* Hover effects */
  .controls-container .lil-gui .controller input[type="range"]::-webkit-slider-thumb:hover {
    background: linear-gradient(145deg, #e2e8f0 0%, #cbd5e1 50%, #94a3b8 100%);
    box-shadow: 
      0 4px 10px rgba(0,0,0,0.5), 
      inset 0 1px 0 rgba(255,255,255,0.5);
    border: 2px solid #334155;
  }

  .controls-container .lil-gui .controller input[type="range"]::-moz-range-thumb:hover {
    background: linear-gradient(145deg, #e2e8f0 0%, #cbd5e1 50%, #94a3b8 100%);
    box-shadow: 
      0 4px 10px rgba(0,0,0,0.5), 
      inset 0 1px 0 rgba(255,255,255,0.5);
    border: 2px solid #334155;
  }

  /* Track styling for Firefox */
  .controls-container .lil-gui .controller input[type="range"]::-moz-range-track {
    background: linear-gradient(to right, #d1d5db 0%, #d1d5db 100%);
    border-radius: 8px;
    height: 16px;
    border: 1px solid #9ca3af;
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
  }

  /* --- visual cue when the slider is exactly at the original center --- */
  .controls-container .lil-gui .controller input[type="range"].at-center::-webkit-slider-thumb {
    border-color: #3b82f6 !important;
    box-shadow:
      0 0 0 3px rgba(59,130,246,.25),
      0 3px 8px rgba(59,130,246,.35),
      inset 0 1px 0 rgba(255,255,255,.6) !important;
  }
  .controls-container .lil-gui .controller input[type="range"].at-center::-moz-range-thumb {
    border-color: #3b82f6 !important;
    box-shadow:
      0 0 0 3px rgba(59,130,246,.25),
      0 3px 8px rgba(59,130,246,.35),
      inset 0 1px 0 rgba(255,255,255,.6) !important;
  }

  /* Hide the number input/display by default */
  .controls-container .lil-gui .controller input[type="number"],
  .controls-container .lil-gui .controller .display {
    display: none !important;
  }

  /* Show numerical values in dev mode */
  body.dev-mode .controls-container .lil-gui .controller input[type="number"],
  body.dev-mode .controls-container .lil-gui .controller .display {
    display: block !important;
    width: 60px;
    font-size: 12px;
    margin-left: 8px;
  }

  /* Gripper button styling */
  .controls-container .gripper-section {
    margin: 0 0 12px 0;
  }

  .controls-container .gripper-label {
    font-size: 16px;
    font-weight: 500;
    color: #374151;
    margin-bottom: 8px;
    text-align: left;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans";
  }

  .controls-container .gripper-buttons {
    display: flex;
    gap: 8px;
    justify-content: center;
    margin: 0;
  }

  /* Reset button styling */
  .controls-container .lil-gui .controller .reset-btn {
    padding: 1px 0px;
    margin-left: 5px;
    border: 1px solid #d1d5db;
    background: #f3f4f6;
    border-radius: 1px;
    font-size: 8px;
    cursor: pointer;
    transition: background 0.2s ease;
    color: #374151;
    width: 30px;
    height: 20px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    user-select: none;
  }

  .controls-container .lil-gui .controller .reset-btn:hover {
    background: #e5e7eb;
    border-color: #9ca3af;
  }

  .controls-container .lil-gui .controller .reset-btn:active {
    background: #d1d5db;
  }

  .controls-container .gripper-buttons button,
  .controls-container .confirm-button {
    padding: 8px 16px;
    border: none;
    border-radius: 6px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    text-transform: capitalize;
  }

  .controls-container .gripper-buttons button.open-btn {
    background: #10b981;
    color: white;
    flex: 1;
  }

  .controls-container .gripper-buttons button.close-btn {
    background: #ef4444;
    color: white;
    flex: 1;
  }

  /* Inactive gripper button states */
  .controls-container .gripper-buttons button.open-btn.inactive {
    background: #e5e7eb;
    color: #6b7280;
    border: 2px solid #d1d5db;
  }

  .controls-container .gripper-buttons button.close-btn.inactive {
    background: #e5e7eb;
    color: #6b7280;
    border: 2px solid #d1d5db;
  }

  /* Active gripper button states (enhanced) */
  .controls-container .gripper-buttons button.open-btn.active {
    background: #10b981;
    color: white;
    border: 2px solid #059669;
    box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.2);
  }

  .controls-container .gripper-buttons button.close-btn.active {
    background: #ef4444;
    color: white;
    border: 2px solid #dc2626;
    box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.2);
  }

  .controls-container .confirm-button {
    background: #3b82f6;
    color: white;
    width: 100%;
    font-size: 16px;
    font-weight: 600;
    padding: 12px 16px;
  }

  /* Task Already Completed button styling */
  .task-completed-container {
    background: rgba(255, 255, 255, 0.95);
    border-radius: 8px;
    padding: 16px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    border: 1px solid rgba(255,255,255,0.2);
    min-width: 200px;
    align-self: flex-start;
  }

  /* Task Already Completed - explicit inactive/active states (parity with gripper buttons) */
  .controls-container .task-completed-button {
    background: #fbbf24;        /* lighter orange when NOT selected */
    color: #ffffff;
    width: 100%;
    box-sizing: border-box;      /* borders won't change width/height */
    font-size: 14px;
    font-weight: 600;
    padding: 10px 16px;
    border-radius: 6px;
    border: 2px solid transparent;  /* reserve space in ALL states */
    cursor: pointer;
    opacity: .85;
    transition: all .15s ease;
    margin-bottom: 12px;
  }

  /* Hover (unchanged) */
  .controls-container .task-completed-button:hover {
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(245, 158, 11, 0.30);
    opacity: 1;
  }

  /* Selected */
  .controls-container .task-completed-button.active {
    background: #f59e0b;
    /* keep the same 2px border thickness so size doesn't change */
    border-color: transparent;
    box-shadow: 0 0 0 3px rgba(245, 158, 11, 0.25), 0 8px 18px rgba(0,0,0,.18);
    opacity: 1;
  }

  /* Explicit unselected */
  .controls-container .task-completed-button.inactive {
    background: #fbbf24;
    color: #ffffff;
    border-color: transparent;   /* DO NOT remove the border */
    box-shadow: none;
    opacity: .85;
  }

  /* Disabled / blocked */
  .controls-container .task-completed-button:disabled {
    background: #e5e7eb;
    color: #9ca3af;
    border: 2px dashed #d1d5db;  /* same thickness as base ‚Üí same size */
    cursor: not-allowed;
    box-shadow: none;
    transform: none;
    opacity: 1;
  }


  .controls-container button:hover {
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    transition: all 0.2s ease;
  }

  .controls-container button:active {
    transform: translateY(0);
  }

  .view-container{
    position:relative;
    display:grid;
    place-items:center;
    overflow:hidden;
  }
  .view-container.selected{border:2px solid #60a5fa;box-shadow:0 0 15px rgba(96,165,250,.6)}
  canvas{display:block;object-fit:cover;width:100%;height:100%}
  /* (no width/height forcing on canvas; renderer controls it) */
 /* --- nice full-screen status overlay + spinner --- */
  #statusOverlay{
    position:fixed; inset:0; display:none; place-items:center;
    background: radial-gradient(1200px 800px at 50% 30%, #111827 0%, #0b0d12 60%, #000 100%);
    color:#e5e7eb; padding:24px; text-align:center;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
  }
  #statusOverlay .card{
    max-width: 720px; width: min(92vw, 720px);
    background: rgba(17,24,39,0.55);
    border: 1px solid rgba(255,255,255,0.08);
    box-shadow: 0 10px 30px rgba(0,0,0,0.5), inset 0 1px 0 rgba(255,255,255,0.04);
    border-radius: 20px; padding: 26px 28px;
    backdrop-filter: blur(8px);
  }
  #statusOverlay .title{ font-size:20px; letter-spacing:.02em; margin:0 0 8px }
  #statusOverlay .msg  { font-size:16px; line-height:1.5; opacity:.9; margin:0 }
  #statusOverlay .row  { display:flex; align-items:center; gap:14px; justify-content:center; margin-bottom:10px }
  #statusOverlay .spinner{
    width:22px; height:22px; border-radius:50%;
    border:3px solid rgba(255,255,255,.25);
    border-top-color:#60a5fa; border-right-color:#93c5fd;
    animation: spin 1s linear infinite;
    box-shadow: 0 0 20px rgba(96,165,250,.35);
  }
  @keyframes spin{ to { transform: rotate(360deg); } }
  
  /* Auto-refresh progress bar styles */
  #refreshProgressBar {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    height: 4px;
    background: rgba(255, 255, 255, 0.2);
    z-index: 10000;
    opacity: 0;
    transition: opacity 0.3s ease;
  }
  
  #refreshProgressBar.visible {
    opacity: 1;
  }
  
  #refreshProgressBar .progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #3b82f6, #1d4ed8);
    width: 0%;
    transition: width 0.1s linear;
    box-shadow: 0 0 10px rgba(59, 130, 246, 0.6);
  }
  
  #refreshCountdown {
    position: fixed;
    top: 20px;
    right: 20px;
    background: rgba(17, 24, 39, 0.9);
    color: white;
    padding: 12px 20px;
    border-radius: 25px;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans";
    font-size: 14px;
    font-weight: 600;
    z-index: 10001;
    backdrop-filter: blur(8px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    opacity: 0;
    transform: translateY(-10px);
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  
  #refreshCountdown.visible {
    opacity: 1;
    transform: translateY(0);
  }
  
  #refreshCountdown .countdown-icon {
    display: inline-block;
    animation: pulse 1s ease-in-out infinite;
  }

  /* Disabled gripper buttons look inert + show not-allowed cursor */
  .controls-container .gripper-buttons button:disabled {
    background: #e5e7eb;
    color: #9ca3af;
    border: 2px dashed #d1d5db;
    cursor: not-allowed;
    box-shadow: none;
  }

  /* Animate button styling */
  .controls-container .animate-button {
    background: #f65c5c;
    color: white;
    width: 100%;
    font-size: 15px;
    font-weight: 600;
    padding: 10px 16px;
    border-radius: 6px;
    border: none;
    cursor: pointer;
    opacity: .85;
    transition: all .15s ease;
    margin-bottom: 12px; /* ‚Üê add a bit of breathing room */
  }
  .controls-container .animate-button:hover {
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(139, 92, 246, .35);
    opacity: 1;
  }
  .controls-container .animate-button.active {
    background: #ed3a3a; /* brighter while active */
    box-shadow: 0 0 0 3px rgba(124, 58, 237, .25), 0 8px 18px rgba(0,0,0,.18);
    opacity: 1;
  }

  .controls-container .task-completed-button { 
    margin-bottom: 12px; /* matches .animate-button‚Äôs bottom margin */
    font-weight: 600;
  }

  /* --- disabled slider look --- */
  .controls-container .lil-gui .controller input[type="range"]:disabled {
    opacity: 0.55;
    cursor: not-allowed;
  }
  .controls-container .lil-gui .controller .reset-btn:disabled {
    opacity: 0.55;
    cursor: not-allowed;
  }

  .controls-container .lil-gui.locked {
    opacity: 0.75;
  }
    
  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.6; }
  }
</style>

<!-- Polyfill so the import-map works everywhere -->
<script async src="https://cdn.jsdelivr.net/npm/es-module-shims@2/dist/es-module-shims.js"></script>

<script type="importmap">
{
  "imports": {
    "three":               "https://cdn.jsdelivr.net/npm/three@0.165/build/three.module.js",
    "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.165/examples/jsm/",
    "urdf-loader":         "https://cdn.jsdelivr.net/npm/urdf-loader@0.12.6/src/URDFLoader.js?module",
    "closed-chain-ik":     "https://cdn.jsdelivr.net/npm/closed-chain-ik@0.18.0/dist/index.module.js"
  }
}
</script></head><body>
  <!-- Centering mount for the WebGL canvas; avoids CSS stretching -->
  <div id="viewport"></div>
  
  <!-- Auto-refresh progress bar -->
  <div id="refreshProgressBar">
    <div class="progress-fill"></div>
  </div>
  
  <!-- Auto-refresh countdown display -->
  <div id="refreshCountdown">
    <span class="countdown-icon">üîÑ</span>
    <span>Loading next task in <span id="countdownTime">5</span>s</span>
  </div>
<script type="module">

/* ---------- stable per-browser session id + fetch helper ---------- */
const SID_STORAGE_KEY = 'crowd_sid';
function getStableSID() {
  try {
    const existing = localStorage.getItem(SID_STORAGE_KEY);
    if (existing) return existing;
  } catch (_) { /* localStorage blocked? proceed with ephemeral */ }

  let sid;
  try {
    sid = (crypto && crypto.randomUUID) ? crypto.randomUUID() : null;
  } catch (_) { sid = null; }
  if (!sid) sid = 'sid-' + Math.random().toString(36).slice(2) + '-' + Date.now();

  try { localStorage.setItem(SID_STORAGE_KEY, sid); } catch (_) {}
  return sid;
}
const SID = getStableSID();
console.log('[SID]', SID);

/** Like fetch(), but always sends X-Session-ID and expands relative API paths */
function apiFetch(path, options = {}) {
  const url = path.startsWith('http') ? path : `${API_BASE_URL}${path}`;
  const headers = { ...(options.headers || {}), 'X-Session-ID': SID };
  return fetch(url, { ...options, headers });
}

/* ---------- imports ---------- */
import * as THREE                    from 'three';
import { OrbitControls }             from 'three/examples/jsm/controls/OrbitControls.js';
import URDFLoader                    from 'urdf-loader';
import {
  urdfRobotToIKRoot,
  setIKFromUrdf,
  setUrdfFromIK,
  Goal,
  Solver,
  DOF
} from 'closed-chain-ik';

import {GUI} from 'three/examples/jsm/libs/lil-gui.module.min.js';

// Simple API Configuration - use appropriate proxy based on environment
async function getCurrentCloudflaredUrl() {
  try {
    // For production (Netlify), always use the function proxy to avoid CORS issues
    if (location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
      return '/.netlify/functions/api';
    }
    
    // For local development, try to get the actual cloudflared URL from Netlify function
    // This only works if running netlify dev, otherwise fallback to hardcoded URL
    try {
      const response = await fetch('/.netlify/functions/get-backend-url');
      if (response.ok) {
        const data = await response.json();
        return data.backend_url;
      }
    } catch (netlifyError) {
      // Netlify functions not available (running on pure Vite dev server)
      console.log('Netlify functions not available, using fallback Tailscale URL');
    }
    
    // Fallback to hardcoded Tailscale URL for local development
    return 'https://ztclab-1.tail503d36.ts.net';
  } catch (error) {
    console.error('Error getting backend URL:', error);
    // Fallback based on environment
    if (location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
      return '/.netlify/functions/api'; // Use proxy for production
    }
    return 'https://reconstruction-parker-put-push.trycloudflare.com'; // Direct for local dev
  }
}

// Initialize API_BASE_URL - will be set dynamically in the loader
let API_BASE_URL = '/.netlify/functions/api'; // Default to proxy

// Function to check if we're in async collection mode
async function isAsyncCollectionMode() {
  try {
    const response = await fetch(`${API_BASE_URL}/api/monitor/latest-state`);
    if (!response.ok) {
      console.warn('Could not check async collection mode, defaulting to false');
      return false;
    }
    const data = await response.json();
    return data.is_async_collection === true;
  } catch (error) {
    console.warn('Error checking async collection mode:', error);
    return false;
  }
}

// Auto-refresh with progress bar function
async function delayedRefresh(delay = 5000) {
  // Check if we're in async collection mode
  const isAsync = await isAsyncCollectionMode();
  
  // If in async collection mode, refresh immediately
  if (isAsync) {
    console.log('üîÑ Async collection mode detected - refreshing immediately');
    // Hard refresh the page to load the next task (equivalent to Ctrl+Shift+R)
    // This forces a bypass of all caches
    window.location.replace(window.location.href.split('?')[0] + '?_=' + Date.now());
    return;
  }
  
  const progressBar = document.getElementById('refreshProgressBar');
  const countdown = document.getElementById('refreshCountdown');
  const countdownTime = document.getElementById('countdownTime');
  const progressFill = progressBar.querySelector('.progress-fill');
  
  // Show progress bar and countdown
  progressBar.classList.add('visible');
  countdown.classList.add('visible');
  
  let timeLeft = delay / 1000; // Convert to seconds
  let elapsed = 0;
  
  const updateInterval = 100; // Update every 100ms for smooth progress
  
  const timer = setInterval(() => {
    elapsed += updateInterval;
    timeLeft = Math.max(0, (delay - elapsed) / 1000);
    
    // Update progress bar
    const progress = (elapsed / delay) * 100;
    progressFill.style.width = `${Math.min(progress, 100)}%`;
    
    // Update countdown display
    countdownTime.textContent = Math.ceil(timeLeft);
    
    // Check if time is up
    if (elapsed >= delay) {
      clearInterval(timer);
      
      // Hide progress elements
      progressBar.classList.remove('visible');
      countdown.classList.remove('visible');
      
      // Perform the refresh after a brief delay to allow animations
      setTimeout(() => {
        // Hard refresh the page to load the next task (equivalent to Ctrl+Shift+R)
        // This forces a bypass of all caches
        window.location.replace(window.location.href.split('?')[0] + '?_=' + Date.now());
      }, 300);
    }
  }, updateInterval);
}

async function getInitialState() {
  try {
    console.log('[DEBUG] Fetching initial state from:', `${API_BASE_URL}/api/get-state`);
    const response = await apiFetch(`/api/get-state`, {
      headers: {
        'Accept': 'application/json'
      }
    });
    console.log('[DEBUG] Response status:', response.status, response.statusText);
    
    if (!response.ok) {
      const responseText = await response.text();
      console.error('[DEBUG] Response error body:', responseText.substring(0, 500));
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const data = await response.json();
    console.log('[DEBUG] Successfully fetched initial state');
    return data;
  } catch (error) {
    console.error("Could not fetch initial state:", error);
    showServerNotStarted();
    // Hide interactive UI when server is not running
    const uiElems = document.querySelectorAll("button, .lil-gui, #viewport");
    uiElems.forEach(el=>{
      el.style.display = "none";
    });
    return {};
  }
}


// Build a THREE.Texture from a base64 JPEG data URL
async function makeTextureFromDataURL(url) {
  const loader = new THREE.TextureLoader();
  return await new Promise((resolve, reject) => {
    loader.load(
      url,
      tex => {
        tex.flipY = true;
        tex.generateMipmaps = false;
        tex.minFilter = THREE.LinearFilter;
        tex.magFilter = THREE.LinearFilter;
        tex.needsUpdate = true;
        resolve(tex);
      },
      undefined,
      err => reject(err)
    );
  });
}

/* ---------- scene ---------- */
const defaultBg = new THREE.Color(0xf5f5f5);
const scene = new THREE.Scene();
scene.background = defaultBg;
scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1));

const dir = new THREE.DirectionalLight(0xffffff, 1.2);
dir.position.set(2, 4, 2);
scene.add(dir);

/* ---------- floor / workspace visual -------------------- */
// light, neutral grid on the ground (y = 0)

// Default camera (will be cloned for each view)
const templateCamera = new THREE.PerspectiveCamera(45, 1, 0.01, 100);
templateCamera.position.set(0.2, -2, 0).applyAxisAngle(new THREE.Vector3(0, -1, 1), Math.PI);

// Render everything at a more compact size for captcha-style layout
const VIEW_SCALE = 0.8;

// Multi-view system
const views = new Map(); // viewName -> {camera, renderer, container, name}
let currentViewName = null;
let calibrationMode = false; // Calibration mode (UI & per-camera params)
const mount = document.getElementById('viewport');

// When true, pose sliders + scene dragging are locked (after gripper changed)
let slidersLocked = false;

// Create the prompt text first
const promptText = document.createElement('div');
promptText.className = 'prompt-text';
promptText.textContent = 'Pick up the red block.'; // Default text, will be updated from server
mount.appendChild(promptText);

// Create the content container for views and controls
const contentContainer = document.createElement('div');
contentContainer.className = 'content-container';
mount.appendChild(contentContainer);

// Create the views grid container
const viewsGrid = document.createElement('div');
viewsGrid.className = 'views-grid';
contentContainer.appendChild(viewsGrid);

// Create a wrapper for controls and task completed button
const controlsWrapper = document.createElement('div');
controlsWrapper.style.display = 'flex';
controlsWrapper.style.flexDirection = 'column';
controlsWrapper.style.gap = '0px';
contentContainer.appendChild(controlsWrapper);

// Create the controls container for sliders
const controlsContainer = document.createElement('div');
controlsContainer.className = 'controls-container';
controlsContainer.style.display = 'none'; // Hidden initially
controlsWrapper.appendChild(controlsContainer);

// Multi-view grid layout helper
function calculateGridLayout(numViews) {
  if (numViews === 1) return { rows: 1, cols: 1 };
  if (numViews === 2) return { rows: 1, cols: 2 };
  if (numViews === 3) return { rows: 2, cols: 2 }; // 2 on top, 1 on bottom
  if (numViews === 4) return { rows: 2, cols: 2 };
  // For more views, calculate a reasonable grid
  const cols = Math.ceil(Math.sqrt(numViews));
  const rows = Math.ceil(numViews / cols);
  return { rows, cols };
}

function setupViewportGrid(numViews) {
  const { rows, cols } = calculateGridLayout(numViews);
  viewsGrid.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
  viewsGrid.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
}

function createViewRenderer(viewName, cameraModel, texture) {
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(devicePixelRatio);
  
  const camera = templateCamera.clone();
  
  const container = document.createElement('div');
  container.className = 'view-container';
  container.dataset.viewName = viewName;
  
  container.appendChild(renderer.domElement);
  viewsGrid.appendChild(container);
  
  const view = {
    camera,
    renderer,
    container,
    name: viewName,
    model: cameraModel,
    texture: texture
  };
  
  views.set(viewName, view);
  return view;
}

function updateViewSizes() {
  const viewContainers = viewsGrid.querySelectorAll('.view-container');
  if (viewContainers.length === 0) return;
  
  // Define compact view dimensions based on number of views (increased by 87.5% total: 1.25 * 1.5)
  const numViews = viewContainers.length;
  let targetWidth, targetHeight;
  
  if (numViews === 1) {
    targetWidth = 600;  // 400 * 1.5
    targetHeight = 450; // 300 * 1.5
  } else if (numViews === 2) {
    targetWidth = 450;  // 300 * 1.5
    targetHeight = 338; // 225 * 1.5
  } else if (numViews === 3 || numViews === 4) {
    targetWidth = 375;  // 250 * 1.5
    targetHeight = 282; // 188 * 1.5
  } else {
    targetWidth = 300;  // 200 * 1.5
    targetHeight = 225; // 150 * 1.5
  }
  
  // Apply sizing to views grid - no gaps or padding now
  const { rows, cols } = calculateGridLayout(numViews);
  const totalWidth = cols * targetWidth; // no gaps
  const totalHeight = rows * targetHeight; // no gaps
  
  viewsGrid.style.width = totalWidth + 'px';
  viewsGrid.style.height = totalHeight + 'px';
  
  views.forEach(view => {
    const model = view.model;
    if (!model) return;
    
    const W = model.width | 0;
    const H = model.height | 0;
    
    // Make canvas fill the entire container
    const containerAspect = targetWidth / targetHeight;
    const imageAspect = W / H;
    
    let renderWidth = targetWidth;
    let renderHeight = targetHeight;
    
    // Fill the container completely (may crop image slightly)
    if (containerAspect > imageAspect) {
      // Container is wider than image aspect - fit to width
      renderHeight = Math.round(targetWidth / imageAspect);
    } else {
      // Container is taller than image aspect - fit to height  
      renderWidth = Math.round(targetHeight * imageAspect);
    }
    
    view.renderer.setSize(renderWidth, renderHeight);
    
    // Set container size to match target exactly
    view.container.style.width = targetWidth + 'px';
    view.container.style.height = targetHeight + 'px';
  });
}


// --- status overlay (initially hidden) ---
const statusOverlay = document.createElement('div');
statusOverlay.id = 'statusOverlay';
document.body.appendChild(statusOverlay);

function showServerNotStarted(){
  statusOverlay.innerHTML = `
    <div class="card">
      <div class="row">
        <div class="spinner" aria-hidden="true"></div>
        <h2 class="title">Connecting to data collection server‚Ä¶</h2>
      </div>
      <p class="msg">
        Data collection server hasn't started yet.<br/>
        Please wait for further communications.
      </p>
    </div>`;
  statusOverlay.style.display = 'grid';
}

// ================================ devMode ===================================
const devMode = false;
// Apply dev-mode class to body if devMode is enabled
if (devMode) {
  document.body.classList.add('dev-mode');
}
// ================================ devMode ===================================


let calibGUI = null;                       // lil-gui instance for calibration
const calibState = {};                     // name -> {tx,ty,tz,rx,ry,rz,fx,fy,cx,cy}
const calibDefaults = {};                  // snapshot at calibration start (per camera)

/* ---------- load URDF ---------- */
const loader = new URDFLoader();
loader.packages = {                 // map package:// paths ‚Üí server paths
  'trossen_arm_description': 'assets/trossen_arm_description'
};

loader.load(
  'assets/trossen_arm_description/urdf/generated/wxai/wxai_base.urdf',
  async robot => {

    // Set API_BASE_URL dynamically based on environment
    if (location.hostname === 'localhost' || location.hostname === '127.0.0.1') {
      if (location.port === '5173' || location.port === '5174') {
        // Running on Vite dev server - get direct cloudflared URL
        API_BASE_URL = await getCurrentCloudflaredUrl();
        console.log('[DEBUG] Using direct cloudflared URL for Vite dev server:', API_BASE_URL);
      } else {
        // Running on production build locally
        API_BASE_URL = 'http://127.0.0.1:9000';
      }
    } else {
      // Running on deployed Netlify - use function proxy to avoid CORS
      API_BASE_URL = '/.netlify/functions/api';
      console.log('[DEBUG] Using Netlify function proxy for production:', API_BASE_URL);
    }

    console.log('Using API Base URL:', API_BASE_URL);

    scene.add(robot);

    showOnlySpecifiedLinks(robot, ['link_6', 'gripper_left', 'gripper_right']);

    let robotVisible = false; // toggle visibility of the robot model
    robot.visible = false;     // hide arm until user moves a slider
    let toggleRobotBtn = null;

    /* --- build IK tree from URDF (limits copied automatically) --- */
    const ikRoot = urdfRobotToIKRoot(robot);          // :contentReference[oaicite:0]{index=0}

    ikRoot.clearDoF()

    const state = await getInitialState();
    const cameraModels = state.camera_models ?? {};
    // If the data collection server isn't available, stop building UI
    if (!state || Object.keys(state).length === 0 || !cameraModels) {
      // Ensure the status overlay is visible and abort UI construction
      showServerNotStarted();
      return; // ‚Üê prevents creating sliders/buttons and starting animation
    }

    /* ---------- build textures from JPEG base64 views --------------- */
    const viewTextures = {}; // 'front' ‚Üí THREE.Texture
    for (const [key, dataUrl] of Object.entries(state.views ?? {})) {
      viewTextures[key] = await makeTextureFromDataURL(dataUrl);
    }

    const initialJointPositions = state.joint_positions ?? {};
    const activeControls        = state.controls ?? ['x','y','z','roll','pitch','yaw'];

    /* ---------- gripper finger-tip calibration (load + state) ---------- */
    const TIP_CAL_LS_KEY = 'wxai_gripper_tip_calib';

    function loadTipCalibFromLS() {
      try { const txt = localStorage.getItem(TIP_CAL_LS_KEY); return txt ? JSON.parse(txt) : null; } catch { return null; }
    }
    function saveTipCalibToLS(obj) {
      try { localStorage.setItem(TIP_CAL_LS_KEY, JSON.stringify(obj)); } catch {}
    }

    // Server-provided values take priority, then localStorage, then defaults
    let tipCalib = (state.gripper_tip_calib && state.gripper_tip_calib.left && state.gripper_tip_calib.right)
      ? JSON.parse(JSON.stringify(state.gripper_tip_calib))
      : (loadTipCalibFromLS() ?? {
          left:  { x: 0.03, y: 0.00, z: 0.00 },
          right: { x: 0.03, y: 0.00, z: 0.00 }
        });

    saveTipCalibToLS(tipCalib); // mirror locally so it's never lost client‚Äëside

    // Calibratable local offsets (per finger) that the renderer uses
    const fingerTipLocalLeft  = new THREE.Vector3(tipCalib.left.x,  tipCalib.left.y,  tipCalib.left.z);
    const fingerTipLocalRight = new THREE.Vector3(tipCalib.right.x, tipCalib.right.y, tipCalib.right.z);

    function applyTipCalibToVectors(){
      fingerTipLocalLeft.set (tipCalib.left.x,  tipCalib.left.y,  tipCalib.left.z);
      fingerTipLocalRight.set(tipCalib.right.x, tipCalib.right.y, tipCalib.right.z);
    }

    
    // Update prompt text from server state
    const promptFromServer = state.prompt || 'Pick up the red block.';
    promptText.textContent = promptFromServer;
    
    for (const [name, val] of Object.entries(initialJointPositions)) {
      robot.setJointValue(name, val);
    }

    /* ---------- gripper-motion arrows ---------------------------------- */
    let gripArrows = [];                       // keeps currently-shown arrow meshes
    let gripDir    = state.gripper ?? 0;

    function drawGripArrows(dir /* +1 open | ‚Äì1 close */) {
      /* remove previous arrows */
      gripArrows.forEach(a => scene.remove(a));
      gripArrows.length = 0;

      if (dir !== undefined && dir !== null) {
        gripDir = dir;     // remember last request only if dir is explicitly provided
      }
      
      // Always create arrows, use current gripDir if no direction specified
      const effectiveDir = (dir !== undefined && dir !== null) ? dir : gripDir || 1; // default to open arrows if no direction available
      const colour   = effectiveDir > 0 ? 0x00ff00 : 0xff0000;
      const len      = 0.04, headLen = 0.02;
      const shaftLen = len - headLen, shaftRad = 0.005, offset = 0.00;
      const tipX     = 0.02;

      function addArrow(linkName, outward) {
        const link = robot.getObjectByName(linkName); if (!link) return;
        const dirLocal    = new THREE.Vector3(0, effectiveDir * outward, 0).normalize();
        const baseDist    = effectiveDir > 0 ? offset : offset + len;
        const originLocal = new THREE.Vector3(tipX, outward * baseDist, 0);

        /* geometry ---------------------------------------------------- */
        const mat       = new THREE.MeshBasicMaterial({ color: colour });
        const grp       = new THREE.Group();

        const shaftGeo  = new THREE.CylinderGeometry(shaftRad, shaftRad,
                                                     shaftLen, 8, 1, true);
        const shaft     = new THREE.Mesh(shaftGeo, mat);
        shaft.position.y = shaftLen / 2;
        grp.add(shaft);

        const coneGeo   = new THREE.ConeGeometry(headLen * 0.6, headLen, 8);
        const cone      = new THREE.Mesh(coneGeo, mat);
        cone.position.y = shaftLen + headLen / 2;
        grp.add(cone);

        grp.position.copy(originLocal);
        grp.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dirLocal);
        
        // Add arrows to scene instead of robot links so they're visible even when robot is hidden
        scene.add(grp);
        
        // Store link reference to update arrow position in animation loop
        grp.userData.targetLink = link;
        grp.userData.originLocal = originLocal.clone();
        grp.userData.dirLocal = dirLocal.clone();
        
        gripArrows.push(grp);
      }
      addArrow('gripper_left',  +1);
      addArrow('gripper_right', -1);
    }

    function updateGripArrowVisibility() {
      // Show gripper arrows only for front and perspective cameras
      const showArrows = currentViewName === 'front' || currentViewName === 'perspective';
      console.log(`[DEBUG] updateGripArrowVisibility: currentViewName="${currentViewName}", showArrows=${showArrows}, gripArrows.length=${gripArrows.length}`);
      gripArrows.forEach(arrow => {
        if (arrow && arrow.visible !== undefined) {
          arrow.visible = showArrows;
        }
      });
    }

    drawGripArrows(state.gripper ?? 0);        // render initial arrows from server
    updateGripArrowVisibility();               // set initial visibility based on current view

    const initialGripDir = gripDir;

    const gui = new GUI({ container: controlsContainer });
    gui.domElement.style.position = 'static'; // Remove absolute positioning
    gui.domElement.style.width = '100%';

    let guiShield = null;  // invisible overlay to block pointer input on lil-gui
    
    // Create gripper controls container (will be added after sliders)
    let gripperButtonsContainer = null;
    let openBtn = null, closeBtn = null; // Store button references for state updates
    
    function updateGripperButtonStates() {
      if (!openBtn || !closeBtn) return;
      
      // Remove all state classes first
      openBtn.classList.remove('active', 'inactive');
      closeBtn.classList.remove('active', 'inactive');
      
      // Apply states based on current gripper direction
      if (gripDir > 0) { // Open
        openBtn.classList.add('active');
        closeBtn.classList.add('inactive');
      } else { // Close
        openBtn.classList.add('inactive');
        closeBtn.classList.add('active');
      }
    }

    function updateGripperInteractivity() {
      if (!openBtn || !closeBtn) return;

      if (taskCompletedSelected) {
        openBtn.disabled = true;
        closeBtn.disabled = true;

        const msg = 'Gripper disabled: "Task Already Completed" is selected.';
        openBtn.title = msg;
        closeBtn.title = msg;

        openBtn.classList.add('inactive'); openBtn.classList.remove('active');
        closeBtn.classList.add('inactive'); closeBtn.classList.remove('active');
        return;
      }

      const atDefault = slidersAtDefault();
      openBtn.disabled = !atDefault;
      closeBtn.disabled = !atDefault;

      const changed = getChangedAxes();
      const hoverMsg = atDefault
        ? 'You can change the gripper state.'
        : `Gripper locked: pose sliders changed (${changed.join(', ')}). Reset sliders to their starting values to change the gripper.`;

      openBtn.title = hoverMsg;
      closeBtn.title = hoverMsg;

      const label = document.querySelector('.gripper-label');
      if (label) label.title = hoverMsg;

      if (!atDefault) {
        openBtn.classList.add('inactive'); openBtn.classList.remove('active');
        closeBtn.classList.add('inactive'); closeBtn.classList.remove('active');
      } else {
        updateGripperButtonStates();
      }
    }


    // --- Task Already Completed availability + global lock orchestration ---
    let taskCompletedBlocked = false;  // becomes true if any slider or gripper is changed

    function setTaskCompletedBlocked(blocked){
      taskCompletedBlocked = blocked;
      if (taskCompletedBtn){
        taskCompletedBtn.disabled = blocked;
        taskCompletedBtn.classList.toggle('blocked', blocked);

        // Update hover/title text to explain why it‚Äôs blocked/available
        const changed = getChangedAxes();
        const gripperChanged = (gripDir !== initialGripDir);
        if (blocked){
          const parts = [];
          if (changed.length) parts.push(`slider changes: ${changed.join(', ')}`);
          if (gripperChanged) parts.push('gripper changed');
          taskCompletedBtn.title = `Blocked - ${parts.join(' & ')}. Reset sliders and gripper to enable.`;
        }else{
          taskCompletedBtn.title = taskCompletedSelected
            ? 'Selected--task already completed--press Confirm to submit'
            : 'Not selected. Press to select, then press Confirm to submit.';
        }
      }
    }

    function updateTaskCompletedAvailability(){
      // Block if any user change from the original state
      const shouldBlock = !slidersAtDefault() || (gripDir !== initialGripDir);
      setTaskCompletedBlocked(shouldBlock);
    }

    function recomputeLocks(){
      // Sliders are locked if TAC is selected OR the gripper is not at its original state
      const lock = taskCompletedSelected || (gripDir !== initialGripDir);
      setSlidersLocked(lock);

      // Explain why the panel is locked
      if (controlsContainer){
        controlsContainer.title = taskCompletedSelected
          ? 'Pose sliders are locked because ‚ÄúTask Already Completed‚Äù is selected.'
          : (gripDir !== initialGripDir ? 'Pose sliders are locked because the gripper state was changed.' : '');
      }

      // Gripper buttons disabled when TAC is selected (regardless of sliders)
      updateGripperInteractivity();
    }


    function setSlidersLocked(locked) {
      slidersLocked = locked;

      // Disable lil-gui range + number inputs (if visible in dev mode)
      const ranges  = controlsContainer.querySelectorAll('.lil-gui input[type="range"]');
      const numbers = controlsContainer.querySelectorAll('.lil-gui input[type="number"]');
      ranges.forEach(el  => { el.disabled = locked; });
      numbers.forEach(el => { el.disabled = locked; });

      // Disable the tiny reset buttons we append to each controller
      const resetBtns = controlsContainer.querySelectorAll('.lil-gui .reset-btn');
      resetBtns.forEach(btn => { btn.disabled = locked; });

      // Dim the panel
      if (gui && gui.domElement) {
        gui.domElement.classList.toggle('locked', locked);

        // Create an invisible shield that catches all pointer events
        if (!guiShield) {
          guiShield = document.createElement('div');
          Object.assign(guiShield.style, {
            position: 'absolute',
            inset: '0',
            zIndex: '2',
            cursor: 'not-allowed',
            background: 'transparent',
            display: 'none',
          });
          // Ensure the lil-gui container is positioned for absolute child
          const s = gui.domElement.style;
          if (!s.position || s.position === 'static') s.position = 'relative';
          gui.domElement.appendChild(guiShield);
        }
        guiShield.style.display = locked ? 'block' : 'none';
      }

      // Panel tooltip
      controlsContainer.title = locked
        ? 'Pose sliders are locked because the gripper state was changed.'
        : '';
    }
    
    
    function onGripperChange(newDir) {
      gripDir = newDir;                         // Update the current gripper direction
      drawGripArrows(newDir);
      updateGripArrowVisibility();
      updateGripperButtonStates();

      // Any gripper change blocks "Task Already Completed" until reset
      updateTaskCompletedAvailability();

      // Lock/unlock sliders considering both gripper change and TAC selection
      recomputeLocks();
    }

    
    if (activeControls.includes('gripper')) {
      gripperButtonsContainer = document.createElement('div');
      gripperButtonsContainer.className = 'gripper-section';
      
      const gripperLabel = document.createElement('div');
      gripperLabel.className = 'gripper-label';
      gripperLabel.textContent = 'gripper';
      gripperButtonsContainer.appendChild(gripperLabel);
      
      const buttonsContainer = document.createElement('div');
      buttonsContainer.className = 'gripper-buttons';
      
      openBtn = document.createElement('button');
      openBtn.textContent = 'Open';
      openBtn.className = 'open-btn';
      openBtn.onclick = () => {
        onGripperChange(+1);
      };
      
      closeBtn = document.createElement('button');
      closeBtn.textContent = 'Close';
      closeBtn.className = 'close-btn';
      closeBtn.onclick = () => {
        onGripperChange(-1);
      };
      
      buttonsContainer.appendChild(openBtn);
      buttonsContainer.appendChild(closeBtn);
      gripperButtonsContainer.appendChild(buttonsContainer);
    }

    const camPoses = state.camera_poses ?? {}

    // --- Intrinsics ‚Üí projection helper (use Knew from backend) ---
    function applyProjectionFromK(view) {
      const model = view.model;
      const camera = view.camera;
      if (!model || !model.Knew || !model.width || !model.height) {
        return false;
      }
      const K = model.Knew;       // 3x3 (row-major)
      const W = model.width|0;
      const H = model.height|0;
      const near = camera.near, far = camera.far;

      // Scale intrinsics to current viewport (CSS) size
      const sz = new THREE.Vector2();
      view.renderer.getDrawingBufferSize(sz);
      const vw = sz.x, vh = sz.y;
      const sx = vw / W, sy = vh / H;

      const fx = K[0][0] * sx, fy = K[1][1] * sy;
      const cx = K[0][2] * sx, cy = K[1][2] * sy;

      // OpenCV pixels (origin top-left, +y down) ‚Üí Three frustum (y up)
      const left   = -cx * near / fx;
      const right  =  (vw - cx) * near / fx;
      const top    =  cy * near / fy;
      const bottom = -(vh - cy) * near / fy;

      const P = new THREE.Matrix4().makePerspective(left, right, top, bottom, near, far);
      camera.projectionMatrix.copy(P);
      camera.projectionMatrixInverse.copy(P).invert();
      camera.projectionMatrixAutoUpdate = false;
      return true;
    }

    function applyDefaultPerspective(view) {
      const camera = view.camera;
      camera.projectionMatrixAutoUpdate = true;
      camera.fov = 45;
      camera.aspect = 1; // Will be updated when renderer size is set
      camera.updateProjectionMatrix();
    }

    function updateViewCamera(view, pose) {
      if (!pose) return false;
      
      const m = poseToMatrix(pose);
      const pos   = new THREE.Vector3();
      const quat  = new THREE.Quaternion();
      const scale = new THREE.Vector3();
      m.decompose(pos, quat, scale);

      view.camera.position.copy(pos);
      view.camera.quaternion.copy(quat);
      view.camera.updateMatrixWorld();
      
      return true;
    }

    /* ---------- calibration helpers (intrinsics & extrinsics) ------- */
    function poseKeyForName(name) {
      // camPoses keys look like "front_pose", "left_pose", ...
      for (const k of Object.keys(camPoses)) if (k.startsWith(name)) return k;
      return null;
    }

    function ensureCalibStateFor(name) {
      if (calibState[name]) return;
      // Seed from current view's camera transform & model K
      const view = views.get(name);
      if (!view) return;
      
      const pos = new THREE.Vector3();
      const quat = new THREE.Quaternion();
      view.camera.updateMatrixWorld();
      view.camera.getWorldPosition(pos);
      view.camera.getWorldQuaternion(quat);
      const eul = new THREE.Euler().setFromQuaternion(quat, 'XYZ');
      const model = cameraModels?.[name];
      const K = model?.Knew;
      calibState[name] = {
        tx: pos.x, ty: pos.y, tz: pos.z,
        rx: eul.x, ry: eul.y, rz: eul.z,
        fx: K ? K[0][0] : 800,
        fy: K ? K[1][1] : 800,
        cx: K ? K[0][2] : (model?.width ?? 640) / 2,
        cy: K ? K[1][2] : (model?.height ?? 480) / 2,
        zoom: 1.0,  // multiplicative scale for fx, fy
      };
    }

    function destroyCalibGUI() { if (calibGUI) { calibGUI.destroy(); calibGUI = null; } }

    function applyExtrinsicsFromParams(name) {
      const s = calibState[name]; if (!s) return;
      const view = views.get(name); if (!view) return;
      
      const q = new THREE.Quaternion().setFromEuler(new THREE.Euler(s.rx, s.ry, s.rz, 'XYZ'));
      view.camera.position.set(s.tx, s.ty, s.tz);
      view.camera.quaternion.copy(q);
      view.camera.updateMatrixWorld(true);
      
      // Update camPoses so switching away/back keeps edited pose
      const key = poseKeyForName(name);
      if (key) {
        const m = new THREE.Matrix4().compose(view.camera.position.clone(), view.camera.quaternion.clone(), new THREE.Vector3(1,1,1));
        const e = m.elements; // row-major in Three (column-major storage)
        camPoses[key] = [
          [e[0], e[4], e[8],  e[12]],
          [e[1], e[5], e[9],  e[13]],
          [e[2], e[6], e[10], e[14]],
          [e[3], e[7], e[11], e[15]],
        ];
      }
    }

    function applyIntrinsicsFromParams(name) {
      const s = calibState[name]; if (!s) return;
      const model = cameraModels?.[name]; if (!model) return;
      const view = views.get(name); if (!view) return;
      
      const z = (s.zoom ?? 1.0);
      const fx_eff = s.fx * z;
      const fy_eff = s.fy * z;
      model.Knew = [
        [fx_eff, 0,     s.cx],
        [0,      fy_eff, s.cy],
        [0,    0,    1   ],
      ];
      applyProjectionFromK(view);
    }

    // tiny helper: add a slider **and** a matching "revert" button for it
    function addParamWithRevert(folder, stateObj, key, range, step, label, onChange, camName){
      const [min, max] = range;
      const ctrl = folder.add(stateObj, key, min, max, step).name(label).onChange((value) => {
        onChange(camName);
      });
      
      const revertObj = {};
      const revertLabel = `revert ${label}`;
      revertObj[revertLabel] = () => {
        // restore from snapshot taken when entering calibration
        stateObj[key] = calibDefaults[camName][key];
        ctrl.updateDisplay();
        onChange(camName);
      };
      folder.add(revertObj, revertLabel);
      return ctrl;
    }

    function enterCalibration() {
      if (!currentViewName) { console.warn('Pick a camera view before calibrating.'); return; }
      calibrationMode = true;
      destroyCalibGUI();
      ensureCalibStateFor(currentViewName);
      const s = calibState[currentViewName];
      calibDefaults[currentViewName] = { ...s };
      calibGUI = new GUI();
      // Position panel top-right with higher z-index and ensure it's interactive
      calibGUI.domElement.style.position = 'fixed';
      calibGUI.domElement.style.top = '8px';
      calibGUI.domElement.style.right = '8px';
      calibGUI.domElement.style.zIndex = 9999;
      calibGUI.domElement.style.pointerEvents = 'auto';
      calibGUI.domElement.style.userSelect = 'none';
      
      // Intrinsics controls (no folder)
      const model = cameraModels[currentViewName];
      const W = model?.width  ?? 640;
      const H = model?.height ?? 480;
      addParamWithRevert(calibGUI, s, 'zoom', [0.1, 5.0], 0.1, 'zoom', applyIntrinsicsFromParams, currentViewName);
      addParamWithRevert(calibGUI, s, 'fx', [50, 8000], 1,   'fx', applyIntrinsicsFromParams, currentViewName);
      addParamWithRevert(calibGUI, s, 'fy', [50, 8000], 1,   'fy', applyIntrinsicsFromParams, currentViewName);
      addParamWithRevert(calibGUI, s, 'cx', [0, W],     0.1, 'cx', applyIntrinsicsFromParams, currentViewName);
      addParamWithRevert(calibGUI, s, 'cy', [0, H],     0.1, 'cy', applyIntrinsicsFromParams, currentViewName);
      
      // Extrinsics controls (no folder)
      addParamWithRevert(calibGUI, s, 'tx', [s.tx - 0.25, s.tx + 0.25], 0.0005, 'tx (m)',   applyExtrinsicsFromParams, currentViewName);
      addParamWithRevert(calibGUI, s, 'ty', [s.ty - 0.25, s.ty + 0.25], 0.0005, 'ty (m)',   applyExtrinsicsFromParams, currentViewName);
      addParamWithRevert(calibGUI, s, 'tz', [s.tz - 0.25, s.tz + 0.25], 0.0005, 'tz (m)',   applyExtrinsicsFromParams, currentViewName);
      addParamWithRevert(calibGUI, s, 'rx', [s.rx - 1.0,  s.rx + 1.0 ], 0.0005, 'roll rx',  applyExtrinsicsFromParams, currentViewName);
      addParamWithRevert(calibGUI, s, 'ry', [s.ry - 1.0,  s.ry + 1.0 ], 0.0005, 'pitch ry', applyExtrinsicsFromParams, currentViewName);
      addParamWithRevert(calibGUI, s, 'rz', [s.rz - 1.0,  s.rz + 1.0 ], 0.0005, 'yaw rz',   applyExtrinsicsFromParams, currentViewName);
      
      // ---- Save calibration action (writes to backend) ----
      const actions = {
        async save_calibration() {
          try {
            // build 4x4 from current cam pose (tx,ty,tz + rx,ry,rz)
            const q = new THREE.Quaternion().setFromEuler(new THREE.Euler(s.rx, s.ry, s.rz, 'XYZ'));
            const Tm = new THREE.Matrix4().compose(
              new THREE.Vector3(s.tx, s.ty, s.tz),
              q,
              new THREE.Vector3(1,1,1)
            );
            // convert to row-major list-of-lists like the rest of the app
            const e = Tm.elements;
            const T_three = [
              [e[0], e[4], e[8],  e[12]],
              [e[1], e[5], e[9],  e[13]],
              [e[2], e[6], e[10], e[14]],
              [e[3], e[7], e[11], e[15]],
            ];
            const model = cameraModels[currentViewName];
            // Use effective fx/fy that include zoom
            const z = (s.zoom ?? 1.0);
            const fx_eff = s.fx * z;
            const fy_eff = s.fy * z;
            const payload = {
              camera: currentViewName,
              intrinsics: {
                width:  model?.width  ?? 640,
                height: model?.height ?? 480,
                Knew: [
                  [fx_eff, 0,    s.cx],
                  [0,    fy_eff, s.cy],
                  [0,    0,    1   ],
                ],
                zoom: z
              },
              extrinsics: { T_three }
            };
            const resp = await apiFetch(`/api/save-calibration`, {
              method: 'POST',
              headers: { 
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(payload)
            });
            const out = await resp.json();
            if (!resp.ok) throw new Error(out?.error || 'save failed');
            console.log('‚úÖ saved calibration:', out);
            alert(`Saved calibration for '${currentViewName}' to ${out.path}`);
          } catch (err) {
            console.error('‚ùå save calibration failed', err);
            alert('Save calibration failed. See console for details.');
          }
        }
      };
      calibGUI.add(actions, 'save_calibration').name('Save calibration');

      /* --------- Gripper tip calibration (dev panel) --------- */
      // Working copy for sliders
      const tipDev = JSON.parse(JSON.stringify(tipCalib));

      // When sliders move: commit to live calib, update vectors, persist locally
      function onTipDevChange(){
        tipCalib.left.x  = tipDev.left.x;  tipCalib.left.y  = tipDev.left.y;  tipCalib.left.z  = tipDev.left.z;
        tipCalib.right.x = tipDev.right.x; tipCalib.right.y = tipDev.right.y; tipCalib.right.z = tipDev.right.z;
        applyTipCalibToVectors();
        saveTipCalibToLS(tipCalib);
      }

      const tipFolderDev = calibGUI.addFolder('gripper tips');
      const rng = [-0.10, 0.10], step = 0.0005; // 0.5 mm step; widen if needed

      tipFolderDev.add(tipDev.left,  'x', rng[0], rng[1], step).name('left x (m)').onChange(onTipDevChange);
      tipFolderDev.add(tipDev.left,  'y', rng[0], rng[1], step).name('left y (m)').onChange(onTipDevChange);
      tipFolderDev.add(tipDev.left,  'z', rng[0], rng[1], step).name('left z (m)').onChange(onTipDevChange);

      tipFolderDev.add(tipDev.right, 'x', rng[0], rng[1], step).name('right x (m)').onChange(onTipDevChange);
      tipFolderDev.add(tipDev.right, 'y', rng[0], rng[1], step).name('right y (m)').onChange(onTipDevChange);
      tipFolderDev.add(tipDev.right, 'z', rng[0], rng[1], step).name('right z (m)').onChange(onTipDevChange);

      // Save to backend (same pattern as camera)
      const tipActions = {
        async save_gripper_tips(){
          const payload = {
            gripper_tip_calib: tipCalib,
            state_id: state.state_id,
            episode_id: state.episode_id
          };
          try {
            // Prefer a generic calibration endpoint (like cameras)
            let resp = await apiFetch(`/api/save-calibration`, {
              method: 'POST',
              headers: { 'Content-Type':'application/json' },
              body: JSON.stringify({ type: 'gripper_tips', ...payload })
            });

            // Fallback: dedicated route if your backend uses one
            if (!resp.ok) {
              resp = await apiFetch(`/api/save-gripper-tips`, {
                method: 'POST',
                headers: { 'Content-Type':'application/json' },
                body: JSON.stringify(payload)
              });
            }

            const out = await resp.json();
            if (!resp.ok) throw new Error(out?.error || 'save failed');
            console.log('‚úÖ saved gripper tip calibration', out);
            alert(`Saved gripper tip calibration${out.path ? ` to ${out.path}` : ''}.`);
          } catch (err) {
            console.error('‚ùå failed to save gripper tip calibration', err);
            alert('Saved locally. Server save failed (check console).');
          }
        }
      };
      tipFolderDev.add(tipActions, 'save_gripper_tips').name('Save gripper tips');

      // Initial apply so the matrices reflect slider defaults
      applyIntrinsicsFromParams(currentViewName);
      applyExtrinsicsFromParams(currentViewName);

    }

    function exitCalibration() {
      destroyCalibGUI();
      calibrationMode = false;
    }

    function showOnlySpecifiedLinks(robot, keepNames /* array of link names */) {
      const keep = new Set(keepNames);

      // 1) Hide every mesh under the robot (visual + collision)
      robot.traverse(o => {
        if (o.isMesh) o.visible = false;
      });

      // 2) Re‚Äëenable meshes that live under the allowed link groups
      keep.forEach(name => {
        const link = robot.getObjectByName(name);
        if (!link) {
          console.warn(`[showOnlySpecifiedLinks] link "${name}" not found`);
          return;
        }
        link.traverse(o => {
          if (o.isMesh) o.visible = true;
        });
      });

      // Important: DO NOT set .visible=false on any parent links in the chain.
      // We only hide their meshes so children (e.g., link_6 ‚Üí carriages ‚Üí grippers)
      // still receive correct transforms from the kinematics.
    }

    setIKFromUrdf(ikRoot, robot);
    ikRoot.updateMatrixWorld(true);

    /* --- locate the end-effector link inside IK tree --- */
    let ee = null;
    
    ikRoot.traverse(child => {                        // Frame.traverse
      if ( child.name === 'ee_gripper_link' ) { ee = child; return true; }
    });

    /* --- create a translation-only Goal --- */
    const goal = new Goal();
    goal.setDoF(DOF.X, DOF.Y, DOF.Z, DOF.EX, DOF.EY, DOF.EZ);

    goal.makeClosure( ee );                          // link goal ‚Üî ee

    /* ---- sample the **visual** EE pose after matrices are fresh */
    const startPos  = new THREE.Vector3();
    const startQuat = new THREE.Quaternion();

    robot.updateMatrixWorld( true );                 // propagate world mats
    const eeVis = robot.getObjectByName( 'ee_gripper_link' );
    eeVis.getWorldPosition   ( startPos  );
    eeVis.getWorldQuaternion ( startQuat );

    goal.setPosition   ( startPos.x, startPos.y, startPos.z );
    goal.setQuaternion ( startQuat.x, startQuat.y, startQuat.z, startQuat.w );

    /* ===== Animate button + loop state ===== */
    const animState = {
      enabled: false,
      t: 0,
      duration: 2000,     // ms start ‚Üí target
      lastTs: 0,
      phase: 'forward',   // 'forward' | 'hold'
      holdMs: 250,        // 0.25 s at goal
      holdElapsed: 0
    };

    // Reusable temporaries for interpolation (avoid per‚Äëframe allocations)
    const _interpPos  = new THREE.Vector3();
    const _interpQuat = new THREE.Quaternion();

    // Compute the *target* pose from current user params.
    // We purposely derive orientation from baseQuat + (roll,pitch,yaw)
    // instead of reusing currentQuat to avoid drift.
    function getTargetPose() {
      // Always return the latest interactive target (local-frame orientation)
      return { pos: targetPose.pos, quat: targetPose.quat };
    }

    // Toggle animation ON/OFF.
    function toggleAnimation() {
      animState.enabled = !animState.enabled;

      if (animState.enabled) {
        // Reset the arm to the initial joint configuration (the "initial positions" you have)
        // so the animation starts exactly from there.
        if (initialJointPositions) {
          for (const [name, val] of Object.entries(initialJointPositions)) {
            robot.setJointValue(name, val);
          }
          robot.updateMatrixWorld(true);
          // Resample the initial EE pose in case anything drifted
          eeVis.getWorldPosition(startPos);
          eeVis.getWorldQuaternion(startQuat);
        }

        // Start timeline
        animState.t = 0;
        animState.lastTs = performance.now();
        animateBtn.classList.add('active');
        animState.phase = 'forward';
        animState.holdElapsed = 0;

        // Snap goal to the initial pose (no first-frame lag)
        goal.setPosition(startPos.x, startPos.y, startPos.z);
        goal.setQuaternion(startQuat.x, startQuat.y, startQuat.z, startQuat.w);

        // Make sure robot is visible
        if (!robotVisible) {
          robotVisible = true;
          robot.visible = true;
          if (toggleRobotBtn) toggleRobotBtn.textContent = 'hide robot model';
        }
        // Hide pose gizmos while animating (rotation wheels + red dot)
        setPoseGizmosVisible(false);
      } else {
        animateBtn.classList.remove('active');
        // If stopped mid-way, snap directly to the current target
        const { pos, quat } = getTargetPose();
        goal.setPosition(pos.x, pos.y, pos.z);
        goal.setQuaternion(quat.x, quat.y, quat.z, quat.w);
        // Restore pose gizmos when animation is off
        setPoseGizmosVisible(true);
      }
    }


    /* ---------- semi-transparent alignment line -------------------- */
    const lineLen = 0.80;      // meters
    const lineRad = 0.002;     // thickness
    const lineOffX = - 0.01;
    // --- cache & helpers for fast updates (no per-frame allocs) ---
    const baseLineLen = lineLen; // baseline length for scaling helper lines
    const floorZ      = 0.0;      // ground plane (Z-up)
    const bottomPad   = 0.0005;   // tiny lift to avoid z-fighting
    const _eePosTmp   = new THREE.Vector3();

    /* ---------- two yellow drop lines from gripper finger tips ---------- */

    // If you want the lines to end at exactly z=0, keep this at 0.0.
    // If you see z-fighting flicker, bump it up slightly (e.g., 0.0005).
    const fingerBottomPad = 0.0;

    // Shared yellow material (semi‚Äëtransparent)
    const fingerLineMat = new THREE.MeshBasicMaterial({
      color: 0xffcc00, transparent: true, opacity: 0.95
    });

    // Helper to build a vertical cylinder whose local Y maps to world Z (like the green line)
    function makeDownLine(material){
      const m = new THREE.Mesh(
        new THREE.CylinderGeometry(lineRad, lineRad, lineLen, 8, 1, true),
        material
      );
      m.rotation.x = Math.PI / 2;   // align cylinder Y ‚Üí world Z
      m.visible = false;
      scene.add(m);
      return m;
    }

    const leftFingerLine  = makeDownLine(fingerLineMat);
    const rightFingerLine = makeDownLine(fingerLineMat);

    // Cache references to the finger links in the URDF
    // (Rename here if your URDF uses different link names)
    const leftFingerLink  = robot.getObjectByName('gripper_left');
    const rightFingerLink = robot.getObjectByName('gripper_right');


    /* ---- XY cross at the target pose (keeps the same drag proxy) --------- */
    // Transform anchor (acts like the old marker mesh, but is now a Group)
    const marker = new THREE.Group();
    marker.position.copy(startPos);
    marker.quaternion.copy(startQuat);
    scene.add(marker);

    // Visible cross (two thin bars along local X and Y)
    const CROSS_LEN   = 0.1;  // 10 cm total length; tweak if you want bigger/smaller
    const CROSS_THICK = 0.005; // 5 mm thickness
    const crossMat = new THREE.MeshBasicMaterial({
      color: 0xff0000,       // same red as before; change if you prefer
      transparent: true,
      opacity: 0.85,
      depthTest: false,      // always draw on top of the camera texture
      depthWrite: false
    });

    // X bar: length along local X, thin in Y/Z
    const xBar = new THREE.Mesh(new THREE.BoxGeometry(CROSS_THICK, CROSS_THICK, CROSS_LEN), crossMat);
    // Y bar: length along local Y, thin in X/Z
    const yBar = new THREE.Mesh(new THREE.BoxGeometry(CROSS_THICK, CROSS_LEN, CROSS_THICK), crossMat);

    // Make the cross purely visual (do not participate in picking)
    // This ensures the existing proxy remains the only drag target.
    xBar.raycast = () => {};
    yBar.raycast = () => {};

    const crossGroup = new THREE.Group();
    crossGroup.name = 'marker_cross';
    crossGroup.add(xBar, yBar);
    marker.add(crossGroup);

    // Keep the exact same drag proxy (unchanged)
    const pickProxy = new THREE.Mesh(
      new THREE.SphereGeometry(0.04, 16, 16), // ~4 cm radius hit area
      new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0, depthWrite: false })
    );
    pickProxy.name = 'marker_pick_proxy';
    marker.add(pickProxy);

    // ===== Rotation wheels (roll/pitch/yaw) - helpers & state =====
    const rotationWheels = {};        // { roll:{group, segments:Mesh[]}, pitch:{...}, yaw:{...} }
    let rotationPickables = [];       // flat list of all wheel segment meshes for raycasting

    // Visual states for wheels
    const WHEEL_OPACITY = {
      idle:   { even: 0.44, odd: 0.24 },
      hover:  { even: 0.64, odd: 0.44 },
      active: { even: 0.84, odd: 0.64 },
    };

    // Build one wheel (striped annulus) for an axis
    function makeWheel(axisName, colorHex, innerR=0.085, outerR=0.105, strips=48) {
      const group = new THREE.Group();
      group.name = `wheel_${axisName}`;
      group.userData.axis = axisName;
      group.renderOrder = 999; // draw above everything
      const segments = [];

      const segAngle = (Math.PI * 2) / strips;
      const gap = segAngle * 0.08;               // subtle gaps between strips
      const thetaLen = segAngle - gap;

      for (let i = 0; i < strips; i++) {
        const thetaStart = i * segAngle + gap * 0.5;
        const geom = new THREE.RingGeometry(innerR, outerR, 18, 1, thetaStart, thetaLen);
        const mat = new THREE.MeshBasicMaterial({
          color: colorHex,
          transparent: true,
          opacity: (i % 2 === 0 ? WHEEL_OPACITY.idle.even : WHEEL_OPACITY.idle.odd),
          side: THREE.DoubleSide,
          depthTest: false,   // always visible
        });
        const seg = new THREE.Mesh(geom, mat);
        seg.userData.axis = axisName; // so picking any segment knows its axis
        group.add(seg);
        segments.push(seg);
      }

      return { group, segments };
    }

    function setWheelState(axis, state /* idle|hover|active */) {
      const w = rotationWheels[axis]; if (!w) return;
      const cfg = WHEEL_OPACITY[state] || WHEEL_OPACITY.idle;
      w.segments.forEach((seg, i) => {
        seg.material.opacity = (i % 2 === 0 ? cfg.even : cfg.odd);
        seg.material.needsUpdate = true;
      });
    }
    function resetAllWheelStates() {
      ['roll','pitch','yaw'].forEach(a => setWheelState(a, 'idle'));
    }

    // Build and mount all wheels that are enabled by activeControls
    function buildRotationWheels() {
      rotationPickables.length = 0;
      // pleasant, readable axis colors
      const colorFor = { roll: 0xff5b5b, pitch: 0x22cc88, yaw: 0x4f8cff };

      ['roll','pitch','yaw'].forEach(axis => {
        if (!activeControls.includes(axis)) return;
        const { group, segments } = makeWheel(axis, colorFor[axis]);
        scene.add(group);
        rotationWheels[axis] = { group, segments };
        rotationPickables.push(...segments);
      });

      resetAllWheelStates();
    }

    // World-space local axes from the marker‚Äôs orientation
    function localAxesWorld() {
      const q = marker.quaternion;
      return {
        xW: new THREE.Vector3(1,0,0).applyQuaternion(q).normalize(),
        yW: new THREE.Vector3(0,1,0).applyQuaternion(q).normalize(),
        zW: new THREE.Vector3(0,0,1).applyQuaternion(q).normalize(),
      };
    }

    // For a given axis name, return plane normal n and in-plane orthonormal basis u,v
    function planeBasisForAxis(axis) {
      const { xW, yW, zW } = localAxesWorld();
      if (axis === 'roll')   return { n: xW, u: yW, v: zW }; // rotate about local X ‚Üí YZ plane
      if (axis === 'pitch')  return { n: yW, u: zW, v: xW }; // rotate about local Y ‚Üí XZ plane
      /* yaw */              return { n: zW, u: xW, v: yW }; // rotate about local Z ‚Üí XY plane
    }
    function alignRingToNormal(group, n) {
      const from = new THREE.Vector3(0,0,1); // RingGeometry faces +Z by default
      const q = new THREE.Quaternion().setFromUnitVectors(from, n);
      group.quaternion.copy(q);
      group.updateMatrixWorld(true);
    }

    function angleOnPlaneFromPoint(p, center, u, v) {
      const r = p.clone().sub(center);
      return Math.atan2(r.dot(v), r.dot(u));
    }
    function normalizeAngle(a) {
      while (a >  Math.PI) a -= Math.PI * 2;
      while (a < -Math.PI) a += Math.PI * 2;
      return a;
    }

    // Build wheels now that the marker exists
    buildRotationWheels();
    // ===== Rotation wheels - helpers & state (end) =====

    // --- helper to show/hide pose gizmos (red dot + rotation wheels) ---
    function setPoseGizmosVisible(visible) {
      if (marker) marker.visible = visible;
      Object.values(rotationWheels).forEach(w => {
        if (w && w.group) w.group.visible = visible;
      });
    }


    /* 2) build lil-GUI sliders ----------------------------------- */
    // ---- absolute hard limits (same for all users) ----
    const ABS_LIMITS = {
      x:     { min: 0.10,  max: 0.43  },
      y:     { min: -0.15, max: 0.15  },
      z:     { min: 0.005, max: 0.30  },
      roll:  { min: -1.00, max: 1.00  },
      pitch: { min: -0.60, max: 0.75  },
      yaw:   { min: -0.81, max: 0.81  },
    };

    const startEuler = new THREE.Euler().setFromQuaternion(startQuat, 'XYZ');
    // --- interactive target pose (driven by sliders/marker) ---
    const targetPose = {
      pos: startPos.clone(),
      quat: startQuat.clone()
    };
    const params = {
      x: startPos.x, y: startPos.y, z: startPos.z,
      // roll:  startEuler.x,
      // pitch: startEuler.y,
      // yaw:   startEuler.z
      roll:  0.0,
      pitch: 0.0,
      yaw:   0.0
    };

    // Keep last angles so we can apply *incremental* local rotations
    const prevAngles = {
      roll:  params.roll,
      pitch: params.pitch,
      yaw:   params.yaw
    };

    // Record the starting values once; used to detect "pose unchanged"
    const initialParams = {
      x: params.x, y: params.y, z: params.z,
      roll: params.roll, pitch: params.pitch, yaw: params.yaw
    };

    const lastGoodParams = { ...params };
    function recordLastGood(keys = poseAxes) {
      keys.forEach(k => { lastGoodParams[k] = params[k]; });
    }

    // Only check the controls that are present
    const poseAxes = ['x','y','z','roll','pitch','yaw'].filter(k => activeControls.includes(k));
    const EPS = 1e-6; // tolerance for float comparisons
    function approximatelyEqual(a,b,eps=EPS){ return Math.abs(a - b) <= eps; }
    function getChangedAxes(){ return poseAxes.filter(k => !approximatelyEqual(params[k], initialParams[k])); }
    function slidersAtDefault(){ return getChangedAxes().length === 0; }

    function updateGoal() {
      // 1) Absolute position from sliders/drag
      targetPose.pos.set(params.x, params.y, params.z);

      // 2) Orientation: compose *incremental* rotation in the gripper's local frame
      const dRoll  = params.roll  - prevAngles.roll;
      const dPitch = params.pitch - prevAngles.pitch;
      const dYaw   = params.yaw   - prevAngles.yaw;

      if (Math.abs(dRoll) > EPS || Math.abs(dPitch) > EPS || Math.abs(dYaw) > EPS) {
        const dQ = new THREE.Quaternion().setFromEuler(
          new THREE.Euler(dRoll, dPitch, dYaw, 'XYZ')
        );
        // local-frame: post-multiply onto the current target orientation
        targetPose.quat.multiply(dQ).normalize();

        prevAngles.roll  = params.roll;
        prevAngles.pitch = params.pitch;
        prevAngles.yaw   = params.yaw;
      }

      // 3) Marker always shows the desired target immediately
      marker.position.copy(targetPose.pos);
      marker.quaternion.copy(targetPose.quat);

      // 4) Push to IK only when NOT animating
      if (!animState.enabled) {
        goal.setPosition(targetPose.pos.x, targetPose.pos.y, targetPose.pos.z);
        goal.setQuaternion(
          targetPose.quat.x, targetPose.quat.y, targetPose.quat.z, targetPose.quat.w
        );
      }

      // Existing reveal/locking UI
      if (!robotVisible) {
        robotVisible = true;
        robot.visible = true;
        if (toggleRobotBtn) toggleRobotBtn.textContent = 'hide robot model';
      }
      if (!slidersLocked) recordLastGood();
      updateGripperInteractivity();
    }



    // ---------- Drag helpers ----------
    const raycaster = new THREE.Raycaster();
    const ndc = new THREE.Vector2();

    const DRAG_SPECS = {
      front:       { axes: ['y','z'], normal: new THREE.Vector3(1,0,0) }, // lock X ‚Üí move on YZ
      left:        { axes: ['x','z'], normal: new THREE.Vector3(0,1,0) }, // lock Y ‚Üí move on XZ
      right:       { axes: ['x','z'], normal: new THREE.Vector3(0,1,0) }, // lock Y ‚Üí move on XZ
      perspective: { axes: ['x','y'], normal: new THREE.Vector3(0,0,1) }, // lock Z ‚Üí move on XY
    };

    function specForView(name){
      return DRAG_SPECS[name] || DRAG_SPECS.perspective;
    }

    function setNDCFromPointerEvent(evt, renderer){
      const rect = renderer.domElement.getBoundingClientRect();
      ndc.x =  ( (evt.clientX - rect.left) / rect.width ) * 2 - 1;
      ndc.y = -( (evt.clientY - rect.top)  / rect.height) * 2 + 1;
    }

    function clampToSlider(axis, v){
      // Clamp to the effective slider range (span‚à©ABS_LIMITS) and also
      // to the absolute limits for extra safety.
      const r = sliderRanges[axis] || {};
      const abs = ABS_LIMITS[axis];
      let min = r.min ?? -Infinity;
      let max = r.max ?? +Infinity;
      if (abs) {
        min = Math.max(min, abs.min);
        max = Math.min(max, abs.max);
      }
      return Math.min(max, Math.max(min, v));
    }

    function updateSlidersDisplay(axes){
      axes.forEach(a => {
        sliderCtrls[a]?.updateDisplay();
        updateSliderDecor(a);
      });
     }

    // --- UI decoration: center tick + invalid shading + center detent glow ---
    function clamp01(x){ return Math.max(0, Math.min(1, x)); }
    function updateSliderDecor(axis){
      const ctrl = sliderCtrls[axis]; if (!ctrl) return;
      const input = ctrl.domElement.querySelector('input[type="range"]'); if (!input) return;
      const abs = ABS_LIMITS[axis]; if (!abs) return;
      const {min, max} = sliderRanges[axis];        // full centered track (center ¬± span)
      const center = sliderCenters[axis];
      const span = (max - min);
      if (span <= 0) return;

      // Positions along the track (0..100%)
      const pct = v => 100 * clamp01((v - min) / span);
      const absMinPct = pct(abs.min);
      const absMaxPct = pct(abs.max);
      const centerPct = 50; // by construction (center ¬± span)

      // Layered gradients: left OOB, right OOB, center tick, base
      const leftOOB  = absMinPct > 0
        ? `linear-gradient(to right, rgba(239,68,68,.26) 0%, rgba(239,68,68,.26) ${absMinPct}%, transparent ${absMinPct}%, transparent 100%)`
        : '';
      const rightOOB = absMaxPct < 100
        ? `linear-gradient(to right, transparent 0%, transparent ${absMaxPct}%, rgba(239,68,68,.26) ${absMaxPct}%, rgba(239,68,68,.26) 100%)`
        : '';
      const centerTick = `linear-gradient(to right,
        transparent calc(${centerPct}% - 1px),
        #3b82f6    calc(${centerPct}% - 1px),
        #3b82f6    calc(${centerPct}% + 1px),
        transparent calc(${centerPct}% + 1px)
      )`;
      const base = 'linear-gradient(to right, #d1d5db, #d1d5db)';
      input.style.background = [leftOOB, rightOOB, centerTick, base].filter(Boolean).join(',');

      // Snap-to-center detent (~2% of span) + visual glow
      const detent = 0.02 * span;
      const atCenter = Math.abs(params[axis] - center) <= detent;
      input.classList.toggle('at-center', atCenter);
    }

    // Single shared drag state
    // Single shared drag state (translation or rotation)
    const dragState = {
      active: false,
      mode: null,                // 'translate' | 'rotate'
      view: null,
      plane: new THREE.Plane(),  // used both for translate & rotate
      axes: /** @type {('x'|'y'|'z')[]} */([]), // translation axes (two on a plane)
      axis: /** @type {'roll'|'pitch'|'yaw'|null} */(null), // rotation axis
      pointerId: null,

      // rotation-specific
      u: new THREE.Vector3(),
      v: new THREE.Vector3(),
      angle0: 0,
      param0: 0,
    };


    function attachDragHandlersToView(view){
      const el = view.renderer.domElement;

      function pickAll(evt) {
        setNDCFromPointerEvent(evt, view.renderer);
        raycaster.setFromCamera(ndc, view.camera);
        // Highest priority: wheel segments, then the dot proxy, then the dot itself
        const targets = [
          ...rotationPickables,
          marker.getObjectByName('marker_pick_proxy'),
          marker
        ].filter(Boolean);
        return raycaster.intersectObjects(targets, true);
      }

      // Hover: cursor + wheel highlight
      el.addEventListener('pointermove', (evt) => {
        if (slidersLocked) {                // ‚Üê block hover affordances while locked
          el.style.cursor = 'not-allowed';
          return;
        }
        if (dragState.active || calibrationMode) return;

        const hits = pickAll(evt);
        const wheelHit = hits.find(h => h.object?.userData?.axis);
        const dotHit   = hits.find(h => (h.object === marker) || (h.object?.name === 'marker_pick_proxy'));

        // Visual: highlight hovered wheel (others idle)
        resetAllWheelStates();
        if (wheelHit) {
          setWheelState(wheelHit.object.userData.axis, 'hover');
          el.style.cursor = 'grab';
        } else if (dotHit) {
          el.style.cursor = 'grab';
        } else {
          el.style.cursor = 'default';
        }
      });

      el.addEventListener('pointerdown', (evt) => {
        if (slidersLocked) {                // ‚Üê block starting a drag while locked
          el.style.cursor = 'not-allowed';
          return;
        }
        if (calibrationMode) return;

        const hits = pickAll(evt);
        if (!hits.length) return;

        // Decide mode by topmost hit
        const top = hits[0];
        const hitAxis = top.object?.userData?.axis || null;

        dragState.active    = true;
        dragState.view      = view;
        dragState.pointerId = evt.pointerId;
        el.setPointerCapture(dragState.pointerId);
        el.style.cursor = 'grabbing';

        currentViewName = view.name; // keep other UI in sync
        updateGripArrowVisibility();

        if (hitAxis) {
          // === ROTATION DRAG ===
          dragState.mode = 'rotate';
          dragState.axis = /** @type {'roll'|'pitch'|'yaw'} */(hitAxis);

          const { n, u, v } = planeBasisForAxis(dragState.axis);
          dragState.u.copy(u); dragState.v.copy(v);
          dragState.plane.setFromNormalAndCoplanarPoint(n, marker.position);

          const hitPt = new THREE.Vector3();
          raycaster.ray.intersectPlane(dragState.plane, hitPt);
          dragState.angle0 = angleOnPlaneFromPoint(hitPt, marker.position, dragState.u, dragState.v);
          dragState.param0 = params[dragState.axis];

          resetAllWheelStates();
          setWheelState(dragState.axis, 'active');
        } else {
          // === TRANSLATION DRAG === (dot)
          dragState.mode = 'translate';

          const spec = specForView(view.name);       // which axes to move in this view
          dragState.axes = spec.axes;
          dragState.plane.setFromNormalAndCoplanarPoint(spec.normal, marker.position);
        }

        evt.preventDefault();
      });

      el.addEventListener('pointermove', (evt) => {
        if (!dragState.active || dragState.view !== view) return;

        setNDCFromPointerEvent(evt, view.renderer);
        raycaster.setFromCamera(ndc, view.camera);

        const hitPoint = new THREE.Vector3();
        if (!raycaster.ray.intersectPlane(dragState.plane, hitPoint)) return;

        if (dragState.mode === 'translate') {
          // Move the two allowed axes directly
          dragState.axes.forEach(axis => {
            const v = axis === 'x' ? hitPoint.x : axis === 'y' ? hitPoint.y : hitPoint.z;
            params[axis] = clampToSlider(axis, v);   // invisible ABS barrier
          });
          updateGoal();
          updateSlidersDisplay(dragState.axes);
        } else if (dragState.mode === 'rotate' && dragState.axis) {
          // Angle delta on plane
          const ang1 = angleOnPlaneFromPoint(hitPoint, marker.position, dragState.u, dragState.v);
          const dAng = normalizeAngle(ang1 - dragState.angle0);
          let newVal = dragState.param0 + dAng;
          newVal = clampToSlider(dragState.axis, newVal);

          params[dragState.axis] = newVal;
          updateGoal();
          sliderCtrls[dragState.axis]?.updateDisplay();
        }
        
        updateTaskCompletedAvailability();
        evt.preventDefault();
      });

      function endDrag(){
        if (!dragState.active) return;
        try { el.releasePointerCapture(dragState.pointerId); } catch(_) {}
        dragState.active = false;
        const endedAxis = dragState.axis;
        dragState.mode  = null;
        dragState.axis  = null;
        dragState.view  = null;
        dragState.axes  = [];
        el.style.cursor = 'default';

        // After drag, leave hover highlight if still under cursor
        const fakeEvt = { clientX: window._lastMouseX ?? 0, clientY: window._lastMouseY ?? 0 };
        // best-effort hover restore
        resetAllWheelStates();
        if (endedAxis) setWheelState(endedAxis, 'hover');
      }

      // Track mouse position globally to re-evaluate hover after drag end
      el.addEventListener('pointermove', (e)=> { window._lastMouseX = e.clientX; window._lastMouseY = e.clientY; });

      el.addEventListener('pointerup',       endDrag);
      el.addEventListener('pointercancel',   endDrag);
      el.addEventListener('pointerleave',    (e)=>{ if (dragState.active) endDrag(); });
    }



    /* ---------- camera-view buttons --------------------------- */
    function poseToMatrix(mat){
      return new THREE.Matrix4().set(
        mat[0][0], mat[0][1], mat[0][2], mat[0][3],
        mat[1][0], mat[1][1], mat[1][2], mat[1][3],
        mat[2][0], mat[2][1], mat[2][2], mat[2][3],
        mat[3][0], mat[3][1], mat[3][2], mat[3][3],
      );
    }

    function selectView(viewName) {
      // Remove selection from all views
      views.forEach(view => {
        view.container.classList.remove('selected');
      });
      
      // Select the new view
      const view = views.get(viewName);
      if (view) {
        // Only show visual selection highlighting in devMode
        if (devMode) {
          view.container.classList.add('selected');
        }
        currentViewName = viewName;
        
        // Update gripper arrow visibility based on selected view
        updateGripArrowVisibility();
        
        if (calibrationMode) {
          destroyCalibGUI();
          enterCalibration();
        }
      }
    }

    function initializeViews() {
      // Clear existing views
      views.clear();
      viewsGrid.innerHTML = '';
      
      // Get available camera poses and textures
      const availableViews = [];
      Object.keys(camPoses).forEach(poseKey => {
        const viewName = poseKey.replace('_pose', '');
        if (viewTextures[viewName] && cameraModels[viewName]) {
          availableViews.push({
            name: viewName,
            poseKey: poseKey,
            texture: viewTextures[viewName],
            model: cameraModels[viewName],
            pose: camPoses[poseKey]
          });
        }
      });
      
      console.log(`[DEBUG] availableViews:`, availableViews.map(v => v.name));
      
      if (availableViews.length === 0) return;
      
      // Setup grid layout
      setupViewportGrid(availableViews.length);
      
      // Create views
      availableViews.forEach((viewInfo, index) => {
        const view = createViewRenderer(viewInfo.name, viewInfo.model, viewInfo.texture);
        attachDragHandlersToView(view);
        
        // Set up camera pose and projection
        updateViewCamera(view, viewInfo.pose);
        applyProjectionFromK(view);
        
        // For 3 views, hide the 4th grid position
        if (availableViews.length === 3 && index === 2) {
          view.container.style.gridColumn = '1 / -1';
          view.container.style.justifySelf = 'center';
        }
      });
      
      // Update sizes and select first view
      updateViewSizes();
      if (availableViews.length > 0) {
        // In devMode, select the first view for visual feedback
        // In regular mode, just set currentViewName without visual selection
        if (devMode) {
          selectView(availableViews[0].name);
        } else {
          currentViewName = availableViews[0].name;
          console.log(`[DEBUG] Initial currentViewName set to: "${currentViewName}"`);
          updateGripArrowVisibility(); // Update arrow visibility for initial view
        }
      }
    }

    const btnBar   = document.createElement('div');
    btnBar.style.position = 'fixed';
    btnBar.style.top = '8px';
    btnBar.style.left = '8px';
    btnBar.style.zIndex = 10;
    btnBar.style.display = 'flex';
    btnBar.style.gap = '4px';
    document.body.appendChild( btnBar );

    /* add camera selection buttons (only if devMode enabled) */
    if (devMode) {
      Object.keys(camPoses).forEach(poseKey=>{
        const viewName = poseKey.replace('_pose', '');
        const b       = document.createElement('button');
        b.textContent = viewName; // "left", "right", ‚Ä¶
        b.onclick     = ()=> selectView(viewName);
        btnBar.appendChild( b );
      });
    }

    /* add calibrate toggle button (only if devMode enabled) */
    if (devMode) {
      const calibrateBtn = document.createElement('button');
      calibrateBtn.textContent = 'calibrate';
      calibrateBtn.onclick = () => {
        if (!calibrationMode) {
          if (!currentViewName) { alert('Pick a camera view first (front/left/right/...).'); return; }
          enterCalibration();
          calibrateBtn.textContent = 'exit calibration';
        } else {
          exitCalibration();
          calibrateBtn.textContent = 'calibrate';
        }
      };
      btnBar.appendChild(calibrateBtn);
    }

    /* add hide/show robot model button (bottom-left corner) (only if devMode enabled) */
    if (devMode) {
      toggleRobotBtn = document.createElement('button');
      toggleRobotBtn.textContent = 'show robot model';
      toggleRobotBtn.style.position = 'fixed';
      toggleRobotBtn.style.left     = '8px';
      toggleRobotBtn.style.bottom   = '8px';
      toggleRobotBtn.style.zIndex   = 10;
      document.body.appendChild(toggleRobotBtn);

      toggleRobotBtn.onclick = () => {
        robotVisible = !robotVisible;
        robot.visible = robotVisible;
        toggleRobotBtn.textContent = robotVisible
          ? 'hide robot model'
          : 'show robot model';
      };

      toggleRobotBtn.textContent = 'show robot model';
    }

    let taskCompletedSelected = false;

    /* ---------- confirm button (lower-right corner) ------------------- */

    // Initialize the multi-view system
    initializeViews();

  /* ---------- confirm button (inside controls container) ------------------- */

    // Create confirm button to be added to controls container
    const confirmBtn = document.createElement('button');
    confirmBtn.textContent = 'Confirm';
    confirmBtn.className = 'confirm-button';

    confirmBtn.onclick = async () => {
      // 0) Freeze any ongoing animation (unchanged)
      if (animState.enabled) {
        animState.enabled = false;
        if (animateBtn) animateBtn.classList.remove('active');
        setPoseGizmosVisible(true);
      }

      // NEW: If "Task Already Completed" is selected, POST that and exit early.
      if (taskCompletedSelected) {
        try {
          const response = await apiFetch(`/api/task-already-completed`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              state_id: state.state_id,
              episode_id: state.episode_id,
              task_already_completed: true
            })
          });

          if (response.ok) {
            console.log('‚úÖ Task already completed response sent');
            delayedRefresh(5000);
          } else {
            const errorData = await response.json().catch(() => ({}));
            console.error('‚ùå Failed to send task already completed response:', errorData);
            alert('Failed to submit response. Please try again.');
          }
        } catch (err) {
          console.error('‚ùå Failed to send task already completed response', err);
          alert('Failed to submit response. Please try again.');
        }
        return; // IMPORTANT: do NOT run the normal submit-goal flow.
      }

      // ===== Normal submit-goal flow (unchanged below) =====

      // 1) Use the intended goal pose
      const { pos: tgtPos, quat: tgtQuat } = getTargetPose();

      // 2) Snap the IK goal to that target and explicitly solve to it now
      goal.setPosition(tgtPos.x, tgtPos.y, tgtPos.z);
      goal.setQuaternion(tgtQuat.x, tgtQuat.y, tgtQuat.z, tgtQuat.w);

      setIKFromUrdf(ikRoot, robot);
      for (let i = 0; i < 25; i++) solver.solve();
      setUrdfFromIK(robot, ikRoot);

      // 3) Read joints
      const jointMap = {};
      Object.entries(robot.joints).forEach(([name, joint]) => {
        jointMap[name] = joint.jointValue;
      });

      // 4) Build ee_pose
      const eeEuler = new THREE.Euler().setFromQuaternion(tgtQuat, "XYZ");

      const poseResetToDefault = slidersAtDefault();
      const slidersChangedAxes = getChangedAxes();

      try {
        const response = await apiFetch(`/api/submit-goal`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            joint_positions: jointMap,
            gripper: gripDir,
            ee_pose: {
              position: [tgtPos.x, tgtPos.y, tgtPos.z],
              rpy: [eeEuler.x, eeEuler.y, eeEuler.z]
            },
            state_id: state.state_id,
            episode_id: state.episode_id,
            pose_reset_to_default: poseResetToDefault,
            sliders_changed_axes: slidersChangedAxes
          })
        });

        if (response.ok) {
          console.log('‚úÖ goal sent (final goal joints)');
          delayedRefresh(5000);
        } else {
          console.error('‚ùå failed to send goal - server error:', response.status);
        }
      } catch (err) {
        console.error('‚ùå failed to send goal', err);
      }
    };



    // Animate toggle button (appears above Confirm)
    const animateBtn = document.createElement('button');
    animateBtn.textContent = 'Animate';
    animateBtn.className = 'animate-button';
    animateBtn.onclick = toggleAnimation;

    const spanDefs = [
      ['x',     0.20],   // meters
      ['y',     0.20],
      ['z',     0.20],
      ['roll',  1.0],   // radians
      ['pitch', 0.81],
      ['yaw',   0.81],
    ];

    // Keep references so dragging can clamp to slider ranges & update displays
    const sliderCtrls   = {};  // axis -> lil-gui controller
    const sliderCenters = {};  // axis -> center value
    const sliderRanges  = {};  // axis -> {min, max}

    spanDefs.forEach(([key, span])=>{
      if (!activeControls.includes(key)) return;
      const center = params[key];                // original pose
      const min = center - span;
      const max = center + span;
      const controller = gui.add(params, key, min, max); // keep track centered visually
      controller.onChange(() => {
        if (slidersLocked) {
          // Revert the bound value and refresh the UI; do not push to IK
          params[key] = lastGoodParams[key];
          controller.updateDisplay();
          return;
        }
        // Invisible barrier: clamp to ABS within the (center¬±span) track
        // Also apply a small snap detent to the exact center.
        const { min: smin, max: smax } = sliderRanges[key];
        const abs = ABS_LIMITS[key];
        const spanNow = smax - smin;
        const detent = 0.02 * spanNow;
        if (Math.abs(params[key] - sliderCenters[key]) <= detent) {
          params[key] = sliderCenters[key];
        } else {
          params[key] = clampToSlider(key, params[key]); // (track ‚à© ABS)
        }
        updateGoal();
        updateTaskCompletedAvailability();
        updateSliderDecor(key);
      });

      // Save references for drag interaction
      sliderCtrls[key]   = controller;
      sliderCenters[key] = center;
      sliderRanges[key]  = { min, max };  // full centered track (not pre‚Äëclamped to ABS)

      // Add reset button to each slider
      setTimeout(() => {
        const controllerEl = controller.domElement;
        if (controllerEl) {
          const resetBtn = document.createElement('button');
          resetBtn.textContent = '‚ü≤';
          resetBtn.className = 'reset-btn';
          resetBtn.title = `Reset ${key} to default`;
          resetBtn.onclick = (e) => {
            e.preventDefault();
            e.stopPropagation();
            // Reset EXACTLY to the original center, even if out-of-bounds.
            // Slider track stays clamped; first user interaction will snap back into the valid range.
            params[key] = sliderCenters[key];
            controller.updateDisplay();
            updateGoal();
            updateTaskCompletedAvailability();
            updateSliderDecor(key);
          };
          controllerEl.appendChild(resetBtn);
        }
        // Initial decoration
        updateSliderDecor(key);
      }, 0);
    });

    setSlidersLocked(false);
    // Ensure marker/goal reflect params (and any implicit clamping from controller init)
    updateGoal();

    // Add gripper buttons after sliders
    if (gripperButtonsContainer) {
      controlsContainer.appendChild(gripperButtonsContainer);
      updateGripperButtonStates(); // Set initial button states
    }

    // Evaluate initial interactivity (usually enabled because sliders = defaults)
    updateGripperInteractivity();

    controlsContainer.appendChild(animateBtn);

    // Add confirm button at the bottom
    controlsContainer.appendChild(confirmBtn);

    // Create "Task Already Completed" button in a separate container
    const taskCompletedContainer = document.createElement('div');
    taskCompletedContainer.className = 'task-completed-container';

    // Add title/label above the button
    const taskCompletedTitle = document.createElement('div');
    taskCompletedTitle.textContent = 'In fact, no need to move because...';
    taskCompletedTitle.style.fontSize = '14px';
    taskCompletedTitle.style.fontWeight = '500';
    taskCompletedTitle.style.color = '#374151';
    taskCompletedTitle.style.marginBottom = '8px';
    taskCompletedTitle.style.textAlign = 'left';
    taskCompletedTitle.style.fontFamily = 'system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans"';

    const taskCompletedBtn = document.createElement('button');
    taskCompletedBtn.textContent = 'Task Already Completed';
    taskCompletedBtn.className = 'task-completed-button';
    taskCompletedBtn.setAttribute('aria-pressed', 'false');
    taskCompletedBtn.title = "Task not selected. Press to select, then press Confirm.";
    
    taskCompletedBtn.classList.add('inactive');

    // Toggle-only behavior (no network request)
    taskCompletedBtn.onclick = () => {
      if (taskCompletedBlocked) return; // safety (disabled also prevents clicks)

      taskCompletedSelected = !taskCompletedSelected;
      taskCompletedBtn.classList.toggle('active', taskCompletedSelected);
      taskCompletedBtn.classList.toggle('inactive', !taskCompletedSelected);   // NEW
      taskCompletedBtn.setAttribute('aria-pressed', String(taskCompletedSelected));
      
      // When selected: block sliders + gripper; when deselected: re-evaluate
      recomputeLocks();

      // Keep the title consistent with current state
      setTaskCompletedBlocked(taskCompletedBlocked);

    };

    // Keep the placement between Animate and Confirm
    controlsContainer.insertBefore(taskCompletedBtn, confirmBtn);

    updateTaskCompletedAvailability();

    // Update layout based on number of active controls
    function updateControlsLayout() {
      const numSliders = activeControls.filter(ctrl => ['x', 'y', 'z', 'roll', 'pitch', 'yaw'].includes(ctrl)).length;
      const hasGripper = activeControls.includes('gripper');
      const totalControls = numSliders + (hasGripper ? 1 : 0) + 1; // +1 for confirm button

      if (totalControls > 1) {
        controlsContainer.style.display = 'block';
        controlsWrapper.style.display = 'flex';
        mount.className = (totalControls === 2 && numSliders === 1) ? 'single-slider' : 'multiple-sliders';
      } else {
        controlsContainer.style.display = 'none';
        controlsWrapper.style.display = 'none';
        mount.className = '';
      }
    }

    updateControlsLayout();


    /* --- solver --- */
    const solver = new Solver(ikRoot);                // constructor takes root
    // (solver settings default to 5 iterations, etc.)

    /* --- animation loop --- */
    function animate(now) {
      requestAnimationFrame(animate);

      // If Animate is ON: forward (start‚Üítarget) ‚Üí hold at target ‚Üí restart.
      if (animState.enabled) {
        if (!animState.lastTs) animState.lastTs = now;
        const dt = Math.min(100, now - animState.lastTs); // clamp spikes
        animState.lastTs = now;

        // Always sample the *current* target from sliders/drags
        const { pos: tgtPos, quat: tgtQuat } = getTargetPose();

        if (animState.phase === 'forward') {
          animState.t += (dt / animState.duration);
          if (animState.t >= 1) {
            animState.t = 1;
            animState.phase = 'hold';
            animState.holdElapsed = 0;
          }
          _interpPos.copy(startPos).lerp(tgtPos, animState.t);
          _interpQuat.copy(startQuat).slerp(tgtQuat, animState.t);
          goal.setPosition  (_interpPos.x,  _interpPos.y,  _interpPos.z);
          goal.setQuaternion(_interpQuat.x, _interpQuat.y, _interpQuat.z, _interpQuat.w);
        } else { // 'hold'
          animState.holdElapsed += dt;
          // Stay exactly at the (live) goal during the hold window
          goal.setPosition  (tgtPos.x,  tgtPos.y,  tgtPos.z);
          goal.setQuaternion(tgtQuat.x, tgtQuat.y, tgtQuat.z, tgtQuat.w);
          if (animState.holdElapsed >= animState.holdMs) {
            // Teleport robot back to the *initial joint configuration*
            if (initialJointPositions) {
              for (const [name, val] of Object.entries(initialJointPositions)) {
                robot.setJointValue(name, val);
              }
              robot.updateMatrixWorld(true);
            }

            // Reset the IK goal to the original EE pose (start)
            goal.setPosition(startPos.x, startPos.y, startPos.z);
            goal.setQuaternion(startQuat.x, startQuat.y, startQuat.z, startQuat.w);

            // Begin a fresh forward pass
            animState.phase = 'forward';
            animState.t = 0;
            animState.holdElapsed = 0;
          }

        }
      }

      // Solve IK for this frame
      setIKFromUrdf(ikRoot, robot);
      solver.solve();
      setUrdfFromIK(robot, ikRoot);

      // ----- yellow drop lines from finger tips -----
      function updateFingerLine(link, lineMesh, localTipVec) {
        if (!link) { lineMesh.visible = false; return; }
        link.updateMatrixWorld(true);
        const tipWorld = localTipVec.clone().applyMatrix4(link.matrixWorld);
        const lenToFloor = tipWorld.z - (floorZ + fingerBottomPad);
        if (lenToFloor <= 0) { lineMesh.visible = false; return; }
        lineMesh.visible = true;
        lineMesh.scale.y = lenToFloor / baseLineLen;
        const midZ = (floorZ + fingerBottomPad) + 0.5 * lenToFloor;
        lineMesh.position.set(tipWorld.x, tipWorld.y, midZ);
      }
      updateFingerLine(leftFingerLink,  leftFingerLine,  fingerTipLocalLeft);
      updateFingerLine(rightFingerLink, rightFingerLine, fingerTipLocalRight);

      // ----- gripper arrows track the two finger links -----
      gripArrows.forEach(arrow => {
        const link = arrow.userData.targetLink;
        const originLocal = arrow.userData.originLocal;
        const dirLocal = arrow.userData.dirLocal;
        if (!link) return;
        link.updateMatrixWorld(true);
        const worldPos = originLocal.clone().applyMatrix4(link.matrixWorld);
        arrow.position.copy(worldPos);
        const worldDir = dirLocal.clone().transformDirection(link.matrixWorld);
        arrow.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), worldDir);
      });
      updateGripArrowVisibility();

      // ----- rotation wheels follow marker orientation -----
      (function updateWheels(){
        const pos = marker.position;
        const q = marker.quaternion;
        const xW = new THREE.Vector3(1,0,0).applyQuaternion(q).normalize();
        const yW = new THREE.Vector3(0,1,0).applyQuaternion(q).normalize();
        const zW = new THREE.Vector3(0,0,1).applyQuaternion(q).normalize();
        if (rotationWheels.roll) {
          rotationWheels.roll.group.position.copy(pos);
          alignRingToNormal(rotationWheels.roll.group, xW);
        }
        if (rotationWheels.pitch) {
          rotationWheels.pitch.group.position.copy(pos);
          alignRingToNormal(rotationWheels.pitch.group, yW);
        }
        if (rotationWheels.yaw) {
          rotationWheels.yaw.group.position.copy(pos);
          alignRingToNormal(rotationWheels.yaw.group, zW);
        }
      })();

      // ----- render all views -----
      views.forEach(view => {
        scene.background = view.texture ?? defaultBg;
        view.renderer.render(scene, view.camera);
      });
    }


    animate();
  }
);

/* ---------- responsive canvas ---------- */
addEventListener('resize', () => {
  // Re-center the viewport and update view sizes
  updateViewSizes();
});
</script></body></html>
