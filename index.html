<!-- wxai_min.html  –  minimal translate-only IK demo -->
<!DOCTYPE html><html lang="en"><head>
<meta charset="utf-8" />
<title>WidowX AI — position IK only</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#f5f5f5}
  /* Multi-view container wrapper with blue background */
  #viewport{
    position:fixed; 
    top:50%; left:50%; 
    transform:translate(-50%, -50%);
    background: #3b82f6;
    border-radius: 12px;
    padding: 20px;
    box-shadow:0 4px 20px rgba(0,0,0,0.15);
    display: flex;
    flex-direction: column;
    gap: 20px;
  }
  
  /* Text prompt area */
  #viewport .prompt-text{
    color: white;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans";
    font-size: 18px;
    font-weight: 600;
    text-align: left;
    text-shadow: 0 2px 4px rgba(0,0,0,0.3);
    line-height: 1.4;
    min-height: auto;
    padding: 0;
    margin: 0;
  }

  /* Content container for views and controls */
  #viewport .content-container{
    display: flex;
    gap: 20px;
    align-items: center;
  }
  
  /* Grid container for camera views */
  #viewport .views-grid{
    display:grid; 
    gap:0px; 
    border-radius:4px;
    overflow:hidden;
    flex-shrink: 0;
  }

  /* Container for sliders with CAPTCHA styling */
  #viewport .controls-container{
    background: rgba(255, 255, 255, 0.95);
    border-radius: 8px;
    padding: 16px 16px 12px 16px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    border: 1px solid rgba(255,255,255,0.2);
    min-width: 200px;
    display: flex;
    flex-direction: column;
    gap: 20px;
  }

  /* Single slider layout (underneath views) */
  #viewport.single-slider{
    flex-direction: column;
  }
  #viewport.single-slider .content-container{
    flex-direction: column;
    align-items: center;
  }
  #viewport.single-slider .controls-container{
    align-self: center;
    max-width: 400px;
  }

  /* Multiple slider layout (to the right of views) */
  #viewport.multiple-sliders .content-container{
    flex-direction: row;
    align-items: center;
  }

  /* Style the lil-gui within controls container */
  .controls-container .lil-gui {
    --background-color: transparent;
    --widget-color: rgba(255,255,255,0.9);
    --hover-color: rgba(255,255,255,1);
    --focus-color: #3b82f6;
    --text-color: #374151;
    --text-color-disabled: #9ca3af;
    --border-color: rgba(0,0,0,0.1);
    --border-color-hover: rgba(0,0,0,0.2);
    border: none !important;
    box-shadow: none !important;
    font-size: 16px;
  }

  /* Hide any lil-gui title/header elements */
  .controls-container .lil-gui .title,
  .controls-container .lil-gui .lil-gui > .title {
    display: none !important;
  }

  .controls-container .lil-gui .controller {
    margin: 8px 0;
    height: 32px;
  }

  .controls-container .lil-gui .controller .name {
    font-size: 16px;
    font-weight: 500;
    min-width: 60px;
  }

  .controls-container .lil-gui .controller input[type="range"] {
    -webkit-appearance: none;
    appearance: none;
    background: linear-gradient(to right, #d1d5db 0%, #d1d5db 100%);
    border-radius: 8px;
    height: 16px;
    min-width: 140px;
    outline: none;
    border: 1px solid #9ca3af;
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
  }

  /* Webkit slider thumb (Chrome, Safari, Edge) */
  .controls-container .lil-gui .controller input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 40px;
    height: 28px;
    background: linear-gradient(145deg, #cbd5e1 0%, #94a3b8 50%, #64748b 100%);
    border: 2px solid #475569;
    border-radius: 6px;
    cursor: pointer;
    box-shadow: 
      0 3px 8px rgba(0,0,0,0.4), 
      inset 0 1px 0 rgba(255,255,255,0.3);
    position: relative;
  }

  /* Firefox slider thumb */
  .controls-container .lil-gui .controller input[type="range"]::-moz-range-thumb {
    width: 40px;
    height: 28px;
    background: linear-gradient(145deg, #cbd5e1 0%, #94a3b8 50%, #64748b 100%);
    border: 2px solid #475569;
    border-radius: 6px;
    cursor: pointer;
    box-shadow: 
      0 3px 8px rgba(0,0,0,0.4), 
      inset 0 1px 0 rgba(255,255,255,0.3);
  }

  /* Hover effects */
  .controls-container .lil-gui .controller input[type="range"]::-webkit-slider-thumb:hover {
    background: linear-gradient(145deg, #e2e8f0 0%, #cbd5e1 50%, #94a3b8 100%);
    box-shadow: 
      0 4px 10px rgba(0,0,0,0.5), 
      inset 0 1px 0 rgba(255,255,255,0.5);
    border: 2px solid #334155;
  }

  .controls-container .lil-gui .controller input[type="range"]::-moz-range-thumb:hover {
    background: linear-gradient(145deg, #e2e8f0 0%, #cbd5e1 50%, #94a3b8 100%);
    box-shadow: 
      0 4px 10px rgba(0,0,0,0.5), 
      inset 0 1px 0 rgba(255,255,255,0.5);
    border: 2px solid #334155;
  }

  /* Track styling for Firefox */
  .controls-container .lil-gui .controller input[type="range"]::-moz-range-track {
    background: linear-gradient(to right, #d1d5db 0%, #d1d5db 100%);
    border-radius: 8px;
    height: 16px;
    border: 1px solid #9ca3af;
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
  }

  /* Hide the number input/display by default */
  .controls-container .lil-gui .controller input[type="number"],
  .controls-container .lil-gui .controller .display {
    display: none !important;
  }

  /* Show numerical values in dev mode */
  body.dev-mode .controls-container .lil-gui .controller input[type="number"],
  body.dev-mode .controls-container .lil-gui .controller .display {
    display: block !important;
    width: 60px;
    font-size: 12px;
    margin-left: 8px;
  }

  /* Gripper button styling */
  .controls-container .gripper-section {
    margin: 0 0 12px 0;
  }

  .controls-container .gripper-label {
    font-size: 16px;
    font-weight: 500;
    color: #374151;
    margin-bottom: 8px;
    text-align: left;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans";
  }

  .controls-container .gripper-buttons {
    display: flex;
    gap: 8px;
    justify-content: center;
    margin: 0;
  }

  .controls-container .gripper-buttons button,
  .controls-container .confirm-button {
    padding: 8px 16px;
    border: none;
    border-radius: 6px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    text-transform: capitalize;
  }

  .controls-container .gripper-buttons button.open-btn {
    background: #10b981;
    color: white;
    flex: 1;
  }

  .controls-container .gripper-buttons button.close-btn {
    background: #ef4444;
    color: white;
    flex: 1;
  }

  .controls-container .confirm-button {
    background: #3b82f6;
    color: white;
    width: 100%;
    font-size: 16px;
    font-weight: 600;
    padding: 12px 16px;
  }

  .controls-container button:hover {
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    transition: all 0.2s ease;
  }

  .controls-container button:active {
    transform: translateY(0);
  }

  .view-container{
    position:relative;
    display:grid;
    place-items:center;
    overflow:hidden;
  }
  .view-container.selected{border:2px solid #60a5fa;box-shadow:0 0 15px rgba(96,165,250,.6)}
  canvas{display:block;object-fit:cover;width:100%;height:100%}
  /* (no width/height forcing on canvas; renderer controls it) */
 /* --- nice full-screen status overlay + spinner --- */
  #statusOverlay{
    position:fixed; inset:0; display:none; place-items:center;
    background: radial-gradient(1200px 800px at 50% 30%, #111827 0%, #0b0d12 60%, #000 100%);
    color:#e5e7eb; padding:24px; text-align:center;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
  }
  #statusOverlay .card{
    max-width: 720px; width: min(92vw, 720px);
    background: rgba(17,24,39,0.55);
    border: 1px solid rgba(255,255,255,0.08);
    box-shadow: 0 10px 30px rgba(0,0,0,0.5), inset 0 1px 0 rgba(255,255,255,0.04);
    border-radius: 20px; padding: 26px 28px;
    backdrop-filter: blur(8px);
  }
  #statusOverlay .title{ font-size:20px; letter-spacing:.02em; margin:0 0 8px }
  #statusOverlay .msg  { font-size:16px; line-height:1.5; opacity:.9; margin:0 }
  #statusOverlay .row  { display:flex; align-items:center; gap:14px; justify-content:center; margin-bottom:10px }
  #statusOverlay .spinner{
    width:22px; height:22px; border-radius:50%;
    border:3px solid rgba(255,255,255,.25);
    border-top-color:#60a5fa; border-right-color:#93c5fd;
    animation: spin 1s linear infinite;
    box-shadow: 0 0 20px rgba(96,165,250,.35);
  }
  @keyframes spin{ to { transform: rotate(360deg); } }
</style>

<!-- Polyfill so the import-map works everywhere -->
<script async src="https://cdn.jsdelivr.net/npm/es-module-shims@2/dist/es-module-shims.js"></script>

<script type="importmap">
{
  "imports": {
    "three":               "https://cdn.jsdelivr.net/npm/three@0.165/build/three.module.js",
    "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.165/examples/jsm/",
    "urdf-loader":         "https://cdn.jsdelivr.net/npm/urdf-loader@0.12.6/src/URDFLoader.js?module",
    "closed-chain-ik":     "https://cdn.jsdelivr.net/npm/closed-chain-ik@0.18.0/dist/index.module.js"
  }
}
</script></head><body>
  <!-- Centering mount for the WebGL canvas; avoids CSS stretching -->
  <div id="viewport"></div>
<script type="module">
/* ---------- imports ---------- */
import * as THREE                    from 'three';
import { OrbitControls }             from 'three/examples/jsm/controls/OrbitControls.js';
import URDFLoader                    from 'urdf-loader';
import {
  urdfRobotToIKRoot,
  setIKFromUrdf,
  setUrdfFromIK,
  Goal,
  Solver,
  DOF
} from 'closed-chain-ik';

import {GUI} from 'three/examples/jsm/libs/lil-gui.module.min.js';

// Simple API Configuration - use Netlify Functions proxy
async function getCurrentNgrokUrl() {
  try {
    // Use the direct Netlify function URL since redirects aren't working
    return '/.netlify/functions/api'; // Direct function path
  } catch (error) {
    console.error('Error in getCurrentNgrokUrl:', error);
    return '/.netlify/functions/api'; // Fallback to direct function
  }
}

// Initialize API_BASE_URL dynamically
let API_BASE_URL = 'http://127.0.0.1:9000'; // Default fallback

async function getInitialState() {
  try {
    const response = await fetch(`${API_BASE_URL}/api/get-state`, {
      headers: {
        'ngrok-skip-browser-warning': 'true'
      }
    });
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return await response.json();
  } catch (error) {
    console.error("Could not fetch initial state:", error);
    showServerNotStarted();
    // Hide interactive UI when server is not running
    const uiElems = document.querySelectorAll("button, .lil-gui, #viewport");
    uiElems.forEach(el=>{
      el.style.display = "none";
    });
    return {};
  }
}


// Build a THREE.Texture from a base64 JPEG data URL
async function makeTextureFromDataURL(url) {
  const loader = new THREE.TextureLoader();
  return await new Promise((resolve, reject) => {
    loader.load(
      url,
      tex => {
        tex.flipY = true;
        tex.generateMipmaps = false;
        tex.minFilter = THREE.LinearFilter;
        tex.magFilter = THREE.LinearFilter;
        tex.needsUpdate = true;
        resolve(tex);
      },
      undefined,
      err => reject(err)
    );
  });
}

/* ---------- scene ---------- */
const defaultBg = new THREE.Color(0xf5f5f5);
const scene = new THREE.Scene();
scene.background = defaultBg;
scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1));

const dir = new THREE.DirectionalLight(0xffffff, 1.2);
dir.position.set(2, 4, 2);
scene.add(dir);

/* ---------- floor / workspace visual -------------------- */
// light, neutral grid on the ground (y = 0)

// Default camera (will be cloned for each view)
const templateCamera = new THREE.PerspectiveCamera(45, 1, 0.01, 100);
templateCamera.position.set(0.2, -2, 0).applyAxisAngle(new THREE.Vector3(0, -1, 1), Math.PI);

// Render everything at a more compact size for captcha-style layout
const VIEW_SCALE = 0.8;

// Multi-view system
const views = new Map(); // viewName -> {camera, renderer, container, name}
let currentViewName = null;
let calibrationMode = false; // Calibration mode (UI & per-camera params)
const mount = document.getElementById('viewport');

// Create the prompt text first
const promptText = document.createElement('div');
promptText.className = 'prompt-text';
promptText.textContent = 'Pick up the red block.'; // Default text, will be updated from server
mount.appendChild(promptText);

// Create the content container for views and controls
const contentContainer = document.createElement('div');
contentContainer.className = 'content-container';
mount.appendChild(contentContainer);

// Create the views grid container
const viewsGrid = document.createElement('div');
viewsGrid.className = 'views-grid';
contentContainer.appendChild(viewsGrid);

// Create the controls container for sliders
const controlsContainer = document.createElement('div');
controlsContainer.className = 'controls-container';
controlsContainer.style.display = 'none'; // Hidden initially
contentContainer.appendChild(controlsContainer);

// Multi-view grid layout helper
function calculateGridLayout(numViews) {
  if (numViews === 1) return { rows: 1, cols: 1 };
  if (numViews === 2) return { rows: 1, cols: 2 };
  if (numViews === 3) return { rows: 2, cols: 2 }; // 2 on top, 1 on bottom
  if (numViews === 4) return { rows: 2, cols: 2 };
  // For more views, calculate a reasonable grid
  const cols = Math.ceil(Math.sqrt(numViews));
  const rows = Math.ceil(numViews / cols);
  return { rows, cols };
}

function setupViewportGrid(numViews) {
  const { rows, cols } = calculateGridLayout(numViews);
  viewsGrid.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
  viewsGrid.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
}

function createViewRenderer(viewName, cameraModel, texture) {
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(devicePixelRatio);
  
  const camera = templateCamera.clone();
  
  const container = document.createElement('div');
  container.className = 'view-container';
  container.dataset.viewName = viewName;
  
  container.appendChild(renderer.domElement);
  viewsGrid.appendChild(container);
  
  const view = {
    camera,
    renderer,
    container,
    name: viewName,
    model: cameraModel,
    texture: texture
  };
  
  views.set(viewName, view);
  return view;
}

function updateViewSizes() {
  const viewContainers = viewsGrid.querySelectorAll('.view-container');
  if (viewContainers.length === 0) return;
  
  // Define compact view dimensions based on number of views (increased by 87.5% total: 1.25 * 1.5)
  const numViews = viewContainers.length;
  let targetWidth, targetHeight;
  
  if (numViews === 1) {
    targetWidth = 600;  // 400 * 1.5
    targetHeight = 450; // 300 * 1.5
  } else if (numViews === 2) {
    targetWidth = 450;  // 300 * 1.5
    targetHeight = 338; // 225 * 1.5
  } else if (numViews === 3 || numViews === 4) {
    targetWidth = 375;  // 250 * 1.5
    targetHeight = 282; // 188 * 1.5
  } else {
    targetWidth = 300;  // 200 * 1.5
    targetHeight = 225; // 150 * 1.5
  }
  
  // Apply sizing to views grid - no gaps or padding now
  const { rows, cols } = calculateGridLayout(numViews);
  const totalWidth = cols * targetWidth; // no gaps
  const totalHeight = rows * targetHeight; // no gaps
  
  viewsGrid.style.width = totalWidth + 'px';
  viewsGrid.style.height = totalHeight + 'px';
  
  views.forEach(view => {
    const model = view.model;
    if (!model) return;
    
    const W = model.width | 0;
    const H = model.height | 0;
    
    // Make canvas fill the entire container
    const containerAspect = targetWidth / targetHeight;
    const imageAspect = W / H;
    
    let renderWidth = targetWidth;
    let renderHeight = targetHeight;
    
    // Fill the container completely (may crop image slightly)
    if (containerAspect > imageAspect) {
      // Container is wider than image aspect - fit to width
      renderHeight = Math.round(targetWidth / imageAspect);
    } else {
      // Container is taller than image aspect - fit to height  
      renderWidth = Math.round(targetHeight * imageAspect);
    }
    
    view.renderer.setSize(renderWidth, renderHeight);
    
    // Set container size to match target exactly
    view.container.style.width = targetWidth + 'px';
    view.container.style.height = targetHeight + 'px';
  });
}


// --- status overlay (initially hidden) ---
const statusOverlay = document.createElement('div');
statusOverlay.id = 'statusOverlay';
document.body.appendChild(statusOverlay);

function showServerNotStarted(){
  statusOverlay.innerHTML = `
    <div class="card">
      <div class="row">
        <div class="spinner" aria-hidden="true"></div>
        <h2 class="title">Connecting to data collection server…</h2>
      </div>
      <p class="msg">
        Data collection server hasn't started yet.<br/>
        Please wait for further communications.
      </p>
    </div>`;
  statusOverlay.style.display = 'grid';
}

// ================================ devMode ===================================
const devMode = false;
// Apply dev-mode class to body if devMode is enabled
if (devMode) {
  document.body.classList.add('dev-mode');
}
// ================================ devMode ===================================


let calibGUI = null;                       // lil-gui instance for calibration
const calibState = {};                     // name -> {tx,ty,tz,rx,ry,rz,fx,fy,cx,cy}
const calibDefaults = {};                  // snapshot at calibration start (per camera)

/* ---------- load URDF ---------- */
const loader = new URDFLoader();
loader.packages = {                 // map package:// paths → server paths
  'trossen_arm_description': 'assets/trossen_arm_description'
};

loader.load(
  'assets/trossen_arm_description/urdf/generated/wxai/wxai_base.urdf',
  async robot => {

    // Initialize API_BASE_URL dynamically
    API_BASE_URL = await getCurrentNgrokUrl();
    console.log('Using API Base URL:', API_BASE_URL);

    scene.add(robot);

    let robotVisible = false; // toggle visibility of the robot model
    robot.visible = false;     // hide arm until user moves a slider
    let toggleRobotBtn = null;

    /* --- build IK tree from URDF (limits copied automatically) --- */
    const ikRoot = urdfRobotToIKRoot(robot);          // :contentReference[oaicite:0]{index=0}

    ikRoot.clearDoF()

    const state = await getInitialState();
    const cameraModels = state.camera_models ?? {};
    // If the data collection server isn't available, stop building UI
    if (!state || Object.keys(state).length === 0 || !cameraModels) {
      // Ensure the status overlay is visible and abort UI construction
      showServerNotStarted();
      return; // ← prevents creating sliders/buttons and starting animation
    }

    /* ---------- build textures from JPEG base64 views --------------- */
    const viewTextures = {}; // 'front' → THREE.Texture
    for (const [key, dataUrl] of Object.entries(state.views ?? {})) {
      viewTextures[key] = await makeTextureFromDataURL(dataUrl);
    }

    const initialJointPositions = state.joint_positions ?? {};
    const activeControls        = state.controls ?? ['x','y','z','roll','pitch','yaw'];
    
    // Update prompt text from server state
    const promptFromServer = state.prompt || 'Pick up the red block.';
    promptText.textContent = promptFromServer;
    
    for (const [name, val] of Object.entries(initialJointPositions)) {
      robot.setJointValue(name, val);
    }

    /* ---------- gripper-motion arrows ---------------------------------- */
    let gripArrows = [];                       // keeps currently-shown arrow meshes
    let gripDir    = state.gripper ?? 0;

    function drawGripArrows(dir /* +1 open | –1 close */) {
      /* remove previous arrows */
      gripArrows.forEach(a => a.parent?.remove(a));
      gripArrows.length = 0;

      gripDir = dir || 0;     // remember last request
      if (!dir) return;        // nothing to draw

      const colour   = dir > 0 ? 0x00ff00 : 0xff0000;
      const len      = 0.04, headLen = 0.02;
      const shaftLen = len - headLen, shaftRad = 0.005, offset = 0.00;
      const tipX     = 0.02;

      function addArrow(linkName, outward) {
        const link = robot.getObjectByName(linkName); if (!link) return;
        const dirLocal    = new THREE.Vector3(0, dir * outward, 0).normalize();
        const baseDist    = dir > 0 ? offset : offset + len;
        const originLocal = new THREE.Vector3(tipX, outward * baseDist, 0);

        /* geometry ---------------------------------------------------- */
        const mat       = new THREE.MeshBasicMaterial({ color: colour });
        const grp       = new THREE.Group();

        const shaftGeo  = new THREE.CylinderGeometry(shaftRad, shaftRad,
                                                     shaftLen, 8, 1, true);
        const shaft     = new THREE.Mesh(shaftGeo, mat);
        shaft.position.y = shaftLen / 2;
        grp.add(shaft);

        const coneGeo   = new THREE.ConeGeometry(headLen * 0.6, headLen, 8);
        const cone      = new THREE.Mesh(coneGeo, mat);
        cone.position.y = shaftLen + headLen / 2;
        grp.add(cone);

        grp.position.copy(originLocal);
        grp.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dirLocal);
        link.add(grp);
        gripArrows.push(grp);
      }
      addArrow('gripper_left',  +1);
      addArrow('gripper_right', -1);
    }

    drawGripArrows(state.gripper ?? 0);        // render initial arrows from server

    const gui = new GUI({ container: controlsContainer });
    gui.domElement.style.position = 'static'; // Remove absolute positioning
    gui.domElement.style.width = '100%';
    
    // Create gripper controls container (will be added after sliders)
    let gripperButtonsContainer = null;
    if (activeControls.includes('gripper')) {
      gripperButtonsContainer = document.createElement('div');
      gripperButtonsContainer.className = 'gripper-section';
      
      const gripperLabel = document.createElement('div');
      gripperLabel.className = 'gripper-label';
      gripperLabel.textContent = 'gripper';
      gripperButtonsContainer.appendChild(gripperLabel);
      
      const buttonsContainer = document.createElement('div');
      buttonsContainer.className = 'gripper-buttons';
      
      const openBtn = document.createElement('button');
      openBtn.textContent = 'Open';
      openBtn.className = 'open-btn';
      openBtn.onclick = () => drawGripArrows(+1);
      
      const closeBtn = document.createElement('button');
      closeBtn.textContent = 'Close';
      closeBtn.className = 'close-btn';
      closeBtn.onclick = () => drawGripArrows(-1);
      
      buttonsContainer.appendChild(openBtn);
      buttonsContainer.appendChild(closeBtn);
      gripperButtonsContainer.appendChild(buttonsContainer);
    }

    const camPoses = state.camera_poses ?? {}

    // --- Intrinsics → projection helper (use Knew from backend) ---
    function applyProjectionFromK(view) {
      const model = view.model;
      const camera = view.camera;
      if (!model || !model.Knew || !model.width || !model.height) {
        return false;
      }
      const K = model.Knew;       // 3x3 (row-major)
      const W = model.width|0;
      const H = model.height|0;
      const near = camera.near, far = camera.far;

      // Scale intrinsics to current viewport (CSS) size
      const sz = new THREE.Vector2();
      view.renderer.getDrawingBufferSize(sz);
      const vw = sz.x, vh = sz.y;
      const sx = vw / W, sy = vh / H;

      const fx = K[0][0] * sx, fy = K[1][1] * sy;
      const cx = K[0][2] * sx, cy = K[1][2] * sy;

      // OpenCV pixels (origin top-left, +y down) → Three frustum (y up)
      const left   = -cx * near / fx;
      const right  =  (vw - cx) * near / fx;
      const top    =  cy * near / fy;
      const bottom = -(vh - cy) * near / fy;

      const P = new THREE.Matrix4().makePerspective(left, right, top, bottom, near, far);
      camera.projectionMatrix.copy(P);
      camera.projectionMatrixInverse.copy(P).invert();
      camera.projectionMatrixAutoUpdate = false;
      return true;
    }

    function applyDefaultPerspective(view) {
      const camera = view.camera;
      camera.projectionMatrixAutoUpdate = true;
      camera.fov = 45;
      camera.aspect = 1; // Will be updated when renderer size is set
      camera.updateProjectionMatrix();
    }

    function updateViewCamera(view, pose) {
      if (!pose) return false;
      
      const m = poseToMatrix(pose);
      const pos   = new THREE.Vector3();
      const quat  = new THREE.Quaternion();
      const scale = new THREE.Vector3();
      m.decompose(pos, quat, scale);

      view.camera.position.copy(pos);
      view.camera.quaternion.copy(quat);
      view.camera.updateMatrixWorld();
      
      return true;
    }

    /* ---------- calibration helpers (intrinsics & extrinsics) ------- */
    function poseKeyForName(name) {
      // camPoses keys look like "front_pose", "left_pose", ...
      for (const k of Object.keys(camPoses)) if (k.startsWith(name)) return k;
      return null;
    }

    function ensureCalibStateFor(name) {
      if (calibState[name]) return;
      // Seed from current view's camera transform & model K
      const view = views.get(name);
      if (!view) return;
      
      const pos = new THREE.Vector3();
      const quat = new THREE.Quaternion();
      view.camera.updateMatrixWorld();
      view.camera.getWorldPosition(pos);
      view.camera.getWorldQuaternion(quat);
      const eul = new THREE.Euler().setFromQuaternion(quat, 'XYZ');
      const model = cameraModels?.[name];
      const K = model?.Knew;
      calibState[name] = {
        tx: pos.x, ty: pos.y, tz: pos.z,
        rx: eul.x, ry: eul.y, rz: eul.z,
        fx: K ? K[0][0] : 800,
        fy: K ? K[1][1] : 800,
        cx: K ? K[0][2] : (model?.width ?? 640) / 2,
        cy: K ? K[1][2] : (model?.height ?? 480) / 2,
        zoom: 1.0,  // multiplicative scale for fx, fy
      };
    }

    function destroyCalibGUI() { if (calibGUI) { calibGUI.destroy(); calibGUI = null; } }

    function applyExtrinsicsFromParams(name) {
      const s = calibState[name]; if (!s) return;
      const view = views.get(name); if (!view) return;
      
      const q = new THREE.Quaternion().setFromEuler(new THREE.Euler(s.rx, s.ry, s.rz, 'XYZ'));
      view.camera.position.set(s.tx, s.ty, s.tz);
      view.camera.quaternion.copy(q);
      view.camera.updateMatrixWorld(true);
      
      // Update camPoses so switching away/back keeps edited pose
      const key = poseKeyForName(name);
      if (key) {
        const m = new THREE.Matrix4().compose(view.camera.position.clone(), view.camera.quaternion.clone(), new THREE.Vector3(1,1,1));
        const e = m.elements; // row-major in Three (column-major storage)
        camPoses[key] = [
          [e[0], e[4], e[8],  e[12]],
          [e[1], e[5], e[9],  e[13]],
          [e[2], e[6], e[10], e[14]],
          [e[3], e[7], e[11], e[15]],
        ];
      }
    }

    function applyIntrinsicsFromParams(name) {
      const s = calibState[name]; if (!s) return;
      const model = cameraModels?.[name]; if (!model) return;
      const view = views.get(name); if (!view) return;
      
      const z = (s.zoom ?? 1.0);
      const fx_eff = s.fx * z;
      const fy_eff = s.fy * z;
      model.Knew = [
        [fx_eff, 0,     s.cx],
        [0,      fy_eff, s.cy],
        [0,    0,    1   ],
      ];
      applyProjectionFromK(view);
    }

    // tiny helper: add a slider **and** a matching "revert" button for it
    function addParamWithRevert(folder, stateObj, key, range, step, label, onChange, camName){
      const [min, max] = range;
      const ctrl = folder.add(stateObj, key, min, max, step).name(label).onChange(()=>onChange(camName));
      const revertObj = {};
      const revertLabel = `revert ${label}`;
      revertObj[revertLabel] = () => {
        // restore from snapshot taken when entering calibration
        stateObj[key] = calibDefaults[camName][key];
        ctrl.updateDisplay();
        onChange(camName);
      };
      folder.add(revertObj, revertLabel);
      return ctrl;
    }

    function enterCalibration() {
      if (!currentViewName) { console.warn('Pick a camera view before calibrating.'); return; }
      calibrationMode = true;
      destroyCalibGUI();
      ensureCalibStateFor(currentViewName);
      const s = calibState[currentViewName];
      calibDefaults[currentViewName] = { ...s };
      calibGUI = new GUI();
      // Position panel top-right
      calibGUI.domElement.style.position = 'fixed';
      calibGUI.domElement.style.top = '8px';
      calibGUI.domElement.style.right = '8px';
      calibGUI.domElement.style.zIndex = 20;
      
      // Intrinsics controls (no folder)
      const model = cameraModels[currentViewName];
      const W = model?.width  ?? 640;
      const H = model?.height ?? 480;
      addParamWithRevert(calibGUI, s, 'zoom', [0.1, 5.0], 0.001, 'zoom', applyIntrinsicsFromParams, currentViewName);
      addParamWithRevert(calibGUI, s, 'fx', [50, 8000], 1,   'fx', applyIntrinsicsFromParams, currentViewName);
      addParamWithRevert(calibGUI, s, 'fy', [50, 8000], 1,   'fy', applyIntrinsicsFromParams, currentViewName);
      addParamWithRevert(calibGUI, s, 'cx', [0, W],     0.1, 'cx', applyIntrinsicsFromParams, currentViewName);
      addParamWithRevert(calibGUI, s, 'cy', [0, H],     0.1, 'cy', applyIntrinsicsFromParams, currentViewName);
      
      // Extrinsics controls (no folder)
      addParamWithRevert(calibGUI, s, 'tx', [s.tx - 0.25, s.tx + 0.25], 0.0005, 'tx (m)',   applyExtrinsicsFromParams, currentViewName);
      addParamWithRevert(calibGUI, s, 'ty', [s.ty - 0.25, s.ty + 0.25], 0.0005, 'ty (m)',   applyExtrinsicsFromParams, currentViewName);
      addParamWithRevert(calibGUI, s, 'tz', [s.tz - 0.25, s.tz + 0.25], 0.0005, 'tz (m)',   applyExtrinsicsFromParams, currentViewName);
      addParamWithRevert(calibGUI, s, 'rx', [s.rx - 1.0,  s.rx + 1.0 ], 0.0005, 'roll rx',  applyExtrinsicsFromParams, currentViewName);
      addParamWithRevert(calibGUI, s, 'ry', [s.ry - 1.0,  s.ry + 1.0 ], 0.0005, 'pitch ry', applyExtrinsicsFromParams, currentViewName);
      addParamWithRevert(calibGUI, s, 'rz', [s.rz - 1.0,  s.rz + 1.0 ], 0.0005, 'yaw rz',   applyExtrinsicsFromParams, currentViewName);
      
      // ---- Save calibration action (writes to backend) ----
      const actions = {
        async save_calibration() {
          try {
            // build 4x4 from current cam pose (tx,ty,tz + rx,ry,rz)
            const q = new THREE.Quaternion().setFromEuler(new THREE.Euler(s.rx, s.ry, s.rz, 'XYZ'));
            const Tm = new THREE.Matrix4().compose(
              new THREE.Vector3(s.tx, s.ty, s.tz),
              q,
              new THREE.Vector3(1,1,1)
            );
            // convert to row-major list-of-lists like the rest of the app
            const e = Tm.elements;
            const T_three = [
              [e[0], e[4], e[8],  e[12]],
              [e[1], e[5], e[9],  e[13]],
              [e[2], e[6], e[10], e[14]],
              [e[3], e[7], e[11], e[15]],
            ];
            const model = cameraModels[currentViewName];
            // Use effective fx/fy that include zoom
            const z = (s.zoom ?? 1.0);
            const fx_eff = s.fx * z;
            const fy_eff = s.fy * z;
            const payload = {
              camera: currentViewName,
              intrinsics: {
                width:  model?.width  ?? 640,
                height: model?.height ?? 480,
                Knew: [
                  [fx_eff, 0,    s.cx],
                  [0,    fy_eff, s.cy],
                  [0,    0,    1   ],
                ],
                zoom: z
              },
              extrinsics: { T_three }
            };
            const resp = await fetch(`${API_BASE_URL}/api/save-calibration`, {
              method: 'POST',
              headers: { 
                'Content-Type': 'application/json',
                'ngrok-skip-browser-warning': 'true'
              },
              body: JSON.stringify(payload)
            });
            const out = await resp.json();
            if (!resp.ok) throw new Error(out?.error || 'save failed');
            console.log('✅ saved calibration:', out);
            alert(`Saved calibration for '${currentViewName}' to ${out.path}`);
          } catch (err) {
            console.error('❌ save calibration failed', err);
            alert('Save calibration failed. See console for details.');
          }
        }
      };
      calibGUI.add(actions, 'save_calibration').name('Save calibration');

      // Initial apply so the matrices reflect slider defaults
      applyIntrinsicsFromParams(currentViewName);
      applyExtrinsicsFromParams(currentViewName);
    }

    function exitCalibration() {
      destroyCalibGUI();
      calibrationMode = false;
    }

    setIKFromUrdf(ikRoot, robot);
    ikRoot.updateMatrixWorld(true);

    /* --- locate the end-effector link inside IK tree --- */
    let ee = null;
    
    ikRoot.traverse(child => {                        // Frame.traverse
      if ( child.name === 'ee_gripper_link' ) { ee = child; return true; }
    });

    /* --- create a translation-only Goal --- */
    const goal = new Goal();
    goal.setDoF(DOF.X, DOF.Y, DOF.Z, DOF.EX, DOF.EY, DOF.EZ);

    goal.makeClosure( ee );                          // link goal ↔ ee

    /* ---- sample the **visual** EE pose after matrices are fresh */
    const startPos  = new THREE.Vector3();
    const startQuat = new THREE.Quaternion();

    robot.updateMatrixWorld( true );                 // propagate world mats
    const eeVis = robot.getObjectByName( 'ee_gripper_link' );
    eeVis.getWorldPosition   ( startPos  );
    eeVis.getWorldQuaternion ( startQuat );

    goal.setPosition   ( startPos.x, startPos.y, startPos.z );
    goal.setQuaternion ( startQuat.x, startQuat.y, startQuat.z, startQuat.w );

    const baseQuat = startQuat.clone();

    /* ---------- semi-transparent alignment line -------------------- */
    const lineLen = 0.80;      // meters
    const lineRad = 0.002;     // thickness
    const lineOffX = - 0.01;
    const lineMat = new THREE.MeshBasicMaterial({
      color: 0x00ff00, transparent: true, opacity: 0.4
    });
    const line    = new THREE.Mesh(
      new THREE.CylinderGeometry(lineRad, lineRad, lineLen, 8, 1, true),
      lineMat
    );
    line.rotation.x = Math.PI / 2;   // cylinder-Y → world Z
    scene.add(line);
    // --- cache & helpers for fast updates (no per-frame allocs) ---
    const baseLineLen = line.geometry.parameters.height; // original cylinder height
    const floorZ      = 0.0;      // ground plane (Z-up)
    const bottomPad   = 0.0005;   // tiny lift to avoid z-fighting
    const _eePosTmp   = new THREE.Vector3();

    /* ---- red sphere exactly at that pose ---------------------- */
    const marker = new THREE.Mesh(
      new THREE.SphereGeometry( 0.005, 16, 16 ),
      new THREE.MeshStandardMaterial( { color: 0xff0000 } )
    );
    marker.position.copy    ( startPos  );
    marker.quaternion.copy  ( startQuat );
    scene.add( marker );

    /* 2) build lil-GUI sliders ----------------------------------- */
    const startEuler = new THREE.Euler().setFromQuaternion(startQuat, 'XYZ');
    const params = {
      x: startPos.x, y: startPos.y, z: startPos.z,
      // roll:  startEuler.x,
      // pitch: startEuler.y,
      // yaw:   startEuler.z
      roll:  0.0,
      pitch: 0.0,
      yaw:   0.0
    };

    function updateGoal() {
      /* position */
      goal.setPosition(params.x, params.y, params.z);
      marker.position.set(params.x, params.y, params.z);

      /* orientation */
      const delta = new THREE.Quaternion().setFromEuler(
        new THREE.Euler(params.roll, params.pitch, params.yaw, 'XYZ')
      );
      const quat = baseQuat.clone().multiply(delta);
      goal.setQuaternion(quat.x, quat.y, quat.z, quat.w);
      marker.quaternion.copy(quat);

      // On first slider interaction: reveal the robot and update button label
      if (!robotVisible) {
        robotVisible = true;
        robot.visible = true;
        if (toggleRobotBtn) toggleRobotBtn.textContent = 'hide robot model';
      }
    }

    /* ---------- camera-view buttons --------------------------- */
    function poseToMatrix(mat){
      return new THREE.Matrix4().set(
        mat[0][0], mat[0][1], mat[0][2], mat[0][3],
        mat[1][0], mat[1][1], mat[1][2], mat[1][3],
        mat[2][0], mat[2][1], mat[2][2], mat[2][3],
        mat[3][0], mat[3][1], mat[3][2], mat[3][3],
      );
    }

    function selectView(viewName) {
      // Remove selection from all views
      views.forEach(view => {
        view.container.classList.remove('selected');
      });
      
      // Select the new view
      const view = views.get(viewName);
      if (view) {
        // Only show visual selection highlighting in devMode
        if (devMode) {
          view.container.classList.add('selected');
        }
        currentViewName = viewName;
        
        if (calibrationMode) {
          destroyCalibGUI();
          enterCalibration();
        }
      }
    }

    function initializeViews() {
      // Clear existing views
      views.clear();
      viewsGrid.innerHTML = '';
      
      // Get available camera poses and textures
      const availableViews = [];
      Object.keys(camPoses).forEach(poseKey => {
        const viewName = poseKey.replace('_pose', '');
        if (viewTextures[viewName] && cameraModels[viewName]) {
          availableViews.push({
            name: viewName,
            poseKey: poseKey,
            texture: viewTextures[viewName],
            model: cameraModels[viewName],
            pose: camPoses[poseKey]
          });
        }
      });
      
      if (availableViews.length === 0) return;
      
      // Setup grid layout
      setupViewportGrid(availableViews.length);
      
      // Create views
      availableViews.forEach((viewInfo, index) => {
        const view = createViewRenderer(viewInfo.name, viewInfo.model, viewInfo.texture);
        
        // Set up camera pose and projection
        updateViewCamera(view, viewInfo.pose);
        applyProjectionFromK(view);
        
        // For 3 views, hide the 4th grid position
        if (availableViews.length === 3 && index === 2) {
          view.container.style.gridColumn = '1 / -1';
          view.container.style.justifySelf = 'center';
        }
      });
      
      // Update sizes and select first view
      updateViewSizes();
      if (availableViews.length > 0) {
        // In devMode, select the first view for visual feedback
        // In regular mode, just set currentViewName without visual selection
        if (devMode) {
          selectView(availableViews[0].name);
        } else {
          currentViewName = availableViews[0].name;
        }
      }
    }

    const btnBar   = document.createElement('div');
    btnBar.style.position = 'fixed';
    btnBar.style.top = '8px';
    btnBar.style.left = '8px';
    btnBar.style.zIndex = 10;
    btnBar.style.display = 'flex';
    btnBar.style.gap = '4px';
    document.body.appendChild( btnBar );

    /* add camera selection buttons (only if devMode enabled) */
    if (devMode) {
      Object.keys(camPoses).forEach(poseKey=>{
        const viewName = poseKey.replace('_pose', '');
        const b       = document.createElement('button');
        b.textContent = viewName; // "left", "right", …
        b.onclick     = ()=> selectView(viewName);
        btnBar.appendChild( b );
      });
    }

    /* add calibrate toggle button (only if devMode enabled) */
    if (devMode) {
      const calibrateBtn = document.createElement('button');
      calibrateBtn.textContent = 'calibrate';
      calibrateBtn.onclick = () => {
        if (!calibrationMode) {
          if (!currentViewName) { alert('Pick a camera view first (front/left/right/...).'); return; }
          enterCalibration();
          calibrateBtn.textContent = 'exit calibration';
        } else {
          exitCalibration();
          calibrateBtn.textContent = 'calibrate';
        }
      };
      btnBar.appendChild(calibrateBtn);
    }

    /* add hide/show robot model button (bottom-left corner) (only if devMode enabled) */
    if (devMode) {
      toggleRobotBtn = document.createElement('button');
      toggleRobotBtn.textContent = 'show robot model';
      toggleRobotBtn.style.position = 'fixed';
      toggleRobotBtn.style.left     = '8px';
      toggleRobotBtn.style.bottom   = '8px';
      toggleRobotBtn.style.zIndex   = 10;
      document.body.appendChild(toggleRobotBtn);

      toggleRobotBtn.onclick = () => {
        robotVisible = !robotVisible;
        robot.visible = robotVisible;
        toggleRobotBtn.textContent = robotVisible
          ? 'hide robot model'
          : 'show robot model';
      };

      toggleRobotBtn.textContent = 'show robot model';
    }

    /* ---------- confirm button (lower-right corner) ------------------- */

    // Initialize the multi-view system
    initializeViews();

  /* ---------- confirm button (inside controls container) ------------------- */

    // Create confirm button to be added to controls container
    const confirmBtn = document.createElement('button');
    confirmBtn.textContent = 'Confirm';
    confirmBtn.className = 'confirm-button';

    confirmBtn.onclick = async () => {
      /* gather current joint values (radians / metres) */
      const jointMap = {};
      Object.entries(robot.joints).forEach(([name, joint]) => {
        jointMap[name] = joint.jointValue;
      });

      /* gather current end-effector pose (world frame) */
      robot.updateMatrixWorld(true);             // ensure transforms are fresh
      const eePos  = new THREE.Vector3();
      const eeQuat = new THREE.Quaternion();
      eeVis.getWorldPosition   (eePos);
      eeVis.getWorldQuaternion (eeQuat);
      const eeEuler = new THREE.Euler().setFromQuaternion(eeQuat, "XYZ");

      try {
        await fetch(`${API_BASE_URL}/api/submit-goal`, {
          method: 'POST',
          headers: { 
            'Content-Type': 'application/json',
            'ngrok-skip-browser-warning': 'true'
          },
          body: JSON.stringify({
            joint_positions: jointMap,
            gripper:         gripDir,                // -1 / +1 / 0
            ee_pose: {                               // added  ⤵
              position:   [eePos.x,  eePos.y,  eePos.z],
              rpy: [eeEuler.x, eeEuler.y, eeEuler.z]
            },
            state_id: state.state_id                 // include state_id for tracking
          })
        });
        console.log('✅ goal sent');
      } catch (err) {
        console.error('❌ failed to send goal', err);
      }
    };

    const spanDefs = [
      ['x',     0.20],   // meters
      ['y',     0.20],
      ['z',     0.20],
      ['roll',  0.61],   // radians
      ['pitch', 0.61],
      ['yaw',   0.61],
    ];

    spanDefs.forEach(([key, span])=>{
      if (!activeControls.includes(key)) return;
      const center = params[key];          // start-pose value
      gui.add(params, key, center - span, center + span)
         .onChange(updateGoal);
    });

    // Add gripper buttons after sliders
    if (gripperButtonsContainer) {
      controlsContainer.appendChild(gripperButtonsContainer);
    }

    // Add confirm button at the bottom
    controlsContainer.appendChild(confirmBtn);

    // Update layout based on number of active controls
    function updateControlsLayout() {
      const numSliders = activeControls.filter(ctrl => ['x', 'y', 'z', 'roll', 'pitch', 'yaw'].includes(ctrl)).length;
      const hasGripper = activeControls.includes('gripper');
      const totalControls = numSliders + (hasGripper ? 1 : 0) + 1; // +1 for confirm button
      
      if (totalControls > 1) { // Always show if we have sliders + confirm
        controlsContainer.style.display = 'block';
        
        if (totalControls === 2 && numSliders === 1) { // 1 slider + confirm
          mount.className = 'single-slider';
        } else {
          mount.className = 'multiple-sliders';
        }
      } else {
        controlsContainer.style.display = 'none';
        mount.className = '';
      }
    }
    
    updateControlsLayout();


    /* --- solver --- */
    const solver = new Solver(ikRoot);                // constructor takes root
    // (solver settings default to 5 iterations, etc.)

    /* --- animation loop --- */
    function animate() {
      requestAnimationFrame(animate);

      setIKFromUrdf(ikRoot, robot);   // URDF ➜ IK                                         :contentReference[oaicite:1]{index=1}
      solver.solve();                 // run DLS IK
      setUrdfFromIK(robot, ikRoot);   // IK ➜ URDF                                         :contentReference[oaicite:2]{index=2}

      // --- align the green line so its bottom sits on the ground ---
      eeVis.getWorldPosition(_eePosTmp);
      // Effective vertical length (Z-up), clamped to ≥ 0 with a small gap from the floor
      let len = _eePosTmp.z - (floorZ + bottomPad);
      if (len <= 0) {
        line.visible = false;             // EE at/below floor → hide
      } else {
        line.visible = true;
        // Scale along local Y (already rotated to world Z)
        line.scale.y = len / baseLineLen;
        // Center of cylinder should be midway between EE.z and floorZ+pad
        const midZ = (floorZ + bottomPad) + 0.5 * len;
        line.position.set(_eePosTmp.x + lineOffX, _eePosTmp.y, midZ);
      }
      
      // Render all views
      views.forEach(view => {
        // Set the background texture for this specific view
        scene.background = view.texture ?? defaultBg;
        view.renderer.render(scene, view.camera);
      });
    }
    animate();
  }
);

/* ---------- responsive canvas ---------- */
addEventListener('resize', () => {
  // Re-center the viewport and update view sizes
  updateViewSizes();
});
</script></body></html>
