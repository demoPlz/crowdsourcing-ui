<!-- wxai_min.html  –  minimal translate-only IK demo -->
<!DOCTYPE html><html lang="en"><head>
<meta charset="utf-8" />
<title>WidowX AI — position IK only</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden}
  /* Center the canvas and prevent stretching; letterbox/pillarbox with black */
  #viewport{position:fixed;inset:0;background:#000;display:grid;place-items:center}
  canvas{display:block}
  /* (no width/height forcing on canvas; renderer controls it) */
 </style>

<!-- Polyfill so the import-map works everywhere -->
<script async src="https://cdn.jsdelivr.net/npm/es-module-shims@2/dist/es-module-shims.js"></script>

<script type="importmap">
{
  "imports": {
    "three":               "https://cdn.jsdelivr.net/npm/three@0.165/build/three.module.js",
    "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.165/examples/jsm/",
    "urdf-loader":         "https://cdn.jsdelivr.net/npm/urdf-loader@0.12.6/src/URDFLoader.js?module",
    "closed-chain-ik":     "https://cdn.jsdelivr.net/npm/closed-chain-ik@0.18.0/dist/index.module.js"
  }
}
</script></head><body>
  <!-- Centering mount for the WebGL canvas; avoids CSS stretching -->
  <div id="viewport"></div>
<script type="module">
/* ---------- imports ---------- */
import * as THREE                    from 'three';
import { OrbitControls }             from 'three/examples/jsm/controls/OrbitControls.js';
import URDFLoader                    from 'urdf-loader';
import {
  urdfRobotToIKRoot,
  setIKFromUrdf,
  setUrdfFromIK,
  Goal,
  Solver,
  DOF
} from 'closed-chain-ik';

import {GUI} from 'three/examples/jsm/libs/lil-gui.module.min.js';

async function getInitialState() {
  try {
    const response = await fetch('http://127.0.0.1:9000/api/get-state');
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return await response.json();
  } catch (error) {
    console.error("Could not fetch initial state:", error);
    return {};
  }
}

/* ---------- scene ---------- */
const defaultBg = new THREE.Color(0xf5f5f5);
const scene = new THREE.Scene();
scene.background = defaultBg;
scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1));

const dir = new THREE.DirectionalLight(0xffffff, 1.2);
dir.position.set(2, 4, 2);
scene.add(dir);

/* ---------- floor / workspace visual -------------------- */
// light, neutral grid on the ground (y = 0)
const grid = new THREE.GridHelper(
  2.0,   // size in meters
  20,    // subdivisions
  0x888888, // center line
  0xb0b0b0  // grid lines
);
grid.position.y = 0;          // lie on y = 0
grid.rotation.x = Math.PI / 2;
scene.add(grid);

const axes = new THREE.AxesHelper(0.3);
scene.add(axes);

const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.01, 100);
camera.position.set(0.2, -2, 0).applyAxisAngle(new THREE.Vector3(0, -1, 1), Math.PI);

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
const mount = document.getElementById('viewport');
mount.appendChild(renderer.domElement);

const orbit = new OrbitControls(camera, renderer.domElement);
orbit.target.set(0, 0, 0)
orbit.update();
orbit.saveState();
let currentCamName = null;  // track which calibrated cam is active (null = orbit/free)

/* ---------- load URDF ---------- */
const loader = new URDFLoader();
loader.packages = {                 // map package:// paths → server paths
  'trossen_arm_description': 'assets/trossen_arm_description'
};

loader.load(
  'assets/trossen_arm_description/urdf/generated/wxai/wxai_base.urdf',
  async robot => {

    scene.add(robot);

    let robotVisible = true; // toggle visibility of the robot model

    /* --- build IK tree from URDF (limits copied automatically) --- */
    const ikRoot = urdfRobotToIKRoot(robot);          // :contentReference[oaicite:0]{index=0}

    ikRoot.clearDoF()

    const state = await getInitialState();
    const cameraModels = state.camera_models ?? {};

    /* ---------- build textures for webcam views -------------------- */
    const viewTextures = {};                        // 'front' → THREE.DataTexture
    for (const [key, img] of Object.entries(state.views ?? {})) {
      const H = img.length, W = img[0].length;
      const buf = new Uint8Array(W * H * 4);
      let p = 0;
      for (let y = 0; y < H; ++y) {
        for (let x = 0; x < W; ++x) {
          const [r, g, b] = img[y][x];
          buf[p++] = r; buf[p++] = g; buf[p++] = b; buf[p++] = 255;
        }
      }
      const tex = new THREE.DataTexture(buf, W, H, THREE.RGBAFormat);
      tex.flipY = true;           // image arrays come top-to-bottom
      tex.needsUpdate = true;
      viewTextures[key] = tex;    // store under same key: 'front', 'left', …
    }

    const initialJointPositions = state.joint_positions ?? {};
    const activeControls        = state.controls ?? ['x','y','z','roll','pitch','yaw'];
    for (const [name, val] of Object.entries(initialJointPositions)) {
      robot.setJointValue(name, val);
    }

    /* ---------- gripper-motion arrows ---------------------------------- */
    let gripArrows = [];                       // keeps currently-shown arrow meshes
    let gripDir    = state.gripper ?? 0;

    function drawGripArrows(dir /* +1 open | –1 close */) {
      /* remove previous arrows */
      gripArrows.forEach(a => a.parent?.remove(a));
      gripArrows.length = 0;

      gripDir = dir || 0;     // remember last request
      if (!dir) return;        // nothing to draw

      const colour   = dir > 0 ? 0x00ff00 : 0xff0000;
      const len      = 0.08, headLen = 0.04;
      const shaftLen = len - headLen, shaftRad = 0.01, offset = 0.00;
      const tipX     = 0.04;

      function addArrow(linkName, outward) {
        const link = robot.getObjectByName(linkName); if (!link) return;
        const dirLocal    = new THREE.Vector3(0, dir * outward, 0).normalize();
        const baseDist    = dir > 0 ? offset : offset + len;
        const originLocal = new THREE.Vector3(tipX, outward * baseDist, 0);

        /* geometry ---------------------------------------------------- */
        const mat       = new THREE.MeshBasicMaterial({ color: colour });
        const grp       = new THREE.Group();

        const shaftGeo  = new THREE.CylinderGeometry(shaftRad, shaftRad,
                                                     shaftLen, 8, 1, true);
        const shaft     = new THREE.Mesh(shaftGeo, mat);
        shaft.position.y = shaftLen / 2;
        grp.add(shaft);

        const coneGeo   = new THREE.ConeGeometry(headLen * 0.6, headLen, 8);
        const cone      = new THREE.Mesh(coneGeo, mat);
        cone.position.y = shaftLen + headLen / 2;
        grp.add(cone);

        grp.position.copy(originLocal);
        grp.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dirLocal);
        link.add(grp);
        gripArrows.push(grp);
      }
      addArrow('gripper_left',  +1);
      addArrow('gripper_right', -1);
    }

    drawGripArrows(state.gripper ?? 0);        // render initial arrows from server

    const gui = new GUI();
    if (activeControls.includes('gripper')) {
      const gf = gui.addFolder('gripper');      // tiny sub-folder
      gf.add({ open : () => drawGripArrows(+1) }, 'open');
      gf.add({ close: () => drawGripArrows(-1) }, 'close');
    }

    const camPoses = state.camera_poses ?? {}

    // --- Intrinsics → projection helper (use Knew from backend) ---
    function applyProjectionFromK(name) {
      const model = cameraModels?.[name];
      if (!model || !model.Knew || !model.width || !model.height) {
        return false;
      }
      const K = model.Knew;       // 3x3 (row-major)
      const W = model.width|0;
      const H = model.height|0;
      const near = camera.near, far = camera.far;

      // Scale intrinsics to current viewport (CSS) size
      const sz = new THREE.Vector2();
      renderer.getDrawingBufferSize(sz);
      const vw = sz.x, vh = sz.y;
      const sx = vw / W, sy = vh / H;

      const fx = K[0][0] * sx, fy = K[1][1] * sy;
      const cx = K[0][2] * sx, cy = K[1][2] * sy;

      // OpenCV pixels (origin top-left, +y down) → Three frustum (y up)
      const left   = -cx * near / fx;
      const right  =  (vw - cx) * near / fx;
      const top    =  cy * near / fy;
      const bottom = -(vh - cy) * near / fy;

      const P = new THREE.Matrix4().makePerspective(left, right, top, bottom, near, far);
      camera.projectionMatrix.copy(P);
      camera.projectionMatrixInverse.copy(P).invert();
      camera.projectionMatrixAutoUpdate = false;
      return true;
    }

    function applyDefaultPerspective() {
      camera.projectionMatrixAutoUpdate = true;
      camera.fov = 45;
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
    }

    // Fit the renderer to the camera image while preserving its aspect ratio
    function fitRendererToImage(name){
      const model = cameraModels?.[name];
      const tex   = viewTextures[name];
      if (!model || !tex) return false;
      const W = model.width|0, H = model.height|0;
      // Fit inside window with letterbox/pillarbox; keep aspect = W/H
      const winW = innerWidth, winH = innerHeight;
      const s = Math.min(winW / W, winH / H);
      const vw = Math.round(W * s), vh = Math.round(H * s);
      renderer.setSize(vw, vh);         // updates buffer & CSS size together
      applyProjectionFromK(name);       // rebuild frustum for this viewport
      return true;
    }

    setIKFromUrdf(ikRoot, robot);
    ikRoot.updateMatrixWorld(true);

    /* --- locate the end-effector link inside IK tree --- */
    let ee = null;
    
    ikRoot.traverse(child => {                        // Frame.traverse
      if ( child.name === 'ee_gripper_link' ) { ee = child; return true; }
    });

    /* --- create a translation-only Goal --- */
    const goal = new Goal();
    goal.setDoF(DOF.X, DOF.Y, DOF.Z, DOF.EX, DOF.EY, DOF.EZ);

    goal.makeClosure( ee );                          // link goal ↔ ee

    /* ---- sample the **visual** EE pose after matrices are fresh */
    const startPos  = new THREE.Vector3();
    const startQuat = new THREE.Quaternion();

    robot.updateMatrixWorld( true );                 // propagate world mats
    const eeVis = robot.getObjectByName( 'ee_gripper_link' );
    eeVis.getWorldPosition   ( startPos  );
    eeVis.getWorldQuaternion ( startQuat );

    goal.setPosition   ( startPos.x, startPos.y, startPos.z );
    goal.setQuaternion ( startQuat.x, startQuat.y, startQuat.z, startQuat.w );

    const baseQuat = startQuat.clone();

    /* ---------- semi-transparent alignment line -------------------- */
    const lineLen = 0.80;      // meters
    const lineRad = 0.002;     // thickness
    const lineOffX = - 0.01;
    const lineMat = new THREE.MeshBasicMaterial({
      color: 0x00ff00, transparent: true, opacity: 0.4
    });
    const line    = new THREE.Mesh(
      new THREE.CylinderGeometry(lineRad, lineRad, lineLen, 8, 1, true),
      lineMat
    );
    line.rotation.x = Math.PI / 2;   // cylinder-Y → world Z
    scene.add(line);
    // --- cache & helpers for fast updates (no per-frame allocs) ---
    const baseLineLen = line.geometry.parameters.height; // original cylinder height
    const floorZ      = 0.0;      // ground plane (Z-up)
    const bottomPad   = 0.0005;   // tiny lift to avoid z-fighting
    const _eePosTmp   = new THREE.Vector3();

    /* ---- red sphere exactly at that pose ---------------------- */
    const marker = new THREE.Mesh(
      new THREE.SphereGeometry( 0.005, 16, 16 ),
      new THREE.MeshStandardMaterial( { color: 0xff0000 } )
    );
    marker.position.copy    ( startPos  );
    marker.quaternion.copy  ( startQuat );
    scene.add( marker );

    /* 2) build lil-GUI sliders ----------------------------------- */
    const startEuler = new THREE.Euler().setFromQuaternion(startQuat, 'XYZ');
    const params = {
      x: startPos.x, y: startPos.y, z: startPos.z,
      // roll:  startEuler.x,
      // pitch: startEuler.y,
      // yaw:   startEuler.z
      roll:  0.0,
      pitch: 0.0,
      yaw:   0.0
    };

    function updateGoal() {
      /* position */
      goal.setPosition(params.x, params.y, params.z);
      marker.position.set(params.x, params.y, params.z);

      /* orientation */
      const delta = new THREE.Quaternion().setFromEuler(
        new THREE.Euler(params.roll, params.pitch, params.yaw, 'XYZ')
      );
      const quat = baseQuat.clone().multiply(delta);
      goal.setQuaternion(quat.x, quat.y, quat.z, quat.w);
      marker.quaternion.copy(quat);
    }

    /* ---------- camera-view buttons --------------------------- */
    function poseToMatrix(mat){
      return new THREE.Matrix4().set(
        mat[0][0], mat[0][1], mat[0][2], mat[0][3],
        mat[1][0], mat[1][1], mat[1][2], mat[1][3],
        mat[2][0], mat[2][1], mat[2][2], mat[2][3],
        mat[3][0], mat[3][1], mat[3][2], mat[3][3],
      );
    }

    function switchCamera (key){
      if (key === 'orbit') {
        orbit.enabled = true;
        orbit.reset();
        scene.background = defaultBg; // reset background
        currentCamName = null;
        renderer.setSize(innerWidth, innerHeight);
        applyDefaultPerspective();
        return;
      }
      if (!camPoses[key]) return;
      const m = poseToMatrix( camPoses[key] );
      const pos   = new THREE.Vector3();
      const quat  = new THREE.Quaternion();
      const scale = new THREE.Vector3();
      m.decompose( pos, quat, scale );

      camera.position.copy(pos);
      camera.quaternion.copy(quat);

      camera.updateMatrixWorld();
      orbit.enabled = false;
      /* ---------- set matching webcam frame as background ---------- */
      const name = key.replace('_pose', '');   // 'front_pose' → 'front'
      scene.background = viewTextures[name] ?? defaultBg;
      // Resize renderer to preserve image aspect; then apply calibrated frustum
      if (fitRendererToImage(name)) {
        currentCamName = name;
      } else {
        currentCamName = null;
        renderer.setSize(innerWidth, innerHeight);
        applyDefaultPerspective();
      }
    }

    const btnBar   = document.createElement('div');
    btnBar.style.position = 'fixed';
    btnBar.style.top = '8px';
    btnBar.style.left = '8px';
    btnBar.style.zIndex = 10;
    btnBar.style.display = 'flex';
    btnBar.style.gap = '4px';
    document.body.appendChild( btnBar );

    Object.keys(camPoses).forEach(poseKey=>{
      const b       = document.createElement('button');
      b.textContent = poseKey.split('_')[0]; // "left", "right", …
      b.onclick     = ()=> switchCamera(poseKey);
      btnBar.appendChild( b );
    });

    /* add orbit button */
    const orbitBtn = document.createElement('button');
    orbitBtn.textContent = 'orbit';
    orbitBtn.onclick = ()=> switchCamera('orbit');
    btnBar.appendChild(orbitBtn);

    /* add hide/show robot model button (bottom-left corner) */
    const toggleRobotBtn = document.createElement('button');
    toggleRobotBtn.textContent = 'hide robot model';
    toggleRobotBtn.style.position = 'fixed';
    toggleRobotBtn.style.left     = '8px';
    toggleRobotBtn.style.bottom   = '8px';
    toggleRobotBtn.style.zIndex   = 10;
    document.body.appendChild(toggleRobotBtn);

    toggleRobotBtn.onclick = () => {
      robotVisible = !robotVisible;
      robot.visible = robotVisible;
      toggleRobotBtn.textContent = robotVisible
        ? 'hide robot model'
        : 'show robot model';
    };

    /* ---------- confirm button (lower-right corner) ------------------- */
  const confirmBtn = document.createElement('button');
  confirmBtn.textContent   = 'confirm';
  confirmBtn.style.position = 'fixed';
  confirmBtn.style.right    = '8px';
  confirmBtn.style.bottom   = '8px';
  confirmBtn.style.zIndex   = 10;
  document.body.appendChild(confirmBtn);

  confirmBtn.onclick = async () => {
    /* gather current joint values (radians / metres) */
    const jointMap = {};
    Object.entries(robot.joints).forEach(([name, joint]) => {
      jointMap[name] = joint.jointValue;
    });

    /* gather current end-effector pose (world frame) */
    robot.updateMatrixWorld(true);             // ensure transforms are fresh
    const eePos  = new THREE.Vector3();
    const eeQuat = new THREE.Quaternion();
    eeVis.getWorldPosition   (eePos);
    eeVis.getWorldQuaternion (eeQuat);
    const eeEuler = new THREE.Euler().setFromQuaternion(eeQuat, "XYZ");

    try {
      await fetch('http://127.0.0.1:9000/api/submit-goal', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          joint_positions: jointMap,
          gripper:         gripDir,                // -1 / +1 / 0
          ee_pose: {                               // added  ⤵
            position:   [eePos.x,  eePos.y,  eePos.z],
            rpy: [eeEuler.x, eeEuler.y, eeEuler.z]
          }
        })
      });
      console.log('✅ goal sent');
    } catch (err) {
      console.error('❌ failed to send goal', err);
    }
  };

    /* --- visualise camera frusta ------------------------------ */
    Object.entries(camPoses).forEach(([key, mat])=>{
      const dummy = new THREE.PerspectiveCamera(56, 1, 0.1, 1000);
      dummy.matrix = poseToMatrix(mat);
      dummy.matrixAutoUpdate = false;
      dummy.updateMatrixWorld(true);
      const helper = new THREE.CameraHelper(dummy);
      scene.add(helper);
    });

    const spanDefs = [
      ['x',     0.20],   // meters
      ['y',     0.20],
      ['z',     0.20],
      ['roll',  0.61],   // radians
      ['pitch', 0.61],
      ['yaw',   0.61],
    ];

    spanDefs.forEach(([key, span])=>{
      if (!activeControls.includes(key)) return;
      const center = params[key];          // start-pose value
      gui.add(params, key, center - span, center + span)
         .onChange(updateGoal);
    });


    /* --- solver --- */
    const solver = new Solver(ikRoot);                // constructor takes root
    // (solver settings default to 5 iterations, etc.)

    /* --- animation loop --- */
    function animate() {
      requestAnimationFrame(animate);

      setIKFromUrdf(ikRoot, robot);   // URDF ➜ IK                                         :contentReference[oaicite:1]{index=1}
      solver.solve();                 // run DLS IK
      setUrdfFromIK(robot, ikRoot);   // IK ➜ URDF                                         :contentReference[oaicite:2]{index=2}

      // --- align the green line so its bottom sits on the ground ---
      eeVis.getWorldPosition(_eePosTmp);
      // Effective vertical length (Z-up), clamped to ≥ 0 with a small gap from the floor
      let len = _eePosTmp.z - (floorZ + bottomPad);
      if (len <= 0) {
        line.visible = false;             // EE at/below floor → hide
      } else {
        line.visible = true;
        // Scale along local Y (already rotated to world Z)
        line.scale.y = len / baseLineLen;
        // Center of cylinder should be midway between EE.z and floorZ+pad
        const midZ = (floorZ + bottomPad) + 0.5 * len;
        line.position.set(_eePosTmp.x + lineOffX, _eePosTmp.y, midZ);
      }
      renderer.render(scene, camera);
    }
    animate();
  }
);

/* ---------- responsive canvas ---------- */
addEventListener('resize', () => {
  if (currentCamName) {
    // Keep the camera image undistorted on window resizes
    fitRendererToImage(currentCamName);
  } else {
    renderer.setSize(innerWidth, innerHeight);
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
  }
});
</script></body></html>
