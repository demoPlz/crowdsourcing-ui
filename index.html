<!-- wxai_min.html  –  minimal translate-only IK demo -->
<!DOCTYPE html><html lang="en"><head>
<meta charset="utf-8" />
<title>WidowX AI — position IK only</title>
<style>html,body{margin:0;height:100%;overflow:hidden}</style>

<!-- Polyfill so the import-map works everywhere -->
<script async src="https://cdn.jsdelivr.net/npm/es-module-shims@2/dist/es-module-shims.js"></script>

<script type="importmap">
{
  "imports": {
    "three":               "https://cdn.jsdelivr.net/npm/three@0.165/build/three.module.js",
    "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.165/examples/jsm/",
    "urdf-loader":         "https://cdn.jsdelivr.net/npm/urdf-loader@0.12.6/src/URDFLoader.js?module",
    "closed-chain-ik":     "https://cdn.jsdelivr.net/npm/closed-chain-ik@0.18.0/dist/index.module.js"
  }
}
</script></head><body>
<script type="module">
/* ---------- imports ---------- */
import * as THREE                    from 'three';
import { OrbitControls }             from 'three/examples/jsm/controls/OrbitControls.js';
import URDFLoader                    from 'urdf-loader';
import {
  urdfRobotToIKRoot,
  setIKFromUrdf,
  setUrdfFromIK,
  Goal,
  Solver,
  DOF
} from 'closed-chain-ik';

import {GUI} from 'three/examples/jsm/libs/lil-gui.module.min.js';

async function getInitialState() {
  try {
    const response = await fetch('http://127.0.0.1:9000/api/get-state');
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return await response.json();
  } catch (error) {
    console.error("Could not fetch initial state:", error);
    return {};
  }
}

/* ---------- scene ---------- */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xf5f5f5);
scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1));

const dir = new THREE.DirectionalLight(0xffffff, 1.2);
dir.position.set(2, 4, 2);
scene.add(dir);

/* ---------- floor / workspace visual -------------------- */
// light, neutral grid on the ground (y = 0)
const grid = new THREE.GridHelper(
  2.0,   // size in meters
  20,    // subdivisions
  0x888888, // center line
  0xb0b0b0  // grid lines
);
grid.position.y = 0;          // align with ground plane
scene.add(grid);

const axes = new THREE.AxesHelper(0.3);
scene.add(axes);

const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.01, 100);
camera.position.set(1.5, 1.5, 1.5);

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
document.body.appendChild(renderer.domElement);

const orbit = new OrbitControls(camera, renderer.domElement);
orbit.target.set(0, 0, 0)
orbit.update();
orbit.saveState();

/* ---------- load URDF ---------- */
const loader = new URDFLoader();
loader.packages = {                 // map package:// paths → server paths
  'trossen_arm_description': 'assets/trossen_arm_description'
};

loader.load(
  'assets/trossen_arm_description/urdf/generated/wxai/wxai_base.urdf',
  async robot => {

    scene.add(robot);

    /* --- build IK tree from URDF (limits copied automatically) --- */
    const ikRoot = urdfRobotToIKRoot(robot);          // :contentReference[oaicite:0]{index=0}

    ikRoot.clearDoF()

    const state = await getInitialState();
    const initialJointPositions = state.joint_positions ?? {};
    for (const [name, val] of Object.entries(initialJointPositions)) {
      robot.setJointValue(name, val);
    }

    const camPoses = state.camera_poses ?? {}

    setIKFromUrdf(ikRoot, robot);
    ikRoot.updateMatrixWorld(true);

    /* --- locate the end-effector link inside IK tree --- */
    let ee = null;
    
    ikRoot.traverse(child => {                        // Frame.traverse
      if ( child.name === 'ee_gripper_link' ) { ee = child; return true; }
    });

    /* --- create a translation-only Goal --- */
    const goal = new Goal();
    goal.setDoF(DOF.X, DOF.Y, DOF.Z, DOF.EX, DOF.EY, DOF.EZ);

    goal.makeClosure( ee );                          // link goal ↔ ee

    /* ---- sample the **visual** EE pose after matrices are fresh */
    const startPos  = new THREE.Vector3();
    const startQuat = new THREE.Quaternion();

    robot.updateMatrixWorld( true );                 // propagate world mats
    const eeVis = robot.getObjectByName( 'ee_gripper_link' );
    eeVis.getWorldPosition   ( startPos  );
    eeVis.getWorldQuaternion ( startQuat );

    goal.setPosition   ( startPos.x, startPos.y, startPos.z );
    goal.setQuaternion ( startQuat.x, startQuat.y, startQuat.z, startQuat.w );

    /* ---- red sphere exactly at that pose ---------------------- */
    const marker = new THREE.Mesh(
      new THREE.SphereGeometry( 0.02, 16, 16 ),
      new THREE.MeshStandardMaterial( { color: 0xff0000 } )
    );
    marker.position.copy    ( startPos  );
    marker.quaternion.copy  ( startQuat );
    scene.add( marker );

    /* 2) build lil-GUI sliders ----------------------------------- */
    const startEuler = new THREE.Euler().setFromQuaternion(startQuat, 'XYZ');
    const params = {
      x: startPos.x, y: startPos.y, z: startPos.z,
      roll:  startEuler.x,
      pitch: startEuler.y,
      yaw:   startEuler.z
    };

    function updateGoal() {
      /* position */
      goal.setPosition(params.x, params.y, params.z);
      marker.position.set(params.x, params.y, params.z);

      /* orientation */
      const quat = new THREE.Quaternion().setFromEuler(
        new THREE.Euler(params.roll, params.pitch, params.yaw, 'XYZ')
      );
      goal.setQuaternion(quat.x, quat.y, quat.z, quat.w);
      marker.quaternion.copy(quat);
    }

    /* ---------- camera-view buttons --------------------------- */
    function poseToMatrix(mat){
      return new THREE.Matrix4().set(
        mat[0][0], mat[0][1], mat[0][2], mat[0][3],
        mat[1][0], mat[1][1], mat[1][2], mat[1][3],
        mat[2][0], mat[2][1], mat[2][2], mat[2][3],
        mat[3][0], mat[3][1], mat[3][2], mat[3][3],
      );
    }

    function switchCamera (key){
      if (key === 'orbit') {
        orbit.enabled = true;
        orbit.reset();
        return;
      }
      if (!camPoses[key]) return;
      const m = poseToMatrix( camPoses[key] );
      const pos   = new THREE.Vector3();
      const quat  = new THREE.Quaternion();
      const scale = new THREE.Vector3();
      m.decompose( pos, quat, scale );
      camera.position.copy( pos );
      camera.quaternion.copy( quat );
      camera.updateMatrixWorld();
      orbit.enabled = false;
    }

    const btnBar   = document.createElement('div');
    btnBar.style.position = 'fixed';
    btnBar.style.top = '8px';
    btnBar.style.left = '8px';
    btnBar.style.zIndex = 10;
    btnBar.style.display = 'flex';
    btnBar.style.gap = '4px';
    document.body.appendChild( btnBar );

    Object.keys(camPoses).forEach(key=>{
      const b       = document.createElement('button');
      b.textContent = key.split('_')[0]; // "left", "right", …
      b.onclick     = ()=> switchCamera(key);
      btnBar.appendChild( b );
    });

    /* add orbit button */
    const orbitBtn = document.createElement('button');
    orbitBtn.textContent = 'orbit';
    orbitBtn.onclick = ()=> switchCamera('orbit');
    btnBar.appendChild(orbitBtn);

    /* --- visualise camera frusta ------------------------------ */
    Object.entries(camPoses).forEach(([key, mat])=>{
      const dummy = new THREE.PerspectiveCamera(56, 1, 0.1, 1000);
      dummy.matrix = poseToMatrix(mat);
      dummy.matrixAutoUpdate = false;
      dummy.updateMatrixWorld(true);
      const helper = new THREE.CameraHelper(dummy);
      scene.add(helper);
    });

    const gui = new GUI();
    gui.add(params, 'x', 0.0, 0.60).onChange(updateGoal);
    gui.add(params, 'y',  -0.60, 0.60).onChange(updateGoal);
    gui.add(params, 'z', -0.60, 0.60).onChange(updateGoal);
    gui.add(params, 'roll',  -1.22, 1.22).onChange(updateGoal);
    gui.add(params, 'pitch', -1.22, 1.22).onChange(updateGoal);
    gui.add(params, 'yaw',   -1.22, 1.22).onChange(updateGoal);

    /* --- solver --- */
    const solver = new Solver(ikRoot);                // constructor takes root
    // (solver settings default to 5 iterations, etc.)

    /* --- animation loop --- */
    function animate() {
      requestAnimationFrame(animate);

      setIKFromUrdf(ikRoot, robot);   // URDF ➜ IK                                         :contentReference[oaicite:1]{index=1}
      solver.solve();                 // run DLS IK
      setUrdfFromIK(robot, ikRoot);   // IK ➜ URDF                                         :contentReference[oaicite:2]{index=2}

      renderer.render(scene, camera);
    }
    animate();
  }
);

/* ---------- responsive canvas ---------- */
addEventListener('resize', () => {
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script></body></html>
