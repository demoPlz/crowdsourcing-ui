<!-- wxai_min.html  ‚Äì  minimal translate-only IK demo -->
<!DOCTYPE html><html lang="en"><head>
<meta charset="utf-8" />
<title>WidowX AI - position IK only</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#f5f5f5}
  /* Multi-view container wrapper ‚Äì white card */
  #viewport{
    position:fixed; 
    top:50%; left:50%; 
    transform:translate(-50%, -50%);
    background: #ffffff;                 /* ‚¨ÖÔ∏è was #3b82f6 */
    border-radius: 12px;
    padding: 20px;
    box-shadow:0 4px 20px rgba(0,0,0,0.15);
    display: flex;
    flex-direction: column;
    gap: 16px;                            /* a touch tighter spacing */
    /* Make the card's width fixed (we set the pixel value from JS).
       border-box ensures the 20px padding on each side is INCLUDED in the fixed width. */
    box-sizing: border-box;
    /* These are set from JS; if not set, behaves like today */
    width: var(--viewport-total-px, auto);
    min-width: var(--viewport-total-px, auto);
    max-width: var(--viewport-total-px, none);
  }

  /* Blue prompt bar at the top */
  #viewport .prompt-bar{
    background: #3b82f6;                 /* blue */
    color: #ffffff;
    border-radius: 8px;
    padding: 12px 16px;
    position: relative;
  }

  
  /* Text prompt area */
  #viewport .prompt-text{
    color: white;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans";
    font-size: 18px;
    font-weight: 600;
    text-align: left;
    text-shadow: 0 2px 4px rgba(0,0,0,0.3);
    line-height: 1.4;
    min-height: auto;
    padding: 0;                     /* full width by default */
    margin: 0;
    /* Make long prompt lines wrap instead of widening the card */
    white-space: normal;          /* allow wrapping */
    overflow-wrap: anywhere;      /* break really long tokens (URLs/base64) */
    word-break: break-word;       /* Safari edge cases */
    hyphens: auto;                /* nice hyphenation in supported browsers */
  }

  /* Only reserve space when the example toggle is present */
  #viewport.has-example .prompt-text { padding-right: 50px; }

  /* Content container for views and controls */
  #viewport .content-container{
    display: flex;
    gap: 20px;
    align-items: center;
  }
  
  /* Grid container for camera views */
  #viewport .views-grid{
    display:grid; 
    gap:0px; 
    border-radius:4px;
    overflow:hidden;
    flex-shrink: 0;
  }

  /* Container for sliders with CAPTCHA styling */
  #viewport .controls-container{
    background: rgba(255, 255, 255, 0.95);
    border-radius: 8px;
    padding: 16px 16px 12px 16px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    border: 1px solid rgba(255,255,255,0.2);
    min-width: 200px;
    display: flex;
    flex-direction: column;
    gap: 20px;
  }

  /* Single slider layout (underneath views) */
  #viewport.single-slider{
    flex-direction: column;
  }
  #viewport.single-slider .content-container{
    flex-direction: column;
    align-items: center;
  }
  #viewport.single-slider .controls-container{
    align-self: center;
    max-width: 400px;
  }

  /* Multiple slider layout (to the right of views) */
  #viewport.multiple-sliders .content-container{
    flex-direction: row;
    align-items: center;
  }

  /* Position task completed container in multiple slider layout */
  #viewport.multiple-sliders .task-completed-container {
    margin-top: 12px;
    align-self: flex-start;
  }

  /* Position task completed container in single slider layout */
  #viewport.single-slider .task-completed-container {
    align-self: center;
    max-width: 400px;
    margin-top: 12px;
  }

  /* Style the lil-gui within controls container */
  .controls-container .lil-gui {
    --background-color: transparent;
    --widget-color: rgba(255,255,255,0.9);
    --hover-color: rgba(255,255,255,1);
    --focus-color: #3b82f6;
    --text-color: #374151;
    --text-color-disabled: #9ca3af;
    --border-color: rgba(0,0,0,0.1);
    --border-color-hover: rgba(0,0,0,0.2);
    border: none !important;
    box-shadow: none !important;
    font-size: 16px;
  }

  /* Hide any lil-gui title/header elements */
  .controls-container .lil-gui .title,
  .controls-container .lil-gui .lil-gui > .title {
    display: none !important;
  }

  .controls-container .lil-gui .controller {
    margin: 8px 0;
    height: 32px;
  }

  .controls-container .lil-gui .controller .name {
    font-size: 16px;
    font-weight: 500;
    min-width: 60px;
  }

  .controls-container .lil-gui .controller input[type="range"] {
    -webkit-appearance: none;
    appearance: none;
    background: linear-gradient(to right, #d1d5db 0%, #d1d5db 100%);
    border-radius: 8px;
    height: 16px;
    min-width: 140px;
    outline: none;
    border: 1px solid #9ca3af;
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
    pointer-events: auto !important;
    cursor: pointer;
  }

  /* Ensure calibration GUI sliders are interactive */
  .lil-gui input[type="range"] {
    pointer-events: auto !important;
    cursor: pointer;
    user-select: none;
  }

  /* Webkit slider thumb (Chrome, Safari, Edge) */
  .controls-container .lil-gui .controller input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 40px;
    height: 28px;
    background: linear-gradient(145deg, #cbd5e1 0%, #94a3b8 50%, #64748b 100%);
    border: 2px solid #475569;
    border-radius: 6px;
    cursor: pointer;
    box-shadow: 
      0 3px 8px rgba(0,0,0,0.4), 
      inset 0 1px 0 rgba(255,255,255,0.3);
    position: relative;
  }

  /* Firefox slider thumb */
  .controls-container .lil-gui .controller input[type="range"]::-moz-range-thumb {
    width: 40px;
    height: 28px;
    background: linear-gradient(145deg, #cbd5e1 0%, #94a3b8 50%, #64748b 100%);
    border: 2px solid #475569;
    border-radius: 6px;
    cursor: pointer;
    box-shadow: 
      0 3px 8px rgba(0,0,0,0.4), 
      inset 0 1px 0 rgba(255,255,255,0.3);
  }

  /* Hover effects */
  .controls-container .lil-gui .controller input[type="range"]::-webkit-slider-thumb:hover {
    background: linear-gradient(145deg, #e2e8f0 0%, #cbd5e1 50%, #94a3b8 100%);
    box-shadow: 
      0 4px 10px rgba(0,0,0,0.5), 
      inset 0 1px 0 rgba(255,255,255,0.5);
    border: 2px solid #334155;
  }

  .controls-container .lil-gui .controller input[type="range"]::-moz-range-thumb:hover {
    background: linear-gradient(145deg, #e2e8f0 0%, #cbd5e1 50%, #94a3b8 100%);
    box-shadow: 
      0 4px 10px rgba(0,0,0,0.5), 
      inset 0 1px 0 rgba(255,255,255,0.5);
    border: 2px solid #334155;
  }

  /* Track styling for Firefox */
  .controls-container .lil-gui .controller input[type="range"]::-moz-range-track {
    background: linear-gradient(to right, #d1d5db 0%, #d1d5db 100%);
    border-radius: 8px;
    height: 16px;
    border: 1px solid #9ca3af;
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
  }

  /* --- visual cue when the slider is exactly at the original center --- */
  .controls-container .lil-gui .controller input[type="range"].at-center::-webkit-slider-thumb {
    border-color: #3b82f6 !important;
    box-shadow:
      0 0 0 3px rgba(59,130,246,.25),
      0 3px 8px rgba(59,130,246,.35),
      inset 0 1px 0 rgba(255,255,255,.6) !important;
  }
  .controls-container .lil-gui .controller input[type="range"].at-center::-moz-range-thumb {
    border-color: #3b82f6 !important;
    box-shadow:
      0 0 0 3px rgba(59,130,246,.25),
      0 3px 8px rgba(59,130,246,.35),
      inset 0 1px 0 rgba(255,255,255,.6) !important;
  }

  /* Hide the number input/display by default */
  .controls-container .lil-gui .controller input[type="number"],
  .controls-container .lil-gui .controller .display {
    display: none !important;
  }

  /* Gripper button styling */
  .controls-container .gripper-section {
    margin: 0 0 12px 0;
  }

  .controls-container .gripper-label {
    font-size: 16px;
    font-weight: 500;
    color: #374151;
    margin-bottom: 8px;
    text-align: left;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans";
  }

  .controls-container .gripper-buttons {
    display: flex;
    gap: 8px;
    justify-content: center;
    margin: 0;
  }

  /* Reset button styling */
  .controls-container .lil-gui .controller .reset-btn {
    padding: 1px 0px;
    margin-left: 5px;
    border: 1px solid #d1d5db;
    background: #f3f4f6;
    border-radius: 1px;
    font-size: 8px;
    cursor: pointer;
    transition: background 0.2s ease;
    color: #374151;
    width: 30px;
    height: 20px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    user-select: none;
  }

  .controls-container .lil-gui .controller .reset-btn:hover {
    background: #e5e7eb;
    border-color: #9ca3af;
  }

  .controls-container .lil-gui .controller .reset-btn:active {
    background: #d1d5db;
  }

  .controls-container .gripper-buttons button,
  .controls-container .confirm-button {
    padding: 8px 16px;
    border: none;
    border-radius: 6px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    text-transform: capitalize;
  }

  .controls-container .gripper-buttons button.open-btn {
    background: #10b981;
    color: white;
    flex: 1;
  }

  .controls-container .gripper-buttons button.close-btn {
    background: #ef4444;
    color: white;
    flex: 1;
  }

  /* Inactive gripper button states */
  .controls-container .gripper-buttons button.open-btn.inactive {
    background: #e5e7eb;
    color: #6b7280;
    border: 2px solid #d1d5db;
  }

  .controls-container .gripper-buttons button.close-btn.inactive {
    background: #e5e7eb;
    color: #6b7280;
    border: 2px solid #d1d5db;
  }

  /* Active gripper button states (enhanced) */
  .controls-container .gripper-buttons button.open-btn.active {
    background: #10b981;
    color: white;
    border: 2px solid #059669;
    box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.2);
  }

  .controls-container .gripper-buttons button.close-btn.active {
    background: #ef4444;
    color: white;
    border: 2px solid #dc2626;
    box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.2);
  }

  .controls-container .confirm-button {
    background: #3b82f6;
    color: white;
    width: 100%;
    font-size: 16px;
    font-weight: 600;
    padding: 12px 16px;
  }

  /* Task Already Completed button styling */
  .task-completed-container {
    background: rgba(255, 255, 255, 0.95);
    border-radius: 8px;
    padding: 16px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    border: 1px solid rgba(255,255,255,0.2);
    min-width: 200px;
    align-self: flex-start;
  }

  /* Task Already Completed - explicit inactive/active states (parity with gripper buttons) */
  .controls-container .task-completed-button {
    background: #fbbf24;        /* lighter orange when NOT selected */
    color: #ffffff;
    width: 100%;
    box-sizing: border-box;      /* borders won't change width/height */
    font-size: 14px;
    font-weight: 600;
    padding: 10px 16px;
    border-radius: 6px;
    border: 2px solid transparent;  /* reserve space in ALL states */
    cursor: pointer;
    opacity: .85;
    transition: all .15s ease;
    margin-bottom: 12px;
  }

  /* Hover (unchanged) */
  .controls-container .task-completed-button:hover {
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(245, 158, 11, 0.30);
    opacity: 1;
  }

  /* Selected */
  .controls-container .task-completed-button.active {
    background: #f59e0b;
    /* keep the same 2px border thickness so size doesn't change */
    border-color: transparent;
    box-shadow: 0 0 0 3px rgba(245, 158, 11, 0.25), 0 8px 18px rgba(0,0,0,.18);
    opacity: 1;
  }

  /* Explicit unselected */
  .controls-container .task-completed-button.inactive {
    background: #fbbf24;
    color: #ffffff;
    border-color: transparent;   /* DO NOT remove the border */
    box-shadow: none;
    opacity: .85;
  }

  /* Disabled / blocked */
  .controls-container .task-completed-button:disabled {
    background: #e5e7eb;
    color: #9ca3af;
    border: 2px dashed #d1d5db;  /* same thickness as base ‚Üí same size */
    cursor: not-allowed;
    box-shadow: none;
    transform: none;
    opacity: 1;
  }


  .controls-container button:hover {
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    transition: all 0.2s ease;
  }

  .controls-container button:active {
    transform: translateY(0);
  }

  .view-container{
    position:relative;
    display:grid;
    place-items:center;
    overflow:hidden;
  }
  .view-container.selected{border:2px solid #60a5fa;box-shadow:0 0 15px rgba(96,165,250,.6)}
  canvas{display:block;object-fit:cover;width:100%;height:100%}
  /* (no width/height forcing on canvas; renderer controls it) */
 /* --- nice full-screen status overlay + spinner --- */
  #statusOverlay{
    position:fixed; inset:0; display:none; place-items:center;
    background: radial-gradient(1200px 800px at 50% 30%, #111827 0%, #0b0d12 60%, #000 100%);
    color:#e5e7eb; padding:24px; text-align:center;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
  }
  #statusOverlay .card{
    max-width: 720px; width: min(92vw, 720px);
    background: rgba(17,24,39,0.55);
    border: 1px solid rgba(255,255,255,0.08);
    box-shadow: 0 10px 30px rgba(0,0,0,0.5), inset 0 1px 0 rgba(255,255,255,0.04);
    border-radius: 20px; padding: 26px 28px;
    backdrop-filter: blur(8px);
  }
  #statusOverlay .title{ font-size:20px; letter-spacing:.02em; margin:0 0 8px }
  #statusOverlay .msg  { font-size:16px; line-height:1.5; opacity:.9; margin:0 }
  #statusOverlay .row  { display:flex; align-items:center; gap:14px; justify-content:center; margin-bottom:10px }
  #statusOverlay .spinner{
    width:22px; height:22px; border-radius:50%;
    border:3px solid rgba(255,255,255,.25);
    border-top-color:#60a5fa; border-right-color:#93c5fd;
    animation: spin 1s linear infinite;
    box-shadow: 0 0 20px rgba(96,165,250,.35);
  }
  @keyframes spin{ to { transform: rotate(360deg); } }

  /* Disabled gripper buttons look inert + show not-allowed cursor */
  .controls-container .gripper-buttons button:disabled {
    background: #e5e7eb;
    color: #9ca3af;
    border: 2px dashed #d1d5db;
    cursor: not-allowed;
    box-shadow: none;
  }

  /* Animate button styling */
  .controls-container .animate-button {
    background: #f65c5c;
    color: white;
    width: 100%;
    font-size: 15px;
    font-weight: 600;
    padding: 10px 16px;
    border-radius: 6px;
    border: none;
    cursor: pointer;
    opacity: .85;
    transition: all .15s ease;
    margin-bottom: 12px; /* ‚Üê add a bit of breathing room */
  }
  .controls-container .animate-button:hover {
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(139, 92, 246, .35);
    opacity: 1;
  }
  .controls-container .animate-button.active {
    background: #ed3a3a; /* brighter while active */
    box-shadow: 0 0 0 3px rgba(124, 58, 237, .25), 0 8px 18px rgba(0,0,0,.18);
    opacity: 1;
  }

  .controls-container .task-completed-button { 
    margin-bottom: 12px; /* matches .animate-button‚Äôs bottom margin */
    font-weight: 600;
  }

  /* --- disabled slider look --- */
  .controls-container .lil-gui .controller input[type="range"]:disabled {
    opacity: 0.55;
    cursor: not-allowed;
  }
  .controls-container .lil-gui .controller .reset-btn:disabled {
    opacity: 0.55;
    cursor: not-allowed;
  }

  .controls-container .lil-gui.locked {
    opacity: 0.75;
  }
    
  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.6; }
  }

  /* --- Gripper force widget -------------------------------------------------- */
  .controls-container .force-widget{
    background: #ffffff;
    border: 1px solid #e5e7eb;
    border-radius: 8px;
    padding: 10px 12px;
    box-shadow: 0 1px 4px rgba(0,0,0,.06);
    display: flex; flex-direction: column; gap: 8px;
  }
  .controls-container .force-row{
    display:flex; justify-content:space-between; align-items:center;
    font: 600 13px / 1.2 system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
    color:#374151;
  }
  .controls-container .force-pill{
    padding: 4px 8px; border-radius: 999px; font-weight: 700; color: #fff;
  }
  .controls-container .force-pill.free{     background:#9ca3af; }
  .controls-container .force-pill.contact{  background:#f59e0b; }
  .controls-container .force-pill.grasped{  background:#22c55e; }
  .controls-container .force-bar{ height:8px; width:100%; background:#e5e7eb; border-radius:999px; overflow:hidden; }
  .controls-container .force-bar .fill{
    height:100%; width:0%;
    background:linear-gradient(90deg, #60a5fa, #1d4ed8);
    transition: width .25s ease;
  }

  /* optional: subtle pulse when grasped */
  @keyframes forcePulse { 0%,100%{opacity:.95} 50%{opacity:.6} }

  .controls-container .force-bar {
    margin-top: 12px;  /* adjust to taste: 12‚Äì16px works nicely */
  }

  /* Reset All button (same rhythm as Animate / TAC) */
  .controls-container .reset-all-button{
    background:#22c55e;          /* green */
    color:#ffffff;
    width:100%;
    font-size:15px;
    font-weight:600;
    padding:10px 16px;
    border-radius:6px;
    border:1px solid #16a34a;    /* darker green edge */
    margin-bottom:12px;           /* same cadence as others */
    cursor:pointer;               /* show hand cursor */
  }

  .controls-container .reset-all-button:hover{
    transform:translateY(-1px);
    box-shadow:0 2px 8px rgba(34,197,94,.30);
  }

  .controls-container .reset-all-button:active{
    transform:translateY(0);
    filter:brightness(.95);
  }

  /* Accessible focus ring to match the green theme */
  .controls-container .reset-all-button:focus{
    outline:none;
    box-shadow:0 0 0 3px rgba(34,197,94,.25), 0 2px 8px rgba(0,0,0,.15);
  }

  /* Optional: disabled state if you ever disable it */
  .controls-container .reset-all-button:disabled{
    background:#e5e7eb;
    color:#9ca3af;
    border:1px dashed #d1d5db;
    cursor:not-allowed;
    box-shadow:none;
    transform:none;
  }

  /* === In-view Grip HUD (glass) ============================================= */
  .view-container .grip-hud{
    position:absolute;
    z-index:2;
    transform:translate(-50%,-50%);
    /* force a vertical stack regardless of earlier rules */
    display:flex !important;
    flex-direction:column !important;
    align-items:center !important;
    gap:6px !important;

    padding:8px 10px;
    border-radius:14px;
    background: linear-gradient(135deg, rgba(255,255,255,.28), rgba(255,255,255,.12));
    border: 1px solid rgba(255,255,255,.35);
    box-shadow: 0 8px 24px rgba(0,0,0,.20);
    backdrop-filter: blur(14px) saturate(1.2);
    -webkit-backdrop-filter: blur(14px) saturate(1.2);
    color:#111827;
    user-select:none;
    pointer-events:auto;
    transition: transform .15s ease, box-shadow .15s ease, opacity .15s ease;
    opacity:.92;
  }

  .view-container .grip-hud .badge,
  .view-container .grip-hud .toggle{
    display:block !important;   /* ensure each occupies its own row */
  }

  .view-container .grip-hud:hover{
    transform:translate(-50%,-50%) translateY(-1px);
    box-shadow: 0 14px 32px rgba(0,0,0,.26);
    opacity:1;
  }

  .view-container .grip-hud .badge{
    padding:4px 8px;
    border-radius:999px;
    font:700 11px/1 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, "Helvetica Neue", Arial;
    color:#fff;
    text-transform: none;
    white-space:nowrap;
  }
  .view-container .grip-hud .badge.free    { background:#22c55e; }  /* green */
  .view-container .grip-hud .badge.contact { background:#f59e0b; }  /* amber */
  .view-container .grip-hud .badge.grasped { background:#ef4444; }  /* red */

  .view-container .grip-hud .toggle{
    appearance:none; border:0; border-radius:9px;
    padding:6px 10px;
    min-width:67px;
    font:700 12px/1 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, "Helvetica Neue", Arial;
    color:#fff; cursor:pointer;
    transition: transform .12s ease, box-shadow .12s ease, filter .12s ease, background .12s ease;
    box-shadow: 0 2px 10px rgba(0,0,0,.20);
    border:1px solid transparent;
  }
  .view-container .grip-hud .toggle:hover{ transform: translateY(-1px); }
  .view-container .grip-hud .toggle:active{ transform: translateY(0); }

  /* Toggle tints (current commanded state) */
  .view-container .grip-hud .toggle.open {
    background:#3b82f6;              /* blue */
    border-color:#2563eb;
  }
  .view-container .grip-hud .toggle.close{
    background:#3b82f6;              /* blue */
    border-color:#2563eb;
  }

  /* Disabled gating */
  .view-container .grip-hud.disabled{
    opacity:.85;
    cursor:not-allowed;
    box-shadow: 0 6px 18px rgba(0,0,0,.14);
  }
  .view-container .grip-hud.disabled .toggle{
    background: rgba(255,255,255,.55);
    color:#6b7280;
    border:1px dashed #d1d5db;
    cursor:not-allowed;
    box-shadow:none;
  }

  /* In-view Pose Reset (lower-right) and Home HUD (lower-left) - liquid glass look */
  .view-container .pose-reset,
  .view-container .home-hud{
    position: absolute;
    z-index: 3;
    transform: translate(-50%, -50%); /* center on the computed anchor point */
    display: inline-flex;
    align-items: center;
    justify-content: center;

    width: 28px;
    height: 28px;

    /* liquid glass (match grip HUD) */
    background: linear-gradient(135deg, rgba(255,255,255,.28), rgba(255,255,255,.12));
    border: 1px solid rgba(255,255,255,.35);
    box-shadow: 0 8px 24px rgba(0,0,0,.20);
    backdrop-filter: blur(14px) saturate(1.2);
    -webkit-backdrop-filter: blur(14px) saturate(1.2);
    color: #111827;
    opacity: .92;

    border-radius: 14px;            /* same rounding as the grip HUD */
    font: 700 14px/1 system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
    cursor: pointer;
    pointer-events: auto;
    user-select: none;
    transition: transform .12s ease, box-shadow .12s ease, background .12s ease, opacity .12s ease, filter .12s ease;
  }

  /* Ensure SVG icons are perfectly centered */
  .view-container .pose-reset svg,
  .view-container .home-hud svg {
    display: block;
    margin: 0 auto;
  }

  .view-container .pose-reset:hover,
  .view-container .home-hud:hover{
    transform: translate(-50%, -50%) translateY(-1px);
    box-shadow: 0 12px 28px rgba(0,0,0,.26);
    opacity: 1;
  }

  .view-container .pose-reset:active,
  .view-container .home-hud:active{
    transform: translate(-50%, -50%) translateY(0);
    filter: brightness(.98);
  }

  .view-container .pose-reset[disabled],
  .view-container .home-hud[disabled]{
    opacity: .6;
    cursor: not-allowed;
    box-shadow: none;
    /* keep glass off when disabled to communicate state clearly */
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
  }

  /* Keep Confirm prominent; pin it lower-right in the controls column */
  .controls-container .confirm-button {
    position: sticky;   /* stays visible at the end of the column */
    bottom: 0;
  }

  /* TAC next to Confirm: compact pill */
  .controls-container .tac-inline {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    margin: 8px 0 6px 0;
  }
  .controls-container .tac-toggle {
    background: #fbbf24;
    color: #fff;
    border: 2px solid transparent;
    border-radius: 999px;
    padding: 8px 12px;
    font: 700 13px/1 system-ui, -apple-system, Segoe UI, Roboto;
    cursor: pointer;
    transition: box-shadow .15s ease, transform .12s ease;
  }
  .controls-container .tac-toggle.active {
    background: #f59e0b;
    box-shadow: 0 0 0 3px rgba(245,158,11,.25);
  }
  .controls-container .tac-toggle:disabled {
    background: #e5e7eb; color: #9ca3af; border-style: dashed; cursor: not-allowed;
  }

  /* Confirm bar under the views (lower-right) */
  #viewport .button-bars-container{
    display: flex;
    justify-content: space-between;
    align-items: flex-end;
  }

  #viewport .confirm-bar{
    display:flex;
    justify-content:flex-end;
  }

  #viewport .confirm-bar .confirm-button{
    background:#3b82f6;
    color:#fff;
    border:none;
    border-radius:6px;
    padding:12px 16px;
    font-size:16px;
    font-weight:600;
    cursor:pointer;
    transition:all .2s ease;
  }

  #viewport .confirm-bar .confirm-button:hover{
    transform:translateY(-1px);
    box-shadow:0 2px 8px rgba(0,0,0,.15);
  }

  #viewport .confirm-bar .confirm-button:active{
    transform:translateY(0);
  }

  #viewport .confirm-bar .confirm-button:disabled{
    background:#9ca3af;
    color:#6b7280;
    cursor:not-allowed;
    opacity:0.6;
    transform:none;
  }

  #viewport .confirm-bar .confirm-button:disabled:hover{
    transform:none;
    box-shadow:none;
  }

/* Confirm bar: place Animate to the left of Confirm with a little space */
#viewport .confirm-bar{
  display:flex;
  justify-content:flex-end;
  gap: 8px;               /* ‚Üê new: spacing between Animate and Confirm */
}

/* Buttons that match the Confirm look */
#viewport .confirm-bar .animate-button{
  color:#fff;
  border:none;
  border-radius:6px;
  padding:12px 16px;
  font-size:16px;
  font-weight:600;
  cursor:pointer;
  transition:all .2s ease;
}

/* Light orange Animate (lower-right, left of Confirm) */
#viewport .confirm-bar .animate-button{
  background:#fb923c; /* orange-400 - light orange */
}

#viewport .confirm-bar .animate-button:hover{
  transform:translateY(-1px);
  box-shadow:0 2px 8px rgba(0,0,0,.15);
}
#viewport .confirm-bar .animate-button:active{
  transform:translateY(0);
}

/* Darker orange when activated/playing */
#viewport .confirm-bar .animate-button.active{
  background:#ea580c; /* orange-600 - darker orange */
  box-shadow:0 0 0 3px rgba(234,88,12,.25), 0 2px 8px rgba(0,0,0,.15);
}

/* Square corners stay enforced globally (already covered by your blanket rule),
   but include these explicitly in case you keep per-button overrides elsewhere. */
#viewport .confirm-bar .animate-button,
#viewport .reset-bar .reset-button{
  border-radius:0 !important;
}

/* Reset bar (lower-left, standalone like confirm bar) */
#viewport .reset-bar{
  display:flex;
  justify-content:flex-start;
}

/* Reset button styling (standalone, matching Animate and Confirm) */
#viewport .reset-bar .reset-button{
  background:#9ca3af; /* gray-400 - lighter gray */
  color:#fff;
  border:none;
  border-radius:6px;
  padding:12px 16px;
  font-size:16px;
  font-weight:600;
  cursor:pointer;
  transition:all .2s ease;
}

#viewport .reset-bar .reset-button:hover{
  transform:translateY(-1px);
  box-shadow:0 2px 8px rgba(0,0,0,.15);
}

#viewport .reset-bar .reset-button:active{
  transform:translateY(0);
}

  /* --- Full-bleed blue header inside the #viewport card --- */
  #viewport .prompt-bar{
    /* cancel the card's 20px padding on the top & sides */
    margin: -20px -20px 0 -20px;
    border-radius: 0; /* square corners */
  }

  /* --- Square corners (90¬∞) across the UI --- */
  #viewport,
  #viewport .prompt-bar,
  #viewport .content-container,
  #viewport .controls-container,
  #viewport .task-completed-container,
  #statusOverlay .card,
  #viewport .confirm-bar .confirm-button,    /* lower-right Confirm */
  #viewport .reset-bar .reset-button,        /* lower-left Reset */
  .controls-container .gripper-buttons button,
  .controls-container .confirm-button,       /* controls confirm */
  .controls-container .tac-toggle,
  .controls-container .task-completed-button,
  .controls-container .animate-button,
  .controls-container .reset-all-button,
  .controls-container .force-widget,
  .controls-container .force-pill,
  .controls-container .lil-gui .controller input[type="range"],
  .controls-container .lil-gui .controller input[type="range"]::-webkit-slider-thumb,
  .controls-container .lil-gui .controller input[type="range"]::-moz-range-thumb {
    border-radius: 0 !important;
  }

  /* === Force square corners everywhere you asked (place LAST in <style>) === */

  /* Square the white card itself (all four corners) */
  #viewport {
    border-radius: 0 !important;
    border-top-left-radius: 0 !important;
    border-top-right-radius: 0 !important;
    border-bottom-left-radius: 0 !important;
    border-bottom-right-radius: 0 !important;
  }

  /* Square the lower-right Confirm button (and its bar) */
  #viewport .confirm-bar,
  #viewport .confirm-bar .confirm-button,
  .controls-container .confirm-button {
    border-radius: 0 !important;
    border-top-left-radius: 0 !important;
    border-top-right-radius: 0 !important;
    border-bottom-left-radius: 0 !important;
    border-bottom-right-radius: 0 !important;
  }

  /* Belt-and-suspenders: catch any other buttons in those bars */
  #viewport .confirm-bar button,
  #viewport .reset-bar button {
    border-radius: 0 !important;
  }

  /* === Keep the gripper HUD rounded (unchanged) === */
  .view-container .grip-hud {
    border-radius: 14px !important;          /* as designed */
  }
  .view-container .grip-hud .toggle {
    border-radius: 9px !important;
  }
  .view-container .grip-hud .badge {
    border-radius: 999px !important;
  }

  /* Segmentation overlay sits over the camera texture and moves with the gripper */

  /* === Recording UI (cursor & indicator) ================================== */
  :root { --rec-accent: #ef4444; } /* red-500 */

  /* Record-only wrapper */
  #recordRegion{
    position: relative;           /* anchor overlays inside the recording */
    overflow: hidden;             /* no spillover */
    display: flex;                /* maintain layout structure */
    flex-direction: column;       /* stack content and button bars vertically */
    gap: 16px;                    /* same gap as original viewport */
  }

  /* While recording, hide OS cursor only inside the recorded region */
  body.recording #recordRegion, 
  body.recording #recordRegion * {
    cursor: none !important;
  }

  /* Make the big cursor local to the recorded region */
  #recordRegion #bigCursor{
    position: absolute;           /* was: fixed */
    left: 0; top: 0;
    width: 32px; height: 32px;
    margin-left: -16px; margin-top: -16px;
    pointer-events: none; z-index: 10003; display: none;
  }
  #recordRegion #bigCursor .ring{
    position:absolute; inset:0;
    border: 3px solid #fff; border-radius: 50%;
    box-shadow: 0 0 0 2px rgba(0,0,0,.9), 0 0 12px rgba(0,0,0,.35);
    background: rgba(255,255,255,.04);
  }
  #recordRegion #bigCursor .dot{
    position:absolute; left:50%; top:50%; width:6px; height:6px;
    transform: translate(-50%, -50%);
    border-radius: 50%;
    background: #111827;
    box-shadow: 0 0 0 2px #fff, 0 0 0 4px rgba(0,0,0,.9);
  }
  #recordRegion #bigCursor.active { transform: scale(.92); }
  #recordRegion #bigCursor.click  { animation: clickFlash .18s ease; }

  #recordRegion #recIndicator{
    position: absolute; top: 8px; left: 8px;
    display: none; align-items: center; gap: 8px;
    padding: 6px 10px;
    background: rgba(0,0,0,.55); color: #fff;
    font: 600 13px/1 system-ui, -apple-system, Segoe UI, Roboto;
    border: 1px solid rgba(255,255,255,.15);
    box-shadow: 0 6px 18px rgba(0,0,0,.35);
    z-index: 10002;
  }
  #recordRegion #recIndicator.visible { display: inline-flex; }
  #recordRegion #recIndicator .dot{
    width: 10px; height: 10px; border-radius: 50%;
    background: var(--rec-accent, #ef4444);
    box-shadow: 0 0 0 2px rgba(239,68,68,.35);
    animation: recPulse 1.2s ease-in-out infinite;
  }
  @keyframes recPulse { 0%,100%{ transform: scale(1); opacity: 1 } 50%{ transform: scale(0.7); opacity: .6 } }

  /* Legacy fallback styles for browsers without region capture */
  #bigCursor{
    position: fixed; left: 0; top: 0;
    width: 32px; height: 32px;
    margin-left: -16px; margin-top: -16px;
    pointer-events: none; z-index: 10003; display: none;
  }
  #bigCursor .ring{
    position:absolute; inset:0;
    border: 3px solid #fff; border-radius: 50%;
    box-shadow: 0 0 0 2px rgba(0,0,0,.9), 0 0 12px rgba(0,0,0,.35);
    background: rgba(255,255,255,.04);
  }
  #bigCursor .dot{
    position:absolute; left:50%; top:50%; width:6px; height:6px;
    transform: translate(-50%, -50%);
    border-radius: 50%;
    background: #111827;
    box-shadow: 0 0 0 2px #fff, 0 0 0 4px rgba(0,0,0,.9);
  }
  #bigCursor.active { transform: scale(.92); }
  #bigCursor.click { animation: clickFlash .18s ease; }
  @keyframes clickFlash { 0% { filter: brightness(1.35); } 100% { filter: brightness(1); } }

  /* Preflight hint (before browser share picker) */
  #recPreflight{
    position: fixed; inset: 0; display: none; place-items: center;
    z-index: 10004; background: rgba(0,0,0,.55);
  }
  #recPreflight.visible{ display: grid; }
  #recPreflight .card{
    max-width: 520px; width: min(92vw, 520px);
    background: rgba(17,24,39,.9); color:#e5e7eb;
    padding: 16px 18px; border: 1px solid rgba(255,255,255,.08);
    box-shadow: 0 12px 32px rgba(0,0,0,.5);
    border-radius: 12px; text-align: left;
    font: 500 14px/1.5 system-ui, -apple-system, Segoe UI, Roboto;
  }
  #recPreflight .title{ font-weight:700; margin:0 0 6px; font-size: 16px; }
  #recPreflight .hint { opacity:.9 }

/* === Mini Recording UI (shown only when --record-demo-videos is on) === */
#recMini{
  position: fixed;
  right: 12px; bottom: 12px;
  display: none;                 /* toggled by JS -> .visible */
  align-items: center; gap: 8px;
  padding: 8px 10px;
  background: rgba(17,24,39,0.92);
  color: #fff;
  border: 1px solid rgba(255,255,255,0.12);
  box-shadow: 0 8px 24px rgba(0,0,0,.35);
  z-index: 10006;
  font: 600 13px/1.1 system-ui, -apple-system, Segoe UI, Roboto;
  border-radius: 0 !important;   /* square corners to match your theme */
}
#recMini.visible { display: inline-flex; }
#recMini .dot{
  width: 10px; height: 10px; border-radius: 50%;
  background: #9ca3af; box-shadow: 0 0 0 2px rgba(255,255,255,.18);
}
#recMini .dot.recording{
  background: var(--rec-accent, #ef4444);
  animation: recPulse 1.2s ease-in-out infinite;
}
#recMini .state{ text-transform: uppercase; font-weight: 800; letter-spacing: .02em; opacity:.9; }
#recMini .time{ min-width: 52px; text-align: right; opacity:.9; }
#recMini .btn{
  appearance: none;
  border: 1px solid rgba(255,255,255,0.18);
  background: rgba(255,255,255,0.04);
  color: #fff;
  padding: 6px 8px;
  font: 700 13px / 1 system-ui, -apple-system, Segoe UI, Roboto;
  cursor: pointer;
  border-radius: 0 !important;
}
#recMini .btn[disabled]{ opacity:.5; cursor:not-allowed; border-style: dashed; }
#recMini .btn:hover:not([disabled]){ transform: translateY(-1px); box-shadow: 0 2px 8px rgba(0,0,0,.2); }
#recMini .btn:active:not([disabled]){ transform: translateY(0); }
#recMini .saved-badge{ margin-left: 4px; font-weight: 700; opacity: .9; display: none; }
#recMini.saved .saved-badge{ display: inline; }

/* --- Example video toggle + dock ----------------------------------------- */

/* Keyframe animation for pulsing effect - optimized for performance */
@keyframes pulse-glow {
  0% { 
    opacity: 0.8;
    transform: translateY(-50%) scale(1);
  }
  50% { 
    opacity: 1;
    transform: translateY(-50%) scale(1.05);
  }
  100% { 
    opacity: 0.8;
    transform: translateY(-50%) scale(1);
  }
}

/* the information glyph button on the prompt bar (center-right) */
.prompt-example-toggle{
  position: absolute;
  right: 12px;
  top: 50%;
  transform: translateY(-50%);
  width: auto; height: auto;
  display: inline-flex; 
  align-items: center;
  justify-content: center;
  background: transparent;
  border: none;
  color: #ffffff;
  font-size: 20px;
  cursor: pointer; 
  user-select: none;
  padding: 4px;
  transition: all 0.2s ease;
}

/* Only pulse when never activated and not during interaction */
.prompt-example-toggle.never-activated{
  animation: pulse-glow 1.2s ease-in-out infinite;
}

/* Pause animation during interaction for performance */
.prompt-example-toggle.never-activated.paused{
  animation-play-state: paused;
}

.prompt-example-toggle:hover{ 
  color: rgba(255,255,255,0.8); 
  transform: translateY(-50%) scale(1.1);
  animation: none; /* Stop pulsing on hover */
}
.prompt-example-toggle:active{ 
  transform: translateY(-50%) scale(0.95); 
  animation: none; /* Stop pulsing when clicked */
}
.prompt-example-toggle[disabled]{ 
  opacity:.5; 
  cursor:not-allowed;
  animation: none; /* Stop pulsing when disabled */
}
.prompt-example-toggle.active{
  color: rgba(255,255,255,1);
  filter: drop-shadow(0 0 8px rgba(255,255,255,0.4));
  background: rgba(255,255,255,0.3);
  border-color: rgba(255,255,255,0.5);
  animation: none; /* Stop pulsing when active */
}

/* the independent right-side video window */
#exampleDock{
  position: fixed;
  display: none;                 /* toggled by JS */
  background: #ffffff;
  border: 1px solid rgba(0,0,0,0.08);
  box-shadow: 0 10px 30px rgba(0,0,0,0.15);
  z-index: 10005;                /* above the card */
  overflow: hidden;
  padding: 12px;                 /* padding inside the white box */
}

#exampleDock video{
  display: block;
  width: 100%; height: 100%;
  object-fit: cover;             /* or 'contain' if you prefer letterboxing */
  background: #000;
}
#exampleDock .placeholder{
  width: 100%; height: 100%;
  display: flex; align-items: center; justify-content: center;
  font: 600 14px system-ui, -apple-system, Segoe UI, Roboto, Arial;
  color: #6b7280;
  background: #0b0d12;
}


</style>

<!-- Polyfill so the import-map works everywhere -->
<script async src="https://cdn.jsdelivr.net/npm/es-module-shims@2/dist/es-module-shims.js"></script>

<script type="importmap">
{
  "imports": {
    "three":               "https://cdn.jsdelivr.net/npm/three@0.165/build/three.module.js",
    "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.165/examples/jsm/",
    "urdf-loader":         "https://cdn.jsdelivr.net/npm/urdf-loader@0.12.6/src/URDFLoader.js?module",
    "closed-chain-ik":     "https://cdn.jsdelivr.net/npm/closed-chain-ik@0.18.0/dist/index.module.js"
  }
}
</script></head><body>
  <!-- Centering mount for the WebGL canvas; avoids CSS stretching -->
  <div id="viewport"></div>
<script type="module">

// === High-quality recording profile ==========================================
const HQ_REC = {
  // Render more frames so motion & pointer look smooth
  fps: 60,

  // Pixel up-scale for the compositor (independent from the on-screen UI size)
  // Final recorded size = layout.W√ólayout.H, then multiplied by this effective scale.
  baseScale: 2.0,

  // Output size targets/caps. We scale up to at least ~1080p if the layout allows.
  targetWidth: 1920,      // aim for ‚â•1080p width
  maxWidth:   2560,       // safety caps (‚âà1440p when aspect isn't 16:9)
  maxHeight:  1440,

  // VP9-only codec preferences (better browser compatibility)
  codecPrefs: [
    'video/webm;codecs=vp9',            // VP9 (excellent browser support)
    'video/webm;codecs=vp8',            // VP8 (universal fallback)
    'video/webm'
  ],

  // Bitrate ladder (scale with output area). Adjust to taste.
  bitrateFor(w, h) {
    const px = w * h;
    if (px >= 2560*1440) return 22_000_000;  // ~22 Mbps for QHD
    if (px >= 1920*1080) return 16_000_000;  // 16 Mbps for 1080p
    if (px >= 1280*720 ) return 10_000_000;  // 10 Mbps for 720p
    return 8_000_000;                         // smaller canvases
  }
};
// ============================================================================

/* ---------- stable per-browser session id + fetch helper ---------- */
const SID_STORAGE_KEY = 'crowd_sid';
function getStableSID() {
  try {
    const existing = localStorage.getItem(SID_STORAGE_KEY);
    if (existing) return existing;
  } catch (_) { /* localStorage blocked? proceed with ephemeral */ }

  let sid;
  try {
    sid = (crypto && crypto.randomUUID) ? crypto.randomUUID() : null;
  } catch (_) { sid = null; }
  if (!sid) sid = 'sid-' + Math.random().toString(36).slice(2) + '-' + Date.now();

  try { localStorage.setItem(SID_STORAGE_KEY, sid); } catch (_) {}
  return sid;
}
const SID = getStableSID();
console.log('[SID]', SID);

/** Like fetch(), but always sends X-Session-ID and expands relative API paths */
function apiFetch(path, options = {}) {
  const url = path.startsWith('http') ? path : `${API_BASE_URL}${path}`;
  const headers = { ...(options.headers || {}), 'X-Session-ID': SID };
  return fetch(url, { ...options, headers });
}

/* ---------- imports ---------- */
import * as THREE                    from 'three';
import URDFLoader                    from 'urdf-loader';

import {
  urdfRobotToIKRoot,
  setIKFromUrdf,
  setUrdfFromIK,
  Goal,
  Solver,
  DOF
} from 'closed-chain-ik';

// Simple API Configuration - use appropriate proxy based on environment
async function getCurrentCloudflaredUrl() {
  try {
    // For production (Netlify), always use the function proxy to avoid CORS issues
    if (location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
      return '/.netlify/functions/api';
    }
    
    // For local development, try to get the actual cloudflared URL from Netlify function
    // This only works if running netlify dev, otherwise fallback to hardcoded URL
    try {
      const response = await fetch('/.netlify/functions/get-backend-url');
      if (response.ok) {
        const data = await response.json();
        return data.backend_url;
      }
    } catch (netlifyError) {
      // Netlify functions not available (running on pure Vite dev server)
      console.log('Netlify functions not available, using fallback Tailscale URL');
    }
    
    // Fallback to hardcoded Tailscale URL for local development
    return 'https://ztclab-1.tail503d36.ts.net';
  } catch (error) {
    console.error('Error getting backend URL:', error);
    // Fallback based on environment
    if (location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
      return '/.netlify/functions/api'; // Use proxy for production
    }
    return 'https://reconstruction-parker-put-push.trycloudflare.com'; // Direct for local dev
  }
}

// Initialize API_BASE_URL - will be set dynamically in the loader
let API_BASE_URL = '/.netlify/functions/api'; // Default to proxy

async function refreshViews() {
  console.log('üîÑ Refreshing views with latest static images...');
  try {
    const state = await getInitialState();
    if (state && state.views) {
      // Update each view with the static image
      for (const [viewName, base64Data] of Object.entries(state.views)) {
        if (views.has(viewName)) {
          const view = views.get(viewName);
          // Update the container's background image to show the static image
          view.container.style.background = `center / cover no-repeat url("${base64Data}")`;
          console.log(`‚úì Refreshed ${viewName} view with static image`);
        }
      }
    }
  } catch (error) {
    console.error('‚ùå Failed to refresh views:', error);
  }
}

async function getInitialState() {
  try {
    console.log('[DEBUG] Fetching initial state from:', `${API_BASE_URL}/api/get-state`);
    const response = await apiFetch(`/api/get-state`, {
      headers: {
        'Accept': 'application/json'
      }
    });
    console.log('[DEBUG] Response status:', response.status, response.statusText);
    
    if (!response.ok) {
      const responseText = await response.text();
      console.error('[DEBUG] Response error body:', responseText.substring(0, 500));
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const data = await response.json();
    console.log('[DEBUG] Successfully fetched initial state');
    
    // Check if we got a status response indicating no ready states
    if (data.status && (data.status === 'no_ready_states' || data.status === 'no_pending_states' || data.status === 'no_pending_states_in_episode')) {
      // Server is running but no ready states - hide the server not started message
      hideServerNotStarted();
      
      if (data.blocked_important_states) {
        console.log('üîÑ Important states blocked, starting rapid polling for readiness...');
        startRapidPollingForReadyStates();
      } else {
        console.log('üîÑ No pending states, starting regular polling...');
        startRegularPollingForStates();
      }
      return {};
    }
    
    return data;
  } catch (error) {
    console.error("Could not fetch initial state:", error);
    showServerNotStarted();
    // Hide interactive UI when server is not running
    const uiElems = document.querySelectorAll("button, .lil-gui, #viewport");
    uiElems.forEach(el=>{
      el.style.display = "none";
    });
    return {};
  }
}

// Polling for ready states when important states are blocked
let pollTimer = null;

function startRapidPollingForReadyStates() {
  stopPolling();
  console.log('üöÄ Starting rapid polling for ready important states...');
  
  // Hide server not started message since we know server is responding
  hideServerNotStarted();
  
  // Show user feedback
  showWaitingForStatesMessage('Waiting for important states to become ready...');
  
  // Poll every 1 second when states are blocked
  pollTimer = setInterval(async () => {
    try {
      const response = await apiFetch(`/api/get-state`, {
        headers: { 'Accept': 'application/json' }
      });
      
      if (response.ok) {
        const data = await response.json();
        
        // Check if we now have a real state (not a status response)
        if (!data.status || (data.status !== 'no_ready_states' && data.status !== 'no_pending_states' && data.status !== 'no_pending_states_in_episode')) {
          console.log('‚úÖ State is now ready! Refreshing page...');
          stopPolling();
          hideWaitingMessage();
          // Refresh immediately when state becomes ready
          window.location.replace(window.location.href.split('?')[0] + '?_=' + Date.now());
        }
      }
    } catch (error) {
      console.warn('Polling error:', error);
    }
  }, 1000); // 1 second interval for rapid polling
}

function startRegularPollingForStates() {
  stopPolling();
  console.log('‚è∞ Starting regular polling for new states...');
  
  // Hide server not started message since we know server is responding
  hideServerNotStarted();
  
  // Show user feedback
  showWaitingForStatesMessage('Waiting for new states...');
  
  // Poll every 5 seconds when no states exist
  pollTimer = setInterval(async () => {
    try {
      const response = await apiFetch(`/api/get-state`, {
        headers: { 'Accept': 'application/json' }
      });
      
      if (response.ok) {
        const data = await response.json();
        
        // Check if we now have a real state
        if (!data.status || (data.status !== 'no_ready_states' && data.status !== 'no_pending_states' && data.status !== 'no_pending_states_in_episode')) {
          console.log('‚úÖ New state available! Refreshing page...');
          stopPolling();
          hideWaitingMessage();
          // Refresh immediately when state becomes available
          window.location.replace(window.location.href.split('?')[0] + '?_=' + Date.now());
        }
      }
    } catch (error) {
      console.warn('Polling error:', error);
    }
  }, 5000); // 5 second interval for regular polling
}

function stopPolling() {
  if (pollTimer) {
    clearInterval(pollTimer);
    pollTimer = null;
  }
}

function showWaitingForStatesMessage(message) {
  // Hide the server not started overlay first
  hideServerNotStarted();
  
  // Create or update waiting message with full screen overlay
  let waitingDiv = document.getElementById('waiting-message');
  if (!waitingDiv) {
    waitingDiv = document.createElement('div');
    waitingDiv.id = 'waiting-message';
    waitingDiv.style.cssText = `
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #f5f5f5;
      z-index: 20000;
    `;
    
    // Create inner message box
    const messageBox = document.createElement('div');
    messageBox.className = 'waiting-message-box';
    messageBox.style.cssText = `
      background: #3b82f6;
      color: white;
      padding: 20px 30px;
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.15);
      font-family: system-ui, -apple-system, sans-serif;
      font-size: 16px;
      font-weight: 500;
      text-align: center;
      animation: pulse 2s infinite;
    `;
    
    waitingDiv.appendChild(messageBox);
    
    // Add CSS animation
    if (!document.getElementById('waiting-styles')) {
      const style = document.createElement('style');
      style.id = 'waiting-styles';
      style.textContent = `
        @keyframes pulse {
          0%, 100% { opacity: 1; }
          50% { opacity: 0.7; }
        }
      `;
      document.head.appendChild(style);
    }
    
    document.body.appendChild(waitingDiv);
  }
  
  const messageBox = waitingDiv.querySelector('.waiting-message-box');
  if (messageBox) {
    messageBox.textContent = message;
  }
}

function hideWaitingMessage() {
  const waitingDiv = document.getElementById('waiting-message');
  if (waitingDiv) {
    waitingDiv.remove();
  }
}

// Stop polling when page unloads
window.addEventListener('beforeunload', () => {
  stopPolling();
  // Clean up animation session
  if (backendAnimState.active) {
    navigator.sendBeacon(`${API_BASE_URL}/api/animation/release`, JSON.stringify({}));
  }
  stopStatusChecking();
});




// Build a THREE.Texture from a base64 JPEG data URL
async function makeTextureFromDataURL(url) {
  const loader = new THREE.TextureLoader();
  return await new Promise((resolve, reject) => {
    loader.load(
      url,
      tex => {
        tex.flipY = true;
        tex.generateMipmaps = false;
        tex.minFilter = THREE.LinearFilter;
        tex.magFilter = THREE.LinearFilter;
        tex.needsUpdate = true;
        resolve(tex);
      },
      undefined,
      err => reject(err)
    );
  });
}

/* ---------- scene ---------- */
const defaultBg = new THREE.Color(0xf5f5f5);
const scene = new THREE.Scene();
scene.background = defaultBg;
scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1));

const dir = new THREE.DirectionalLight(0xffffff, 1.2);
dir.position.set(2, 4, 2);
scene.add(dir);


const GRASP_THRESHOLD_N = 50; // N

/* ---------- floor / workspace visual -------------------- */
// light, neutral grid on the ground (y = 0)

// Default camera (will be cloned for each view)
const templateCamera = new THREE.PerspectiveCamera(45, 1, 0.01, 100);
templateCamera.position.set(0.2, -2, 0).applyAxisAngle(new THREE.Vector3(0, -1, 1), Math.PI);

// Render everything at a more compact size for captcha-style layout
const VIEW_SCALE = 0.8;

// Multi-view system
const views = new Map(); // viewName -> {camera, renderer, container, name}
let currentViewName = null;

// When true, pose sliders + scene dragging are locked (after gripper changed)
let slidersLocked = false;

const mount = document.getElementById('viewport');

/* ---------- Local filesystem sink (File System Access API) ---------- */
const LocalSink = (() => {
  let dirHandle = null;
  let fileHandle = null;
  let writer = null;

  async function pickFolder() {
    // Requires user gesture; call from a button click or similar
    dirHandle = await window.showDirectoryPicker({ mode: 'readwrite' });
    // (Optionally store dirHandle in IndexedDB for reuse across sessions)
    return true;
  }

  async function begin(filename) {
    if (!dirHandle) return false;
    fileHandle = await dirHandle.getFileHandle(filename, { create: true });
    writer = await fileHandle.createWritable();
    return true;
  }

  async function writeChunk(blob) {
    if (!writer) return false;
    await writer.write(blob);
    return true;
  }

  async function end() {
    if (writer) { await writer.close(); writer = null; }
    fileHandle = null;
  }

  function hasFolder() { return !!dirHandle; }

  return { pickFolder, begin, writeChunk, end, hasFolder };
})();

/* ---------- Recording (tab capture + cursor overlay + backend upload) ---------- */

// Re-crop if #recordRegion changes while recording
function setupRegionRecrop(track) {
  if (!('ResizeObserver' in window) || !('CropTarget' in window) || !track?.cropTo) return;
  const ro = new ResizeObserver(async () => {
    try {
      const target = await window.CropTarget.fromElement(document.getElementById('recordRegion'));
      await track.cropTo(target);
    } catch (_) {}
  });
  const el = document.getElementById('recordRegion');
  if (el) ro.observe(el);
}

function isBrowserTabTrack(track) {
  try {
    const s = track.getSettings && track.getSettings();
    // In Chromium this is "browser" when the user picked "This Tab"
    return !!s && s.displaySurface === 'browser';
  } catch (_) { return false; }
}

/* ---------- Canvas-based recorder (no tab share required) ---------- */
const CanvasRecording = (() => {
  const FPS = 30;
  let canvas, ctx, stream, mr, chunks = [], active = false, id, startedAt = 0;
  let layout = null;            // {W,H, cells:[{x,y,w,h, view}]}
  let cursor = { x: -1, y: -1, down: false };
  let recScale = 1;  // logical‚Üípixel scale used by the compositor
  let mimeTypeRef = '';          // NEW: remember chosen mime
  let bufferedMode = false;      // NEW: buffer locally until Save when RECORDING_ALLOWED
  let uploaded = false;          // NEW: has the current take been uploaded to server yet?

  function pickMime(){
    for (const t of HQ_REC.codecPrefs) {
      try { if (MediaRecorder.isTypeSupported(t)) return t; } catch (_) {}
    }
    return ''; // let the browser pick
  }

  // Mirror your grid sizing so the compositor matches the on-screen look
  function computeLayout(){
    const vs = Array.from(views.values());
    const n = vs.length;
    if (!n) return null;

    // same targets used in updateViewSizes()
    let cellW, cellH;
    if (n === 1)      { cellW = 600; cellH = 450; }
    else if (n === 2) { cellW = 450; cellH = 338; }
    else              { cellW = 375; cellH = 282; } // 3 or 4

    const { rows, cols } = (n===1) ? {rows:1,cols:1}
                        : (n===2) ? {rows:1,cols:2}
                        :           {rows:2,cols:2};

    const W = cols * cellW, H = rows * cellH;

    // row-major placement
    const cells = [];
    for (let i=0;i<n;i++){
      const r = Math.floor(i/cols), c = i%cols;
      cells.push({ x: c*cellW, y: r*cellH, w: cellW, h: cellH, view: vs[i] });
    }
    return { W, H, cells };
  }

  function ensureCanvas(){
    if (canvas) return;
    canvas = document.createElement('canvas');
    canvas.style.position = 'fixed';
    canvas.style.left = '-10000px'; // keep off-screen
    canvas.style.top  = '-10000px';
    document.body.appendChild(canvas);
    ctx = canvas.getContext('2d', { alpha: false });
    // Prefer the best resampling:
    ctx.imageSmoothingEnabled = true;
    try { ctx.imageSmoothingQuality = 'high'; } catch(_) {}
  }

  // Cover-fit draw (like CSS background-size: cover)
  function drawCover(img, dx, dy, dw, dh){
    const sw = img.naturalWidth || img.videoWidth || img.width || 1;
    const sh = img.naturalHeight || img.videoHeight || img.height || 1;
    const s = Math.max(dw / sw, dh / sh);
    const tw = sw * s, th = sh * s;
    const sx = dx + (dw - tw) / 2;
    const sy = dy + (dh - th) / 2;
    ctx.drawImage(img, sx, sy, tw, th);
  }

  // pointer ‚Üí compositor coordinates (relative to the views grid only)
  function setupPointerTracking(){
    const grid = viewsGrid; // your element that visually holds the 4 views
    grid.addEventListener('pointermove', (e) => {
      const r = grid.getBoundingClientRect();
      cursor.x = (e.clientX - r.left);
      cursor.y = (e.clientY - r.top);
    }, { passive: true });
    grid.addEventListener('pointerleave', () => { cursor.x = -1; cursor.y = -1; });
    grid.addEventListener('pointerdown', () => { cursor.down = true; });
    grid.addEventListener('pointerup',   () => { cursor.down = false; });
  }

  function drawCursor(){
    if (!layout) return;
    // When pointer is outside grid, skip
    if (cursor.x < 0 || cursor.y < 0) return;

    // cursor size roughly like your bigCursor element
    const R = 16;    // outer radius
    const r = 3;     // dot

    ctx.save();
    ctx.translate(cursor.x, cursor.y);

    // outer white ring with dark outline
    ctx.beginPath();
    ctx.arc(0,0,R,0,Math.PI*2);
    ctx.lineWidth = 3;
    ctx.strokeStyle = '#fff';
    ctx.shadowColor = 'rgba(0,0,0,0.9)';
    ctx.shadowBlur = 2;
    ctx.stroke();

    // inner dot
    ctx.beginPath();
    ctx.arc(0,0,r,0,Math.PI*2);
    ctx.fillStyle = '#111827';
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#fff';
    ctx.fill();
    ctx.stroke();

    // click flash (simple scale)
    if (cursor.down){
      ctx.beginPath();
      ctx.arc(0,0,R-2,0,Math.PI*2);
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(255,255,255,0.6)';
      ctx.stroke();
    }
    ctx.restore();
  }

  // Preload snapshot <img> for each view so we can draw them
  function ensureSnapshotImg(view, dataUrl){
    if (view._snapshotImg) return;
    const img = new Image();
    img.src = dataUrl;
    view._snapshotImg = img;
  }

  // ‚ñ∂ NEW: draw DOM HUDs into the compositor
  const DRAW_HUDS_IN_CANVAS = true;

  // SVG paths for icons so we can draw crisp vectors on canvas
  const RESET_SVG_PATH = 'M22.719 12A10.719 10.719 0 0 1 1.28 12h.838a9.916 9.916 0 1 0 1.373-5H8v1H2V2h1v4.2A10.71 10.71 0 0 1 22.719 12z';
  const HOME_SVG_PATH  = 'M 24.962891 1.0546875 A 1.0001 1.0001 0 0 0 24.384766 1.2636719 L 1.3847656 19.210938 A 1.0005659 1.0005659 0 0 0 2.6152344 20.789062 L 4 19.708984 L 4 46 A 1.0001 1.0001 0 0 0 5 47 L 18.832031 47 A 1.0001 1.0001 0 0 0 19.158203 47 L 30.832031 47 A 1.0001 1.0001 0 0 0 31.158203 47 L 45 47 A 1.0001 1.0001 0 0 0 46 46 L 46 19.708984 L 47.384766 20.789062 A 1.0005657 1.0005657 0 1 0 48.615234 19.210938 L 41 13.269531 L 41 6 L 35 6 L 35 8.5859375 L 25.615234 1.2636719 A 1.0001 1.0001 0 0 0 24.962891 1.0546875 z M 25 3.3222656 L 44 18.148438 L 44 45 L 32 45 L 32 26 L 18 26 L 18 45 L 6 45 L 6 18.148438 L 25 3.3222656 z M 37 8 L 39 8 L 39 11.708984 L 37 10.146484 L 37 8 z M 20 28 L 30 28 L 30 45 L 20 45 L 20 28 z';

  function isVisible(el){
    if (!el) return false;
    const cs = getComputedStyle(el);
    return cs.display !== 'none' && cs.visibility !== 'hidden' && +cs.opacity !== 0;
  }
  function relRect(el, container){
    const er = el.getBoundingClientRect();
    const cr = container.getBoundingClientRect();
    return { x: er.left - cr.left, y: er.top - cr.top, w: er.width, h: er.height };
  }
  function roundRect(ctx, x, y, w, h, r){
    const rr = Math.max(0, Math.min(r, Math.min(w, h) / 2));
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.lineTo(x+w-rr, y);
    ctx.quadraticCurveTo(x+w, y, x+w, y+rr);
    ctx.lineTo(x+w, y+h-rr);
    ctx.quadraticCurveTo(x+w, y+h, x+w-rr, y+h);
    ctx.lineTo(x+rr, y+h);
    ctx.quadraticCurveTo(x, y+h, x, y+h-rr);
    ctx.lineTo(x, y+rr);
    ctx.quadraticCurveTo(x, y, x+rr, y);
    ctx.closePath();
  }

  function drawGripHUD(ctx, view, baseX, baseY){
    const hud = view.hudGrip?.el; if (!hud || !isVisible(hud)) return;
    const badgeEl = view.hudGrip.badge;
    const btnEl   = view.hudGrip.btn;

    const H = relRect(hud, view.container);
    const B = relRect(badgeEl, view.container);
    const T = relRect(btnEl, view.container);

    const gx = baseX + H.x, gy = baseY + H.y;

    // Glass card
    ctx.save();
    ctx.globalAlpha = 0.92;
    roundRect(ctx, gx, gy, H.w, H.h, 14);
    ctx.fillStyle = 'rgba(255,255,255,0.24)';
    ctx.fill();
    ctx.lineWidth = 1;
    ctx.strokeStyle = 'rgba(255,255,255,0.35)';
    ctx.stroke();

    // Badge (status)
    const status =
      badgeEl.classList.contains('grasped') ? 'grasped' :
      badgeEl.classList.contains('contact') ? 'contact' : 'free';
    const badgeColor =
      status === 'grasped' ? '#22c55e' :
      status === 'contact' ? '#f59e0b' : '#9ca3af';

    roundRect(ctx, baseX + B.x, baseY + B.y, B.w, B.h, Math.min(B.h/2, 11));
    ctx.fillStyle = badgeColor;
    ctx.fill();

    ctx.fillStyle = '#ffffff';
    ctx.font = '700 11px system-ui, -apple-system, Segoe UI, Roboto';
    ctx.textBaseline = 'middle';
    ctx.textAlign = 'center';
    ctx.fillText(status, baseX + B.x + B.w/2, baseY + B.y + B.h/2);

    // Toggle (Open/Close)
    const isOpen = btnEl.classList.contains('open');
    const btnColor = isOpen ? '#3b82f6' : '#3b82f6';
    roundRect(ctx, baseX + T.x, baseY + T.y, T.w, T.h, 9);
    ctx.fillStyle = btnColor;
    ctx.fill();

    ctx.fillStyle = '#ffffff';
    ctx.font = '700 12px system-ui, -apple-system, Segoe UI, Roboto';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(btnEl.textContent?.trim() || (isOpen ? 'Grasp' : 'Release'),
                 baseX + T.x + T.w/2, baseY + T.y + T.h/2);

    ctx.restore();
  }

  function drawIconButton(ctx, view, el, baseX, baseY, pathStr, viewBoxSize){
    if (!el || !isVisible(el)) return;
    const R = relRect(el, view.container);
    const x = baseX + R.x, y = baseY + R.y, w = R.w, h = R.h;

    ctx.save();
    ctx.globalAlpha = 0.92;
    // glass box
    roundRect(ctx, x, y, w, h, 14);
    ctx.fillStyle = 'rgba(255,255,255,0.24)';
    ctx.fill();
    ctx.lineWidth = 1;
    ctx.strokeStyle = 'rgba(255,255,255,0.35)';
    ctx.stroke();

    // icon
    const vb = viewBoxSize; // e.g., 24 for reset, 50 for home
    const scale = Math.min(w, h) / vb * 0.82; // slight inset
    ctx.translate(x + w/2, y + h/2);
    ctx.scale(scale, scale);
    ctx.translate(-vb/2, -vb/2);
    ctx.fillStyle = '#111827';
    try {
      const p = new Path2D(pathStr);
      ctx.fill(p);
    } catch {
      // Fallback: simple emoji if Path2D path parsing isn't supported
      ctx.setTransform(1,0,0,1,0,0);
      ctx.fillStyle = '#111827';
      ctx.font = `${Math.round(Math.min(w,h)*0.7)}px system-ui`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('‚åÅ', x + w/2, y + h/2);
    }
    ctx.restore();
  }

  function drawHUDs(ctx, layout){
    // Iterate each cell and paint visible HUDs at their DOM-computed positions
    for (const cell of layout.cells){
      const v = cell.view;
      if (!v || !v.container) continue;

      // Gripper HUD (status pill + toggle)
      if (v.hudGrip) drawGripHUD(ctx, v, cell.x, cell.y);

      // Reset icon (24x24 viewBox)
      if (v.hudResetEl) drawIconButton(ctx, v, v.hudResetEl, cell.x, cell.y, RESET_SVG_PATH, 24);

      // Home icon (50x50 viewBox)
      if (v.hudHomeEl)  drawIconButton(ctx, v, v.hudHomeEl,  cell.x, cell.y, HOME_SVG_PATH, 50);
    }
  }

  let rafId = 0;
  function compose(){
    rafId = requestAnimationFrame(compose);
    if (!layout) return;

    // Clear in device pixels
    ctx.save();
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.restore();

    // Ensure our scaled logical transform is active
    ctx.setTransform(recScale, 0, 0, recScale, 0, 0);

    // Draw each cell: camera image ‚Üí renderer canvas
    for (const cell of layout.cells){
      const v = cell.view;
      // 1) camera snapshot (cover fit)
      if (v._snapshotImg) drawCover(v._snapshotImg, cell.x, cell.y, cell.w, cell.h);
      // 2) overlays - your WebGL renderer canvas
      const c = v.renderer?.domElement;
      if (c && c.width && c.height){
        ctx.drawImage(c, cell.x, cell.y, cell.w, cell.h);
      }
      // (If you also want to draw the translucent mask, see note below.)
    }

    // ‚ñ∂ NEW: draw HUD overlays (gripper, reset, home) into the compositor
    if (DRAW_HUDS_IN_CANVAS) drawHUDs(ctx, layout);

    // 3) synthetic cursor (draw last so it sits on top)
    drawCursor();
  }

  async function start(trigger='unknown'){
    if (active) return true;

    ensureCanvas();
    setupPointerTracking();

    // Build (or rebuild) the layout using current views
    layout = computeLayout();
    if (!layout) return false;

    // Choose a scale that reaches ‚â•1080p when possible, within safety caps.
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const minScaleFor1080 = HQ_REC.targetWidth / layout.W;
    const maxScaleAllowed = Math.min(HQ_REC.maxWidth / layout.W, HQ_REC.maxHeight / layout.H);

    // Effective scale = base √ó DPR, but at least the 1080p scale, capped by max.
    recScale = Math.min(
      Math.max(HQ_REC.baseScale * dpr, minScaleFor1080),
      maxScaleAllowed
    );

    // Backing pixels (recording resolution)
    canvas.width  = Math.round(layout.W * recScale);
    canvas.height = Math.round(layout.H * recScale);

    // Keep logical size unchanged (we hide the canvas off-screen anyway)
    canvas.style.width  = layout.W + 'px';
    canvas.style.height = layout.H + 'px';

    // Draw everything in "logical units" and scale to pixels
    ctx.setTransform(recScale, 0, 0, recScale, 0, 0);

    // Make sure each view has a snapshot <img>
    // We have the dataURL in the state; your code passed it into createViewRenderer as imageSrc
    views.forEach((v, name) => {
      const url = window.__INIT_STATE?.views?.[name];
      if (url) ensureSnapshotImg(v, url);
    });

    // Start composition loop first (so first frame is ready quickly)
    compose();

    // Always use buffered mode - no live streaming
    bufferedMode = true;
    uploaded = false;

    // Start recorder on the compositor canvas stream
    const mime = pickMime();
    stream = canvas.captureStream(HQ_REC.fps);
    const bps = HQ_REC.bitrateFor(canvas.width, canvas.height);
    mr = new MediaRecorder(stream, { mimeType: mime, videoBitsPerSecond: bps });
    mimeTypeRef = mr.mimeType || mime;
    id = `rec-${Date.now()}-${Math.random().toString(36).slice(2,7)}`;
    LAST_RECORDING_ID  = id;
    LAST_RECORDING_EXT = 'webm';
    chunks = [];
    startedAt = Date.now();
    active = true;

    // Broadcast start (for the mini HUD)
    try { window.dispatchEvent(new CustomEvent('rec:started', { detail: { id, startedAt } })); } catch(_){}

    mr.ondataavailable = async (ev) => {
      if (!ev.data || ev.data.size === 0) return;
      // Always buffer in memory
      chunks.push(ev.data);
    };

    mr.onstop = async () => {
      cancelAnimationFrame(rafId); rafId = 0;
      // Buffered mode: do nothing here; we will upload on Save.
      active = false;
      try { window.dispatchEvent(new CustomEvent('rec:stopped', { detail: { id, durationMs: Date.now() - startedAt } })); } catch(_){}
    };

    mr.start(1000);
    return true;
  }

  async function stop(){
    if (!active) return;
    let onStopComplete;
    const stopCompletePromise = new Promise(res => { onStopComplete = res; });
    
    // Wrap the existing onstop to notify when it's truly complete
    const originalOnStop = mr.onstop;
    mr.onstop = async function() {
      try {
        await originalOnStop.call(this);
      } finally {
        onStopComplete();
      }
    };
    
    mr.stop();
    await stopCompletePromise;
  }

  // Upload buffered chunks to backend (called by Save)
  async function flushToServer(){
    if (uploaded) return false;                      // already uploaded
    if (!chunks.length || !(chunks[0] instanceof Blob)) return false; // nothing buffered
    
    const rect = { width: canvas?.width || 0, height: canvas?.height || 0 };
    const meta = {
      recording_id: id, 
      sid: SID, 
      started_at: new Date(startedAt || Date.now()).toISOString(),
      trigger: 'manual-save', 
      fps: FPS, 
      viewport: { ...rect, dpr: 1 },
      cursor_overlay: true,
      state_id: window.__INIT_STATE?.state_id,
      episode_id: window.__INIT_STATE?.episode_id,
      task_name: window.__INIT_STATE?.task_name,
      container: 'quad-views',
      ext: 'webm'
    };
    
    // 1. Start recording session on server
    const begin = await apiFetch('/api/record/start', {
      method:'POST', 
      headers:{'Content-Type':'application/json'}, 
      body: JSON.stringify(meta)
    });
    if (!begin.ok) throw new Error('record/start failed');
    
    // 2. Upload all chunks
    for (let i = 0; i < chunks.length; i++){
      const qs = new URLSearchParams({ rid: id, seq: String(i), sid: SID });
      const chunk = chunks[i];
      const r = await apiFetch(`/api/record/chunk?${qs}`, {
        method:'POST', 
        headers:{'Content-Type':'application/octet-stream'}, 
        body: chunk
      });
      if (!r.ok) throw new Error(`record/chunk ${i} failed`);
    }
    
    // 3. Save the recording (combines chunks into final video file)
    const saveResult = await apiFetch('/api/record/save', {
      method:'POST', 
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ recording_id: id })
    });
    if (!saveResult.ok) throw new Error('record/save failed');
    
    uploaded = true;
    return true;
  }

  return { ensureStart: start, stop, isActive: ()=>active, flushToServer };
})();

const Recording = (() => {
  let stream = null, mr = null, chunks = [], uploadOk = false, seq = 0, id = null, active = false, startedAt = 0;
  const FPS = 30;
  let recIndicator, preflight, cursorEl, timerRAF;

  function ensureUI(){
    // ...existing...
    const region = document.getElementById('recordRegion');

    // REC indicator (append inside recordRegion)
    if (!region.querySelector('#recIndicator')) {
      const el = document.createElement('div');
      el.id = 'recIndicator';
      el.innerHTML = '<span class="dot" aria-hidden="true"></span><span>REC <span id="recTimer">00:00</span></span>';
      region.prepend(el);
    }
    recIndicator = region.querySelector('#recIndicator');

    // Preflight hint (still attached to body)
    preflight = document.getElementById('recPreflight');
    if (!preflight){
      preflight = document.createElement('div');
      preflight.id = 'recPreflight';
      preflight.innerHTML = '<div class="card"><div class="title">Share this tab to start recording</div><div class="hint">When prompted by your browser, choose <b>This Tab</b>. We hide the system cursor and draw a large cursor so interactions are clear on video.</div></div>';
      document.body.appendChild(preflight);
    }

    // Big cursor (append inside recordRegion)
    cursorEl = region.querySelector('#bigCursor');
    if (!cursorEl){
      cursorEl = document.createElement('div');
      cursorEl.id = 'bigCursor';
      cursorEl.innerHTML = '<div class="ring"></div><div class="dot"></div>';
      region.appendChild(cursorEl);
    }

    // Pointer tracking (show only inside #recordRegion)
    window.addEventListener('pointermove', (e) => {
      if (!active) { cursorEl.style.display = 'none'; return; }
      const r = region.getBoundingClientRect();
      const inBox = e.clientX >= r.left && e.clientX <= r.right && e.clientY >= r.top && e.clientY <= r.bottom;
      if (inBox) {
        cursorEl.style.display = 'block';
        cursorEl.style.left = e.clientX - r.left + 'px';
        cursorEl.style.top  = e.clientY - r.top  + 'px';
      } else {
        cursorEl.style.display = 'none';
      }
    }, { passive: true });

    window.addEventListener('pointerdown', () => {
      cursorEl.classList.add('active'); cursorEl.classList.add('click');
      setTimeout(()=>cursorEl.classList.remove('click'), 180);
    }, { capture: true });
    window.addEventListener('pointerup',   () => { cursorEl.classList.remove('active'); }, { capture: true });
  }

  function showPreflight(){ preflight?.classList.add('visible'); }
  function hidePreflight(){ preflight?.classList.remove('visible'); }

  function showIndicator(){
    recIndicator?.classList.add('visible');
    const tEl = document.getElementById('recTimer');
    const tick = () => {
      if (!active) return;
      const s = Math.floor((Date.now()-startedAt)/1000);
      const mm = String(Math.floor(s/60)).padStart(2, '0');
      const ss = String(s%60).padStart(2, '0');
      if (tEl) tEl.textContent = `${mm}:${ss}`;
      timerRAF = requestAnimationFrame(tick);
    };
    timerRAF = requestAnimationFrame(tick);
  }
  function hideIndicator(){
    recIndicator?.classList.remove('visible');
    if (timerRAF) cancelAnimationFrame(timerRAF), timerRAF = null;
  }

  function pickMime(){
    const tryTypes = ['video/webm;codecs=vp9','video/webm;codecs=vp8','video/webm'];
    for (const t of tryTypes) if (MediaRecorder.isTypeSupported(t)) return t;
    return '';
  }

  async function start(trigger='unknown'){
    if (active) return true;
    if (!navigator.mediaDevices?.getDisplayMedia || !window.MediaRecorder) {
      console.warn('Recording not supported in this browser.');
      return false;
    }

    ensureUI();
    try {
      showPreflight();
      // Capture THIS TAB; hide system cursor in the capture (we draw our own)
      stream = await navigator.mediaDevices.getDisplayMedia({
        video: { frameRate: FPS, cursor: 'never', displaySurface: 'browser', logicalSurface: true },
        audio: false
      });
      hidePreflight();

      // Immediately after getDisplayMedia succeeds:
      const [track] = stream.getVideoTracks();
      // If the user picked "Entire screen" or a window, bail and re-prompt.
      if (!isBrowserTabTrack(track)) {
        try { stream.getTracks().forEach(t => t.stop()); } catch(_) {}
        alert('Please share **This Tab** (not Entire screen) so we can crop to the robot views.');
        // Re-open the picker; return the result of the recursive call
        return await start(trigger);
      }

      if (track && 'cropTo' in track && 'CropTarget' in window) {
        try {
          const target = await window.CropTarget.fromElement(document.getElementById('recordRegion'));
          await track.cropTo(target);
          console.log('üéØ Recording is cropped to #recordRegion');
        } catch (e) {
          console.warn('Region Capture failed; falling back to full tab:', e);
        }
      } else {
        console.warn('Region Capture not supported; recording full tab.');
      }

      // Re-crop if #recordRegion changes while recording
      setupRegionRecrop(track);

      const mime = pickMime();
      mr = new MediaRecorder(stream, { mimeType: mime, videoBitsPerSecond: 6_000_000 });
      chunks = [];
      uploadOk = false; seq = 0;
      id = `rec-${Date.now()}-${Math.random().toString(36).slice(2,7)}`;
      const filename = `${id}.webm`;
      startedAt = Date.now();
      active = true;

      document.body.classList.add('recording');
      cursorEl.style.display = 'block';
      showIndicator();

      // Best-effort backend session (falls back to local file if not available)
      (async ()=>{
        try {
          const rect = mount.getBoundingClientRect();
          const meta = {
            recording_id: id,
            sid: SID,
            started_at: new Date().toISOString(),
            trigger, fps: FPS,
            viewport: { width: Math.round(rect.width), height: Math.round(rect.height), dpr: devicePixelRatio },
            cursor_overlay: true,
            state_id: window.__INIT_STATE?.state_id,
            episode_id: window.__INIT_STATE?.episode_id,
            task_name: window.__INIT_STATE?.task_name,       // backend "knows", but sending doesn't hurt
            container: 'quad-views',                         // helpful for logs
            ext: (mime && mime.includes('webm')) ? 'webm' : 'webm' // MediaRecorder ‚Üí webm in browsers
          };
          const resp = await apiFetch('/api/record/start', {
            method: 'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(meta)
          });
          uploadOk = resp.ok;
        } catch { uploadOk = false; }
      })();

      mr.ondataavailable = async (ev) => {
        if (!ev.data || ev.data.size === 0) return;

        if (uploadOk) {
          try {
            const qs = new URLSearchParams({ rid: id, seq: String(seq++), sid: SID });
            await apiFetch(`/api/record/chunk?${qs}`, {
              method:'POST', headers: { 'Content-Type': 'application/octet-stream' }, body: ev.data
            });
            return; // success
          } catch (e) {
            console.warn('Chunk upload failed, switching to local sink.', e);
            uploadOk = false;
            // Intentionally fall through to local handling
          }
        }

        // Local sink: open writer on first chunk
        if (LocalSink.hasFolder() && !mr._localSinkOpened) {
          try {
            await LocalSink.begin(filename);
            mr._localSinkOpened = true;
          } catch (e) {
            console.warn('Local sink not available; will buffer and download at end.', e);
          }
        }

        if (mr._localSinkOpened) {
          try { await LocalSink.writeChunk(ev.data); }
          catch (e) { console.warn('Local sink write failed; buffering.', e); chunks.push(ev.data); }
        } else {
          chunks.push(ev.data);
        }
      };

      mr.onstop = async () => {
        try { stream?.getTracks().forEach(t => t.stop()); } catch {}
        try {
          if (uploadOk) {
            await apiFetch('/api/record/stop', {
              method:'POST',
              headers:{'Content-Type':'application/json'},
              body: JSON.stringify({
                recording_id: id,
                duration_ms: Date.now()-startedAt
              })
            });
          } else if (RECORDING_ALLOWED && !LocalSink.hasFolder()) {
            // When the flag is on we require backend persistence.
            throw new Error('Backend recording upload not available (and no local sink).');
          } else if (mr._localSinkOpened) {
            await LocalSink.end();
          } else if (chunks.length) {
            // Legacy fallback: only when flag is OFF or a local sink was chosen.
            const blob = new Blob(chunks, { type: mime || 'video/webm' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = filename; a.click();
            URL.revokeObjectURL(url);
          }
        } catch (e) {
          console.error('‚ùå Recording failed to persist to backend.', e);
          alert('Recording could not be saved to the server. Please pick "This Tab" and try again.');
        }
        active = false;
        document.body.classList.remove('recording');
        cursorEl.style.display = 'none';
        hideIndicator();
      };

      mr.start(1000); // 1s chunks

      // If user stops sharing via browser UI, stop recorder cleanly
      stream.getVideoTracks().forEach(t => t.addEventListener('ended', () => {
        if (mr && mr.state !== 'inactive') mr.stop();
      }));

      return true;
    } catch (err) {
      console.error('User cancelled or capture failed:', err);
      hidePreflight();
      return false;
    }
  }

  async function ensureStart(trigger='unknown'){
    if (!active) await start(trigger);
  }

  async function stop(){
    if (mr && mr.state !== 'inactive') {
      const p = new Promise(res => mr.addEventListener('stop', res, {once:true}));
      mr.stop();
      await p;
    }
  }

  function isActive(){ return active; }
  return { ensureStart, stop, isActive };
})();

// Global flag for recording (set after initial state fetch)
let RECORDING_ALLOWED = false;

// The last started recording, if any (used to associate with Verify)
let LAST_RECORDING_ID  = null;
let LAST_RECORDING_EXT = 'webm'; // MediaRecorder ‚Üí webm in browsers

// Explicit user "Save" state for the current take
let RECORDING_MARKED_SAVED = false;

// Format mm:ss
function _fmt(ms){
  const s = Math.max(0, Math.floor(ms/1000));
  const mm = String(Math.floor(s/60)).padStart(2,'0');
  const ss = String(s%60).padStart(2,'0');
  return `${mm}:${ss}`;
}

// --- Recording hotkeys (bound only when recording is enabled) -----------------
let RECORDING_HOTKEYS_BOUND = false;

function bindRecordingHotkeysOnce() {
  if (RECORDING_HOTKEYS_BOUND) return;
  RECORDING_HOTKEYS_BOUND = true;

  window.addEventListener('keydown', async (e) => {
    if (e.metaKey || e.ctrlKey || e.altKey || e.isComposing) return;
    const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : '';
    if (tag === 'input' || tag === 'textarea' || tag === 'select' || e.defaultPrevented) return;

    const k = (e.key || '').toLowerCase();

    if (k === 'a') {
      // Start (manual mode only)
      if (RECORDING_ALLOWED) {
        e.preventDefault();
        await startRecordingManual('hotkey-a');
      }
    } else if (k === 'q') {
      // Stop only (never save)
      e.preventDefault();
      if (RECORDING_ALLOWED) {
        await stopRecordingManual();
      } else if (CanvasRecording.isActive()) {
        await CanvasRecording.stop();
      }
    } else if (k === 'r') {
      // Re-record
      e.preventDefault();
      if (RECORDING_ALLOWED) {
        await rerecordManual();
      } else {
        try { if (CanvasRecording.isActive()) await CanvasRecording.stop(); } catch(_){}
        await CanvasRecording.ensureStart('hotkey-rerecord');
      }
    } else if (k === 's') {
      // Save (manual mode only)
      if (RECORDING_ALLOWED) {
        e.preventDefault();
        await saveRecordingManual();
      }
    }
  });
}

function maybeRecord(trigger) {
  // Don't auto-record when demo videos are disabled or when in buffered demo-video mode
  // (in buffered mode, recording only starts manually via 'a' key or UI)
  return;
}

function createRecordingMiniUI(){
  let el = document.getElementById('recMini');
  if (el) return el;

  el = document.createElement('div');
  el.id = 'recMini';
  el.innerHTML = `
    <span class="dot" aria-hidden="true"></span>
    <span class="state" id="recMiniState">Idle</span>
    <span class="time" id="recMiniTime">00:00</span>
    <button class="btn" id="recMiniStart" title="Start (a)" aria-label="Start">‚ñ∂</button>
    <button class="btn" id="recMiniStop"  title="Stop (q)"  aria-label="Stop">‚ñ†</button>
    <button class="btn" id="recMiniRerec" title="Re-record (r)" aria-label="Re-record">‚ü≤</button>
    <button class="btn" id="recMiniSave"  title="Save (s)"  aria-label="Save">üíæ</button>
    <span class="saved-badge" id="recMiniSaved">Saved ‚úì</span>
  `;
  document.body.appendChild(el);

  el.querySelector('#recMiniStart').addEventListener('click', ()=> startRecordingManual('ui-start'));
  el.querySelector('#recMiniStop' ).addEventListener('click', ()=> stopRecordingManual());
  el.querySelector('#recMiniRerec').addEventListener('click', ()=> rerecordManual());
  el.querySelector('#recMiniSave' ).addEventListener('click', ()=> saveRecordingManual());

  // Live wiring to recording lifecycle
  window.addEventListener('rec:started', (e)=>{
    _recMiniUpdate('recording', e.detail?.startedAt || Date.now());
  });
  window.addEventListener('rec:stopped', (e)=>{
    _recMiniUpdate('stopped', null, e.detail?.durationMs ?? null);
  });

  // Initialize view
  if (RECORDING_ALLOWED) el.classList.add('visible');
  _recMiniUpdate('idle');
  return el;
}

let _recMiniTimerRAF = 0;
let _recMiniStartedAt = 0;

function _recMiniUpdate(state, startedAt = null, stoppedDurationMs = null){
  const el = document.getElementById('recMini');
  if (!el) return;

  const dot   = el.querySelector('.dot');
  const stTxt = el.querySelector('#recMiniState');
  const tTxt  = el.querySelector('#recMiniTime');
  const saved = el.querySelector('#recMiniSaved');
  const start = el.querySelector('#recMiniStart');
  const stop  = el.querySelector('#recMiniStop');
  const rerec = el.querySelector('#recMiniRerec');
  const save  = el.querySelector('#recMiniSave');

  if (_recMiniTimerRAF) cancelAnimationFrame(_recMiniTimerRAF), _recMiniTimerRAF = 0;

  if (state === 'recording') {
    dot.classList.add('recording');
    stTxt.textContent = 'REC';
    _recMiniStartedAt = startedAt || Date.now();
    const tick = ()=>{ tTxt.textContent = _fmt(Date.now() - _recMiniStartedAt); _recMiniTimerRAF = requestAnimationFrame(tick); };
    _recMiniTimerRAF = requestAnimationFrame(tick);
    start.disabled = true;  stop.disabled = false; rerec.disabled = false; save.disabled = true;
    el.classList.toggle('saved', false);
  } else if (state === 'stopped') {
    dot.classList.remove('recording');
    stTxt.textContent = 'Stopped';
    const dur = (typeof stoppedDurationMs === 'number') ? stoppedDurationMs : (_recMiniStartedAt ? Date.now() - _recMiniStartedAt : 0);
    tTxt.textContent = _fmt(dur);
    start.disabled = false; stop.disabled = true; rerec.disabled = false; save.disabled = RECORDING_MARKED_SAVED;
  } else {
    dot.classList.remove('recording');
    stTxt.textContent = 'Idle';
    tTxt.textContent = '00:00';
    start.disabled = false; stop.disabled = true; rerec.disabled = !LAST_RECORDING_ID; save.disabled = RECORDING_MARKED_SAVED;
    el.classList.toggle('saved', false);
  }

  saved.style.display = RECORDING_MARKED_SAVED ? 'inline' : 'none';
}

// Button actions (manual mode)
async function startRecordingManual(trigger='manual'){
  if (CanvasRecording.isActive()) return;
  RECORDING_MARKED_SAVED = false;           // new take, clear previous saved state
  _recMiniUpdate('idle');
  await CanvasRecording.ensureStart(trigger);
  if (!CanvasRecording.isActive()) _recMiniUpdate('idle'); // start failed
}

async function stopRecordingManual(){
  if (!CanvasRecording.isActive()) return;
  await CanvasRecording.stop();             // stop only; do NOT save
  _recMiniUpdate('stopped');
}

async function rerecordManual(){
  try { if (CanvasRecording.isActive()) await CanvasRecording.stop(); } catch(_){}
  RECORDING_MARKED_SAVED = false;
  _recMiniUpdate('idle');
  await CanvasRecording.ensureStart('manual-rerecord');
}

async function saveRecordingManual(){
  // Save video recording if one exists (this is about UI demo videos, not dataset episodes)
  if (CanvasRecording.isActive()) {
    alert('Cannot save while recording is active. Stop recording first with "q".');
    return;
  }

  // Save buffered video recording if one exists
  if (LAST_RECORDING_ID) {
    try {
      const didUpload = await CanvasRecording.flushToServer();
      if (didUpload) {
        console.log('‚úÖ Video recording saved:', LAST_RECORDING_ID);
        RECORDING_MARKED_SAVED = true;
        _recMiniUpdate('stopped');
      } else {
        console.log('‚ÑπÔ∏è No video recording to save or already saved');
        alert('No video recording to save.');
      }
    } catch (e) {
      console.error('‚ùå Video recording save failed:', e);
      alert('Could not save the video recording to the server. Please try again.');
    }
  } else {
    alert('No video recording to save.');
  }
}

// Create a blue prompt bar that contains the prompt text
const promptBar = document.createElement('div');
promptBar.className = 'prompt-bar';

const promptText = document.createElement('div');
promptText.className = 'prompt-text';
promptText.textContent = ''; // Default text, will be updated from server

promptBar.appendChild(promptText);

mount.appendChild(promptBar);

// NEW: record-only wrapper that excludes the prompt bar
const recordRegion = document.createElement('div');
recordRegion.id = 'recordRegion';
mount.appendChild(recordRegion);

// Everything below goes into recordRegion (NOT directly into mount)
const contentContainer = document.createElement('div');
contentContainer.className = 'content-container';
recordRegion.appendChild(contentContainer);

const buttonBarsContainer = document.createElement('div');
buttonBarsContainer.className = 'button-bars-container';
recordRegion.appendChild(buttonBarsContainer);

const resetBar = document.createElement('div');
resetBar.className = 'reset-bar';
buttonBarsContainer.appendChild(resetBar);

const confirmBar = document.createElement('div');
confirmBar.className = 'confirm-bar';
buttonBarsContainer.appendChild(confirmBar);

// Views grid stays the same, but append to contentContainer under recordRegion
const viewsGrid = document.createElement('div');
viewsGrid.className = 'views-grid';
contentContainer.appendChild(viewsGrid);

// ADD: Example video dock (independent window to the right of the views)
let exampleDock = null;
let exampleVideo = null;
let exampleToggle = null; // created only when demo videos are allowed AND a URL/id exists

function createExampleDockOnce(){
  if (exampleDock) return;
  exampleDock = document.createElement('div');
  exampleDock.id = 'exampleDock';

  exampleVideo = document.createElement('video');
  exampleVideo.muted = true;           // allow autoplay
  exampleVideo.loop = true;
  exampleVideo.autoplay = true;
  exampleVideo.playsInline = true;
  exampleVideo.preload = 'auto';

  exampleDock.appendChild(exampleVideo);
  document.body.appendChild(exampleDock);
}

function updateExampleDockLayout(){
  if (!exampleDock || !viewsGrid) return;
  
  // Get prompt bar position for top alignment
  const promptBar = document.querySelector('.prompt-bar');
  const viewsRect = viewsGrid.getBoundingClientRect();
  const promptRect = promptBar ? promptBar.getBoundingClientRect() : viewsRect;
  
  const gap = 24; // px between views and dock - increased for comfortable spacing
  
  // Make the dock 20% smaller (80% of original size)
  const scaleFactor = 0.75;
  const dockWidth = Math.round(viewsRect.width * scaleFactor);
  const dockHeight = Math.round(viewsRect.height * scaleFactor);
  
  // Position: align top with prompt bar, right of views with gap
  exampleDock.style.top    = Math.round(promptRect.top) + 'px';
  exampleDock.style.left   = Math.round(viewsRect.right + gap) + 'px';
  exampleDock.style.width  = dockWidth + 'px';
  exampleDock.style.height = dockHeight + 'px';
}

function showExampleDock(){
  // Mark button as activated if dock is being shown (remove never-activated class)
  if (exampleToggle.classList.contains('never-activated')) {
    exampleToggle.classList.remove('never-activated');
  }
  
  createExampleDockOnce();
  exampleDock.style.display = 'block';
  exampleToggle.classList.add('active');
  exampleToggle.setAttribute('aria-pressed', 'true');
  exampleToggle.title = 'Hide example';
  updateExampleDockLayout();
  
  // Start video playback when dock is shown - restart from beginning
  const video = exampleDock.querySelector('video');
  if (video) {
    video.currentTime = 0; // Reset to beginning
    video.play().catch(err => {
      console.warn('Autoplay blocked or failed; showing controls.', err);
      video.controls = true; // let the user click play
    });
  }
}

function hideExampleDock(){
  if (!exampleDock) return;
  
  // Pause video when dock is hidden
  const video = exampleDock.querySelector('video');
  if (video) {
    video.pause();
  }
  
  exampleDock.style.display = 'none';
  exampleToggle.classList.remove('active');
  exampleToggle.setAttribute('aria-pressed', 'false');
  exampleToggle.title = 'Show example';
}

function toggleExampleDock(force){
  // Mark button as activated (remove never-activated class)
  if (exampleToggle.classList.contains('never-activated')) {
    exampleToggle.classList.remove('never-activated');
  }
  
  const want = (typeof force === 'boolean') ? force :
               !(exampleDock && exampleDock.style.display === 'block');
  
  console.log(`üé≠ Toggling example dock:`, {
    action: want ? 'show' : 'hide',
    force: force,
    currentDisplay: exampleDock?.style.display,
    videoSrc: exampleVideo?.src
  });
  
  if (want) showExampleDock(); else hideExampleDock();
}

// Keep the dock aligned when the window resizes
window.addEventListener('resize', updateExampleDockLayout);

// Controls wrapper as before (even if display:none)
const controlsWrapper = document.createElement('div');
controlsWrapper.style.display = 'flex';
controlsWrapper.style.flexDirection = 'column';
controlsWrapper.style.gap = '0px';
contentContainer.appendChild(controlsWrapper);

// Create the controls container for sliders
const controlsContainer = document.createElement('div');
controlsContainer.className = 'controls-container';
controlsContainer.style.display = 'none'; // Hidden initially
controlsWrapper.appendChild(controlsContainer);

// Multi-view grid layout helper
function calculateGridLayout(numViews) {
  if (numViews === 1) return { rows: 1, cols: 1 };
  if (numViews === 2) return { rows: 1, cols: 2 };
  if (numViews === 3) return { rows: 2, cols: 2 }; // 2 on top, 1 on bottom
  if (numViews === 4) return { rows: 2, cols: 2 };
  // For more views, calculate a reasonable grid
  const cols = Math.ceil(Math.sqrt(numViews));
  const rows = Math.ceil(numViews / cols);
  return { rows, cols };
}

function setupViewportGrid(numViews) {
  const { rows, cols } = calculateGridLayout(numViews);
  viewsGrid.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
  viewsGrid.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
}

function createViewRenderer(viewName, cameraModel, texture, imageSrc) {
  const renderer = new THREE.WebGLRenderer({
    antialias: true,
    alpha: true,
    powerPreference: 'high-performance',
    precision: 'highp',
    preserveDrawingBuffer: false
  });

  // Render more sharply even on standard monitors
  renderer.setPixelRatio(Math.max(window.devicePixelRatio || 1, 2));

  // Proper color management (r165 uses outputColorSpace)
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  // If you use tone mapping elsewhere, leave it; otherwise:
  renderer.toneMapping = THREE.NoToneMapping;

  renderer.setClearColor(0x000000, 0); // fully transparent canvas
  
  // Create appropriate camera type based on model
  let camera;
  if (cameraModel && cameraModel.projection_type === 'orthographic') {
    // Create orthographic camera with default parameters (will be updated later)
    camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.01, 100);
    camera.position.copy(templateCamera.position);
    camera.quaternion.copy(templateCamera.quaternion);
  } else {
    // Use perspective camera (default)
    camera = templateCamera.clone();
  }
  
  const container = document.createElement('div');
  container.className = 'view-container';
  container.dataset.viewName = viewName;
  
  // Camera feed as CSS background, centered and cropped like the canvas
  if (imageSrc) {
    container.style.background = `center / cover no-repeat url("${imageSrc}")`;
  }
  

  
  container.appendChild(renderer.domElement);
  viewsGrid.appendChild(container);
  
  const view = {
    camera,
    renderer,
    container,
    name: viewName,
    model: cameraModel,
    texture: texture
  };
  
  views.set(viewName, view);
  return view;
}

function updateViewSizes() {
  const viewContainers = viewsGrid.querySelectorAll('.view-container');
  if (viewContainers.length === 0) return;
  
  // Define compact view dimensions based on number of views (increased by 87.5% total: 1.25 * 1.5)
  const numViews = viewContainers.length;
  let targetWidth, targetHeight;
  
  if (numViews === 1) {
    targetWidth = 600;  // 400 * 1.5
    targetHeight = 450; // 300 * 1.5
  } else if (numViews === 2) {
    targetWidth = 450;  // 300 * 1.5
    targetHeight = 338; // 225 * 1.5
  } else if (numViews === 3 || numViews === 4) {
    targetWidth = 375;  // 250 * 1.5
    targetHeight = 282; // 188 * 1.5
  } else {
    targetWidth = 300;  // 200 * 1.5
    targetHeight = 225; // 150 * 1.5
  }
  
  // Apply sizing to views grid - no gaps or padding now
  const { rows, cols } = calculateGridLayout(numViews);
  const totalWidth = cols * targetWidth; // no gaps
  const totalHeight = rows * targetHeight; // no gaps
  
  viewsGrid.style.width = totalWidth + 'px';
  viewsGrid.style.height = totalHeight + 'px';
  
  // Lock the overall card width to the grid width + the card's horizontal padding (20px + 20px).
  // Because we set #viewport { box-sizing: border-box }, this "total" width includes the padding.
  const cardHorizontalPadding = 40; // 20px left + 20px right
  const fixedWidthPx = totalWidth + cardHorizontalPadding;

  // Expose as a CSS variable (used by the CSS above) and hard-set width to be extra safe.
  mount.style.setProperty('--viewport-total-px', fixedWidthPx + 'px');
  mount.style.width    = fixedWidthPx + 'px';
  mount.style.minWidth = fixedWidthPx + 'px';
  mount.style.maxWidth = fixedWidthPx + 'px';
  
  views.forEach(view => {
    const model = view.model;
    if (!model) return;
    
    const W = model.width | 0;
    const H = model.height | 0;
    
    // Make canvas fill the entire container
    const containerAspect = targetWidth / targetHeight;
    const imageAspect = W / H;
    
    let renderWidth = targetWidth;
    let renderHeight = targetHeight;
    
    // Fill the container completely (may crop image slightly)
    if (containerAspect > imageAspect) {
      // Container is wider than image aspect - fit to width
      renderHeight = Math.round(targetWidth / imageAspect);
    } else {
      // Container is taller than image aspect - fit to height  
      renderWidth = Math.round(targetHeight * imageAspect);
    }
    
    view.renderer.setSize(renderWidth, renderHeight);
    
    // Set container size to match target exactly
    view.container.style.width = targetWidth + 'px';
    view.container.style.height = targetHeight + 'px';
  });
  
  // Keep the example dock aligned/sized with the views grid
  updateExampleDockLayout();
}


// --- status overlay (initially hidden) ---
const statusOverlay = document.createElement('div');
statusOverlay.id = 'statusOverlay';
document.body.appendChild(statusOverlay);

function showServerNotStarted(){
  statusOverlay.innerHTML = `
    <div class="card">
      <div class="row">
        <div class="spinner" aria-hidden="true"></div>
        <h2 class="title">Data collection server hasn't started yet‚Ä¶</h2>
      </div>
      <p class="msg">
        Please wait for further communications.
      </p>
    </div>`;
  statusOverlay.style.display = 'grid';
}

function hideServerNotStarted(){
  statusOverlay.style.display = 'none';
}

// ================================ Core Configuration ===================================

/* ---------- load URDF ---------- */
const loader = new URDFLoader();
loader.packages = {                 // map package:// paths ‚Üí server paths
  'trossen_arm_description': 'assets/trossen_arm_description'
};

loader.load(
  'assets/trossen_arm_description/urdf/generated/wxai/wxai_base.urdf',
  async robot => {

    // Set API_BASE_URL dynamically based on environment
    if (location.hostname === 'localhost' || location.hostname === '127.0.0.1') {
      if (location.port === '5173' || location.port === '5174') {
        // Running on Vite dev server - get direct cloudflared URL
        API_BASE_URL = await getCurrentCloudflaredUrl();
        console.log('[DEBUG] Using direct cloudflared URL for Vite dev server:', API_BASE_URL);
      } else {
        // Running on production build locally
        API_BASE_URL = 'http://127.0.0.1:9000';
      }
    } else {
      // Running on deployed Netlify - use function proxy to avoid CORS
      API_BASE_URL = '/.netlify/functions/api';
      console.log('[DEBUG] Using Netlify function proxy for production:', API_BASE_URL);
    }

    console.log('Using API Base URL:', API_BASE_URL);

    // Create a wrapper group to position the robot
    const robotGroup = new THREE.Group();
    robotGroup.position.z = 0.025; // Raise by 0.025 units
    robotGroup.add(robot);
    scene.add(robotGroup);
    
    console.log('[DEBUG] Robot loaded and added to scene with 0.025 offset:', robot);
    console.log('[DEBUG] Robot position:', robot.position);
    console.log('[DEBUG] Robot children count:', robot.children.length);
    console.log('[DEBUG] Scene children count:', scene.children.length);

    /* === Gold tint helpers (applies to both opaque + ghost) ================== */
    const GOLD_HEX           = 0xffc83d;   // warm gold
    const GOLD_EMISSIVE_HEX  = 0x6a4b00;   // subtle warm self-illum

    function applyGoldTintToMaterial(mat, isGhost = false){
      try {
        // Base color
        if (mat.color) mat.color.setHex(GOLD_HEX);

        // Make sure it stays visible on dark camera imagery
        if (mat.emissive){
          mat.emissive.setHex(GOLD_EMISSIVE_HEX);
          mat.emissiveIntensity = isGhost ? 0.65 : 0.40;   // ghost a bit brighter
        }

        // PBR-style materials
        if ('metalness' in mat) mat.metalness = 0.6;
        if ('roughness' in mat) mat.roughness = isGhost ? 0.55 : 0.35;

        // Phong/Lambert fallback
        if ('shininess' in mat) mat.shininess = 30;
        if (mat.specular) mat.specular.setHex(0x222222);

        mat.needsUpdate = true;
      } catch(_) {}
    }

    function applyGoldTint(materialOrArray, isGhost = false){
      if (Array.isArray(materialOrArray)) {
        materialOrArray.forEach(m => applyGoldTintToMaterial(m, isGhost));
      } else if (materialOrArray) {
        applyGoldTintToMaterial(materialOrArray, isGhost);
      }
    }

    // Tint every mesh on the robot now (covers SOLID parts when ghosting is off)
    function tintRobotToGold(root){
      root.traverse(o => {
        if (o.isMesh && o.material) applyGoldTint(o.material, false);
      });
    }

    // Do an immediate pass so the "solid" minimal links are gold from the start
    tintRobotToGold(robot);

    // Which links should be visible outside animation:
    const MINIMAL_LINKS = ['link_6', 'gripper_left', 'gripper_right'];

    // Helpers to flip visibility modes
    function showAllRobotMeshes() {
      robot.traverse(o => { if (o.isMesh) o.visible = true; });
    }
    function showMinimalRobotMeshes() {
      showOnlySpecifiedLinks(robot, MINIMAL_LINKS);
    }

    // ---- Ghosting (semi-transparent) ------------------------------------------
    const GHOST = {
      opacity: 0.42,                 // tweak ghost strength here (0..1)
      origMat: new WeakMap(),        // Mesh -> original material (or array)
      ghostFor: new WeakMap()        // Material -> ghost clone (shared)
    };

    // Utility: is `obj` under any of the given roots?
    function isUnderAny(obj, rootSet) {
      let p = obj;
      while (p) {
        if (rootSet.has(p)) return true;
        p = p.parent;
      }
      return false;
    }

    // Get (or build once) a ghost clone for a material
    function getGhostMaterial(mat) {
      let gm = GHOST.ghostFor.get(mat);
      if (!gm) {
        gm = mat.clone();
        gm.transparent = true;
        gm.opacity = GHOST.opacity;
        gm.depthWrite = false;       // helps avoid z-fighting with opaque parts

        // ‚¨áÔ∏è apply the same gold tint, slightly brighter emissive for readability
        applyGoldTint(gm, true);

        // keep depthTest = true so ghosts still sort reasonably
        if (gm.needsUpdate !== undefined) gm.needsUpdate = true;
        GHOST.ghostFor.set(mat, gm);
      }
      return gm;
    }

    function applyGhostToMesh(mesh) {
      if (!mesh.isMesh || GHOST.origMat.has(mesh)) return;
      const orig = mesh.material;
      GHOST.origMat.set(mesh, orig);
      mesh.material = Array.isArray(orig) ? orig.map(getGhostMaterial) : getGhostMaterial(orig);
    }

    function restoreMeshMaterial(mesh) {
      if (!mesh.isMesh) return;
      const orig = GHOST.origMat.get(mesh);
      if (orig) {
        mesh.material = orig;
        GHOST.origMat.delete(mesh);
        if (mesh.material.needsUpdate !== undefined) mesh.material.needsUpdate = true;
      }
    }

    /**
     * Turn ghosting on/off for everything NOT in MINIMAL_LINKS.
     * Assumes the robot is already visible. Call after showAllRobotMeshes()
     * when enabling, and before showMinimalRobotMeshes() when disabling.
     */
    function setGhostMode(on) {
      // Collect roots for the minimal (fully opaque) subtree(s)
      const minimalRoots = new Set(
        MINIMAL_LINKS.map(n => robot.getObjectByName(n)).filter(Boolean)
      );

      robot.traverse(o => {
        if (!o.isMesh) return;
        const keepOpaque = isUnderAny(o, minimalRoots);
        if (on) {
          if (keepOpaque) {
            restoreMeshMaterial(o);
          } else {
            applyGhostToMesh(o);
            o.visible = true; // ensure non-minimal parts are actually shown
          }
        } else {
          // Turn ghosting off everywhere
          restoreMeshMaterial(o);
        }
      });
    }

    let robotVisible = true;  // toggle visibility of the robot model
    robot.visible = true;     // keep robot always visible
    let toggleRobotBtn = null;

    // --- Visibility policy: use the dragging pattern all the time ---
    let userHasAdjustedPose = true; // always use the dragging appearance pattern

    function revealMinimalRobotFromPose() {
      // Idempotent - call when the user actually adjusts the pose (drag/slider)
      if (!userHasAdjustedPose) userHasAdjustedPose = true;
      if (userHasAdjustedPose) {
        // Show the full robot (body + gripper) and ensure it's opaque.
        robotVisible = true;
        robot.visible = true;
        showAllRobotMeshes();
        setGhostMode(true);    // ‚Üê keep body ghosted like during animation
        if (toggleRobotBtn) toggleRobotBtn.textContent = 'hide robot model';
      }
    }

    function hideRobotCompletely() {
      robotVisible = false;
      robot.visible = false;
    }

    function applyPostAnimationVisibility() {
      // After animation stops, keep the full body visible (opaque) if the user
      // has interacted with the pose; otherwise keep it hidden.
      if (userHasAdjustedPose) {
        robotVisible = true;
        robot.visible = true;
        showAllRobotMeshes();    // full body on
        setGhostMode(true);     // ‚Üê keep body ghosted when Animate is OFF
      } else {
        hideRobotCompletely();
      }
    }

    // Initialize robot with the dragging appearance pattern
    revealMinimalRobotFromPose();




    /* --- build IK tree from URDF (limits copied automatically) --- */
    const ikRoot = urdfRobotToIKRoot(robot);          // :contentReference[oaicite:0]{index=0}

    ikRoot.clearDoF()

    const state = await getInitialState();
    window.__INIT_STATE = state;  // so the recorder can include state_id/episode_id in its /start payload
    
    // After: const state = await getInitialState();
    RECORDING_ALLOWED =
      !!(state?.demo_video?.enabled ?? state?.record_demo_videos ?? state?.flags?.record_demo_videos ?? false);

    console.log(`[recording] ${RECORDING_ALLOWED ? 'enabled (backend flag)' : 'disabled'}`);
    
    bindRecordingHotkeysOnce();
    if (RECORDING_ALLOWED) createRecordingMiniUI();
    const cameraModels = state.camera_models ?? {};
    // If the data collection server isn't available, stop building UI
    if (!state || Object.keys(state).length === 0 || !cameraModels) {
      // Ensure the status overlay is visible and abort UI construction
      showServerNotStarted();
      return; // ‚Üê prevents creating sliders/buttons and starting animation
    }

    /* ---------- build textures from JPEG base64 views --------------- */
    const viewTextures = {}; // 'front' ‚Üí THREE.Texture
    for (const [key, dataUrl] of Object.entries(state.views ?? {})) {
      viewTextures[key] = await makeTextureFromDataURL(dataUrl);
    }



    const initialJointPositions = state.joint_positions ?? {};
    const activeControls        = state.controls ?? ['x','y','z','roll','pitch','yaw'];

    /* ---------- gripper finger-tip calibration (load + state) ---------- */
    const TIP_CAL_LS_KEY = 'wxai_gripper_tip_calib';

    function loadTipCalibFromLS() {
      try { const txt = localStorage.getItem(TIP_CAL_LS_KEY); return txt ? JSON.parse(txt) : null; } catch { return null; }
    }
    function saveTipCalibToLS(obj) {
      try { localStorage.setItem(TIP_CAL_LS_KEY, JSON.stringify(obj)); } catch {}
    }

    // Server-provided values take priority, then localStorage, then defaults
    let tipCalib = (state.gripper_tip_calib && state.gripper_tip_calib.left && state.gripper_tip_calib.right)
      ? JSON.parse(JSON.stringify(state.gripper_tip_calib))
      : (loadTipCalibFromLS() ?? {
          left:  { x: 0.03, y: 0.00, z: 0.00 },
          right: { x: 0.03, y: 0.00, z: 0.00 }
        });

    saveTipCalibToLS(tipCalib); // mirror locally so it's never lost client-side

    // Calibratable local offsets (per finger) that the renderer uses
    const fingerTipLocalLeft  = new THREE.Vector3(tipCalib.left.x,  tipCalib.left.y,  tipCalib.left.z);
    const fingerTipLocalRight = new THREE.Vector3(tipCalib.right.x, tipCalib.right.y, tipCalib.right.z);

    function applyTipCalibToVectors(){
      fingerTipLocalLeft.set (tipCalib.left.x,  tipCalib.left.y,  tipCalib.left.z);
      fingerTipLocalRight.set(tipCalib.right.x, tipCalib.right.y, tipCalib.right.z);
    }

    
    // Update prompt text from server state
    const promptFromServer = state.prompt;
    promptText.textContent = promptFromServer;
    
    // === Example video gating =====================================================
    // Only show video button when there's a VLM-processed video for this specific state
    function getExampleVideoUrlFromState(s){
      return s?.example_video_url
          || s?.example_video?.url
          || s?.prompt_example?.video_url
          || s?.demo_video?.example_url
          || null;
    }

    // --- helper: absolutize /api/... against API_BASE_URL ---
    function resolveExampleVideoUrl(raw) {
      if (!raw) return null;
      // absolute? leave it
      if (/^https?:\/\//i.test(raw)) return raw;
      // relative /api/... ? route through our proxy/base
      if (raw.startsWith('/api/')) return `${API_BASE_URL}${raw}`;
      // anything else (data:, etc.)
      return raw;
    }

    // Only show the button if there's a flex-processed video ID for this state
    const hasFlexVideo = !!(state?.video_prompt);
    const rawExampleUrl = hasFlexVideo ? getExampleVideoUrlFromState(state) : null;
    const exampleUrl = hasFlexVideo ? resolveExampleVideoUrl(rawExampleUrl) : null;

    // Debug logging for video ID
    if (state?.video_prompt) {
      console.log(`üé¨ Example video ID: ${state.video_prompt}`, {
        video_prompt: state.video_prompt,
        video_id: state.video_id, // alias
        rawUrl: rawExampleUrl,
        resolvedUrl: exampleUrl,
        state_id: state.state_id
      });
    }

    if (hasFlexVideo && exampleUrl) {
      // 1) Build the toggle button now (it did not exist before)
      exampleToggle = document.createElement('button');
      exampleToggle.className = 'prompt-example-toggle never-activated';
      exampleToggle.type = 'button';
      exampleToggle.title = 'Show example video';
      exampleToggle.setAttribute('aria-pressed', 'false');
      exampleToggle.innerHTML = `
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 50 50" fill="currentColor" aria-hidden="true">
          <path d="M25,2C12.297,2,2,12.297,2,25s10.297,23,23,23s23-10.297,23-23S37.703,2,25,2z M25,11c1.657,0,3,1.343,3,3s-1.343,3-3,3 s-3-1.343-3-3S23.343,11,25,11z M29,38h-2h-4h-2v-2h2V23h-2v-2h2h4v2v13h2V38z"></path>
        </svg>
      `;
      promptBar.appendChild(exampleToggle);

      // Reserve space on the prompt bar only when the toggle exists
      mount.classList.add('has-example');

      // 2) Build the dock lazily and load the video source (no placeholder fallback)
      createExampleDockOnce();
      exampleDock.innerHTML = '';
      exampleVideo = document.createElement('video');
      exampleVideo.muted = true;
      exampleVideo.loop = true;
      exampleVideo.autoplay = true;
      exampleVideo.playsInline = true;
      exampleVideo.preload = 'auto';
      exampleVideo.crossOrigin = 'anonymous';

      const src = document.createElement('source');
      src.src  = exampleUrl;
      // Use a generic type; servers may emit mp4 or webm depending on encoder
      src.type = '';
      exampleVideo.appendChild(src);
      exampleDock.appendChild(exampleVideo);

      // Do not auto-open the dock; let the user click the toggle
      exampleVideo.addEventListener('error', () => {
        console.error(`‚ùå Example video failed to load (ID: ${state?.video_prompt}):`, exampleVideo?.error, exampleUrl);
      });

      exampleVideo.addEventListener('loadedmetadata', () => {
        // noop; keep dock hidden until user clicks
        console.log(`‚úÖ Example video loaded successfully (ID: ${state?.video_prompt}):`, {
          duration: exampleVideo.duration,
          videoWidth: exampleVideo.videoWidth,
          videoHeight: exampleVideo.videoHeight,
          url: exampleUrl
        });
      });

      exampleVideo.load();

      // Wire the toggle now that it exists
      exampleToggle.addEventListener('click', () => toggleExampleDock());
    } else {
      // No flex video for this state ‚áí do NOT render any example UI at all.
      console.log(`üö´ No example video available for this state:`, {
        state_id: state.state_id,
        video_prompt: state?.video_prompt,
        hasFlexVideo: hasFlexVideo,
        rawExampleUrl: rawExampleUrl
      });
      // Ensure full-width prompt text:
      mount.classList.remove('has-example');
      // Make sure the dock stays gone and we don't set up any layout for it:
      exampleDock = null;
      exampleVideo = null;
      exampleToggle = null;
    }
    
    for (const [name, val] of Object.entries(initialJointPositions)) {
      robot.setJointValue(name, val);
    }

    /* ---------- gripper-motion arrows ---------------------------------- */
    let gripArrows = [];                       // keeps currently-shown arrow meshes
    let gripDir    = state.gripper ?? 0;

    let gripHUDs = [];      // [{ view, el, badge, btn }]
    let poseResetHUDs = []; // [{ view, el }]
    let homeHUDs = [];      // [{ view, el }]

    let hudHiddenForAnimation = false;
    function setHUDHiddenForAnimation(hidden) {
      hudHiddenForAnimation = hidden;
      // Gripper HUDs
      gripHUDs.forEach(({ el }) => {
        if (hidden) el.style.setProperty('display', 'none', 'important');
        else el.style.removeProperty('display');
      });
      // Pose Reset HUDs
      poseResetHUDs.forEach(({ el }) => {
        if (hidden) el.style.setProperty('display', 'none', 'important');
        else el.style.removeProperty('display');
      });
      // Home HUDs
      homeHUDs.forEach(({ el }) => {
        if (hidden) el.style.setProperty('display', 'none', 'important');
        else el.style.removeProperty('display');
      });
    }

    function drawGripArrows(dir /* +1 open | ‚Äì1 close */) {
      /* remove previous arrows */
      gripArrows.forEach(a => scene.remove(a));
      gripArrows.length = 0;

      if (dir !== undefined && dir !== null) {
        gripDir = dir;     // remember last request only if dir is explicitly provided
      }
      
      // Always create arrows, use current gripDir if no direction specified
      const effectiveDir = (dir !== undefined && dir !== null) ? dir : gripDir || 1; // default to open arrows if no direction available
      const colour   = effectiveDir > 0 ? 0x00ff00 : 0xff0000;
      const len      = 0.04, headLen = 0.02;
      const shaftLen = len - headLen, shaftRad = 0.005, offset = 0.03;
      const tipX     = 0.02;

      function addArrow(linkName, outward) {
        const link = robot.getObjectByName(linkName); if (!link) return;
        const dirLocal    = new THREE.Vector3(0, effectiveDir * outward, 0).normalize();
        const baseDist    = effectiveDir > 0 ? offset : offset + len;
        const originLocal = new THREE.Vector3(tipX, outward * baseDist, 0);

        /* geometry ---------------------------------------------------- */
        const mat = new THREE.MeshBasicMaterial({
          color: colour, transparent: true, opacity: 0.95,
          depthTest: false, depthWrite: false
        });
        const grp       = new THREE.Group();
        grp.renderOrder = 1000;
        grp.userData.mat = mat;

        const shaftGeo  = new THREE.CylinderGeometry(shaftRad, shaftRad,
                                                     shaftLen, 8, 1, true);
        const shaft     = new THREE.Mesh(shaftGeo, mat);
        shaft.position.y = shaftLen / 2;
        grp.add(shaft);

        const coneGeo   = new THREE.ConeGeometry(headLen * 0.6, headLen, 8);
        const cone      = new THREE.Mesh(coneGeo, mat);
        cone.position.y = shaftLen + headLen / 2;
        grp.add(cone);

        grp.position.copy(originLocal);
        grp.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dirLocal);
        
        // Add arrows to scene instead of robot links so they're visible even when robot is hidden
        scene.add(grp);
        
        // Store link reference to update arrow position in animation loop
        grp.userData.targetLink = link;
        grp.userData.originLocal = originLocal.clone();
        grp.userData.dirLocal = dirLocal.clone();
        
        gripArrows.push(grp);
      }
      addArrow('gripper_left',  +1);
      addArrow('gripper_right', -1);
    }

    let animating = false;

    function updateGripArrowVisibility() {
      // Visible unless we are animating
      const showArrows = !animating;
      gripArrows.forEach(arrow => {
        if (arrow) arrow.visible = showArrows;
      });
    }

    drawGripArrows(state.gripper ?? 0);        // render initial arrows from server
    updateGripArrowVisibility();               // set initial visibility based on current view

    const initialGripDir = gripDir;

    /* ================== Grip force -> UI + 3D feedback ================== */

    // 1) Read value (Newtons). Missing? We‚Äôll hide the widget.
    let lastGripForceN = (typeof state.left_carriage_external_force === 'number')
      ? state.left_carriage_external_force
      : null;

    function setGripForceN(newN){
      if (typeof newN !== 'number' || !Number.isFinite(newN)) return;
      lastGripForceN = newN;
      updateGripHUDState();
    }

    let forcePollTimer = null;

    function extractForceN(s){
      // Prefer left carriage; fall back to other likely names if your backend differs
      const candidates = [
        s?.left_carriage_external_force,
        s?.right_carriage_external_force,
        s?.gripper_force_n,
        s?.gripper_force,
        s?.force_n,
        s?.forceN
      ];
      return candidates.find(v => typeof v === 'number' && Number.isFinite(v));
    }

    function startForcePolling(intervalMs = 250){
      stopForcePolling();
      forcePollTimer = setInterval(async ()=>{
        try{
          const resp = await apiFetch(`/api/monitor/latest-state`, { headers: { 'Accept':'application/json' } });
          if (!resp.ok) return;
          const s = await resp.json();
          const v = extractForceN(s);
          if (typeof v === 'number') setGripForceN(v);
        }catch(_){ /* ignore transient errors */ }
      }, intervalMs);
    }

    function stopForcePolling(){
      if (forcePollTimer){ clearInterval(forcePollTimer); forcePollTimer = null; }
    }

    window.addEventListener('visibilitychange', ()=>{
      if (document.hidden) stopForcePolling(); else startForcePolling();
    });
    window.addEventListener('beforeunload', stopForcePolling);

    function clamp01(x){ return Math.max(0, Math.min(1, x)); }

    // 3) Minimal widget in the controls column
    function createForceWidget(parent){
      const box = document.createElement('div');
      box.className = 'force-widget';
      const row = document.createElement('div'); row.className = 'force-row';
      const label = document.createElement('div'); label.textContent = 'Grip Pressure';
      const pill = document.createElement('div'); pill.className = 'force-pill free'; pill.textContent = 'free';
      row.append(label, pill);
      const bar = document.createElement('div'); bar.className = 'force-bar';
      const fill = document.createElement('div'); fill.className = 'fill';
      bar.appendChild(fill);
      const val = document.createElement('div'); val.style.font = '600 12px system-ui'; val.style.color = '#4b5563';

      box.append(row, bar, val);
      parent.insertBefore(box, parent.firstChild); // show above sliders

      function setBadge(status){
        pill.classList.remove('free','contact','grasped');
        pill.classList.add(status);
        pill.textContent = (status === 'grasped' ? 'grasped' : status);
        box.style.animation = (status === 'grasped') ? 'forcePulse 1.5s ease-in-out infinite' : 'none';
      }

      return {
        hide(){ box.style.display = 'none'; },
        show(){ box.style.display = 'block'; },
        update(forceN, status){
          const absF = Math.abs(forceN || 0);
          setBadge(status);
          // Scale bar to ~1.4√ó the single grasp threshold
          const denom = Math.max(GRASP_THRESHOLD_N * 1.4, 1);
          fill.style.width = `${clamp01(absF / denom) * 100}%`;
          val.textContent = `Grip strength: ${absF.toFixed(1)} N`;
        }
      };
    }
    const forceUI = createForceWidget(controlsContainer);

    forceUI.hide();

    // 4) Classification + 3D adornment
    function classifyGrip(forceN){
      const f = forceN ?? 0;
      if (!Number.isFinite(f)) return 'free';
      return (f < -GRASP_THRESHOLD_N) ? 'grasped' : 'free';
    }

    // Visuals: keep arrow color tied to commanded state (open/close).
    function applyGripVisual(status, forceN){
      const baseColor = (gripDir > 0 ? 0x00ff00 : 0xff0000); // open=green, close=red
      const opacity   = 0.95;
      const strength  = (status === 'grasped') ? 1 : 0;       // simple 0/1

      gripArrows.forEach(a => {
        if (!a) return;
        const lenScale = 1 + 0.6 * strength;  // emphasize when grasped
        a.scale.set(1, lenScale, 1);
        const mat = a.userData?.mat;
        if (mat){
          mat.color.setHex(baseColor);
          mat.opacity = opacity;
          mat.needsUpdate = true;
        }
      });
    }

    // 5) Drive UI from this state (and record to history)
    (function initGripForce(){
      updateGripHUDState();

      const _origOnGripperChange = onGripperChange;
      onGripperChange = function(newDir){
        _origOnGripperChange(newDir);
        updateGripHUDState();
      };
    })();

    let gui = null;

    let guiShield = null;  // invisible overlay to block pointer input on lil-gui
    
    // Create gripper controls container (will be added after sliders)
    let gripperButtonsContainer = null;
    let openBtn = null, closeBtn = null; // Store button references for state updates
    
    function updateGripperButtonStates() {
      if (!openBtn || !closeBtn) return;
      
      // Remove all state classes first
      openBtn.classList.remove('active', 'inactive');
      closeBtn.classList.remove('active', 'inactive');
      
      // Apply states based on current gripper direction
      if (gripDir > 0) { // Open
        openBtn.classList.add('active');
        closeBtn.classList.add('inactive');
      } else { // Close
        openBtn.classList.add('inactive');
        closeBtn.classList.add('active');
      }
    }

    function updateGripperInteractivity() {
      if (!openBtn || !closeBtn) return;

      if (taskCompletedSelected) {
        openBtn.disabled = true;
        closeBtn.disabled = true;

        const msg = 'Gripper disabled: "Task Already Completed" is selected.';
        openBtn.title = msg;
        closeBtn.title = msg;

        openBtn.classList.add('inactive'); openBtn.classList.remove('active');
        closeBtn.classList.add('inactive'); closeBtn.classList.remove('active');
        return;
      }

      const atDefault = slidersAtDefault();
      openBtn.disabled = !atDefault;
      closeBtn.disabled = !atDefault;

      const changed = getChangedAxes();
      const hoverMsg = atDefault
        ? 'You can change the gripper state.'
        : `Gripper locked: pose sliders changed (${changed.join(', ')}). Reset sliders to their starting values to change the gripper.`;

      openBtn.title = hoverMsg;
      closeBtn.title = hoverMsg;

      const label = document.querySelector('.gripper-label');
      if (label) label.title = hoverMsg;

      if (!atDefault) {
        openBtn.classList.add('inactive'); openBtn.classList.remove('active');
        closeBtn.classList.add('inactive'); closeBtn.classList.remove('active');
      } else {
        updateGripperButtonStates();
      }

      updateGripHUDInteractivity();
    }


    // --- Task Already Completed availability + global lock orchestration ---
    let taskCompletedBlocked = false;  // becomes true if any slider or gripper is changed

    function setTaskCompletedBlocked(blocked){
      taskCompletedBlocked = blocked;
      if (taskCompletedBtn){
        taskCompletedBtn.disabled = blocked;
        taskCompletedBtn.classList.toggle('blocked', blocked);

        // Update hover/title text to explain why it‚Äôs blocked/available
        const changed = getChangedAxes();
        const gripperChanged = (gripDir !== initialGripDir);
        if (blocked){
          const parts = [];
          if (changed.length) parts.push(`slider changes: ${changed.join(', ')}`);
          if (gripperChanged) parts.push('gripper changed');
          taskCompletedBtn.title = `Blocked - ${parts.join(' & ')}. Reset sliders and gripper to enable.`;
        }else{
          taskCompletedBtn.title = taskCompletedSelected
            ? 'Selected--task already completed--press Confirm to submit'
            : 'Not selected. Press to select, then press Confirm to submit.';
        }
      }
    }

    function updateTaskCompletedAvailability(){
      // Block if any user change from the original state
      const shouldBlock = !slidersAtDefault() || (gripDir !== initialGripDir);
      setTaskCompletedBlocked(shouldBlock);
    }

    function recomputeLocks(){
      // Sliders are locked if TAC is selected OR the gripper is not at its original state
      const lock = taskCompletedSelected || (gripDir !== initialGripDir);
      setSlidersLocked(lock);

      // Explain why the panel is locked
      if (controlsContainer){
        controlsContainer.title = taskCompletedSelected
          ? 'Pose sliders are locked because ‚ÄúTask Already Completed‚Äù is selected.'
          : (gripDir !== initialGripDir ? 'Pose sliders are locked because the gripper state was changed.' : '');
      }

      // Gripper buttons disabled when TAC is selected (regardless of sliders)
      updateGripperInteractivity();
    }


    function setSlidersLocked(locked) {
      slidersLocked = locked;

      // Disable lil-gui range + number inputs (if visible in dev mode)
      const ranges  = controlsContainer.querySelectorAll('.lil-gui input[type="range"]');
      const numbers = controlsContainer.querySelectorAll('.lil-gui input[type="number"]');
      ranges.forEach(el  => { el.disabled = locked; });
      numbers.forEach(el => { el.disabled = locked; });

      // Disable the tiny reset buttons we append to each controller
      const resetBtns = controlsContainer.querySelectorAll('.lil-gui .reset-btn');
      resetBtns.forEach(btn => { btn.disabled = locked; });

      // Dim the panel
      if (gui && gui.domElement) {
        gui.domElement.classList.toggle('locked', locked);

        // Create an invisible shield that catches all pointer events
        if (!guiShield) {
          guiShield = document.createElement('div');
          Object.assign(guiShield.style, {
            position: 'absolute',
            inset: '0',
            zIndex: '2',
            cursor: 'not-allowed',
            background: 'transparent',
            display: 'none',
          });
          // Ensure the lil-gui container is positioned for absolute child
          const s = gui.domElement.style;
          if (!s.position || s.position === 'static') s.position = 'relative';
          gui.domElement.appendChild(guiShield);
        }
        guiShield.style.display = locked ? 'block' : 'none';
      }

      // Panel tooltip
      controlsContainer.title = locked
        ? 'Pose sliders are locked because the gripper state was changed.'
        : '';
    }
    
    
    function onGripperChange(newDir) {
      // START recording on first state-altering action
      maybeRecord('gripper-change');
      
      cancelAnimationIfRunning('gripper changed');
      gripDir = newDir;                         // Update the current gripper direction
      drawGripArrows(newDir);
      updateGripArrowVisibility();
      updateGripperButtonStates();

      // Any gripper change blocks "Task Already Completed" until reset
      updateTaskCompletedAvailability();

      // Lock/unlock sliders considering both gripper change and TAC selection
      recomputeLocks();
      updateGripHUDState();
      updateGripHUDInteractivity();
    }

    
    if (activeControls.includes('gripper')) {
      gripperButtonsContainer = document.createElement('div');
      gripperButtonsContainer.className = 'gripper-section';
      
      const gripperLabel = document.createElement('div');
      gripperLabel.className = 'gripper-label';
      gripperLabel.textContent = 'gripper';
      gripperButtonsContainer.appendChild(gripperLabel);
      
      const buttonsContainer = document.createElement('div');
      buttonsContainer.className = 'gripper-buttons';
      
      openBtn = document.createElement('button');
      openBtn.textContent = 'Open';
      openBtn.className = 'open-btn';
      openBtn.onclick = () => {
        onGripperChange(+1);
      };
      
      closeBtn = document.createElement('button');
      closeBtn.textContent = 'Close';
      closeBtn.className = 'close-btn';
      closeBtn.onclick = () => {
        onGripperChange(-1);
      };
      
      buttonsContainer.appendChild(openBtn);
      buttonsContainer.appendChild(closeBtn);
      gripperButtonsContainer.appendChild(buttonsContainer);
    }

    const camPoses = state.camera_poses ?? {}

    // --- Intrinsics ‚Üí projection helper (use Knew from backend) ---
    function applyProjectionFromK(view) {
      const model = view.model;
      const camera = view.camera;
      if (!model || !model.Knew || !model.width || !model.height) {
        return false;
      }
      const K = model.Knew;       // 3x3 (row-major)
      const W = model.width|0;
      const H = model.height|0;
      const near = camera.near, far = camera.far;

      // Scale intrinsics to current viewport (CSS) size
      const sz = new THREE.Vector2();
      view.renderer.getDrawingBufferSize(sz);
      const vw = sz.x, vh = sz.y;
      const sx = vw / W, sy = vh / H;

      // Check if this is an orthographic camera
      if (model.projection_type === 'orthographic') {
        // Use exact orthographic projection parameters from calibration
        const orthoWidth = model.orthographic_width || 1.0;
        const orthoHeight = model.orthographic_height || 1.0;
        
        // Use the calibrated dimensions exactly as specified
        const left = -orthoWidth / 2;
        const right = orthoWidth / 2;
        const top = orthoHeight / 2;
        const bottom = -orthoHeight / 2;
        
        const P = new THREE.Matrix4().makeOrthographic(left, right, top, bottom, near, far);
        camera.projectionMatrix.copy(P);
        camera.projectionMatrixInverse.copy(P).invert();
        camera.projectionMatrixAutoUpdate = false;
        return true;
      } else {
        // Use perspective projection (original code)
        const fx = K[0][0] * sx, fy = K[1][1] * sy;
        const cx = K[0][2] * sx, cy = K[1][2] * sy;

        // OpenCV pixels (origin top-left, +y down) ‚Üí Three frustum (y up)
        const left   = -cx * near / fx;
        const right  =  (vw - cx) * near / fx;
        const top    =  cy * near / fy;
        const bottom = -(vh - cy) * near / fy;

        const P = new THREE.Matrix4().makePerspective(left, right, top, bottom, near, far);
        camera.projectionMatrix.copy(P);
        camera.projectionMatrixInverse.copy(P).invert();
        camera.projectionMatrixAutoUpdate = false;
        return true;
      }
    }

    function applyDefaultPerspective(view) {
      const camera = view.camera;
      camera.projectionMatrixAutoUpdate = true;
      camera.fov = 45;
      camera.aspect = 1; // Will be updated when renderer size is set
      camera.updateProjectionMatrix();
    }

    function updateViewCamera(view, pose) {
      if (!pose) return false;
      
      const m = poseToMatrix(pose);
      const pos   = new THREE.Vector3();
      const quat  = new THREE.Quaternion();
      const scale = new THREE.Vector3();
      m.decompose(pos, quat, scale);

      view.camera.position.copy(pos);
      view.camera.quaternion.copy(quat);
      view.camera.updateMatrixWorld();
      
      return true;
    }



    function addCameraVisualization() {
      // Remove any existing camera visualizations
      const existingCameras = scene.children.filter(child => child.userData.isCameraVisualization);
      existingCameras.forEach(cam => scene.remove(cam));
      
      // Add visual representations of ALL cameras (including front)
      Object.keys(camPoses).forEach(poseKey => {
        const viewName = poseKey.replace('_pose', '');
        const pose = camPoses[poseKey];
        if (!pose) return;
        
        // Get the view to check camera type
        const view = views.get(viewName);
        let helperCamera;
        
        if (view && view.model && view.model.projection_type === 'orthographic') {
          // Create orthographic camera for helper
          const orthoWidth = view.model.orthographic_width || 1.0;
          const orthoHeight = view.model.orthographic_height || 1.0;
          helperCamera = new THREE.OrthographicCamera(
            -orthoWidth/2, orthoWidth/2,    // left, right
            orthoHeight/2, -orthoHeight/2,  // top, bottom  
            0.1, 1                          // near, far
          );
        } else {
          // Create perspective camera for helper (default)
          helperCamera = new THREE.PerspectiveCamera(45, 1, 0.1, 1);
        }
        
        // Create camera helper
        const cameraHelper = new THREE.CameraHelper(helperCamera);
        
        // Apply camera pose
        const m = poseToMatrix(pose);
        cameraHelper.matrix.copy(m);
        cameraHelper.matrixAutoUpdate = false;
        
        // Color code cameras (including front)
        const colors = {
          'front': 0xffff00,         // Yellow
          'left': 0xff0000,          // Red
          'right': 0x00ff00,         // Green  
          'perspective': 0x0000ff    // Blue
        };
        cameraHelper.material.color.setHex(colors[viewName] || 0xffffff);
        
        // Mark as camera visualization for easy removal
        cameraHelper.userData.isCameraVisualization = true;
        
        scene.add(cameraHelper);
        
        const cameraType = view && view.model && view.model.projection_type === 'orthographic' ? 'orthographic' : 'perspective';
        console.log(`[DEBUG] Added ${cameraType} camera visualization for ${viewName} at`, new THREE.Vector3().setFromMatrixPosition(m));
      });
    }



    /* ---------- calibration helpers (intrinsics & extrinsics) ------- */
    function showOnlySpecifiedLinks(robot, keepNames /* array of link names */) {
      const keep = new Set(keepNames);

      // 1) Hide every mesh under the robot (visual + collision)
      robot.traverse(o => {
        if (o.isMesh) o.visible = false;
      });

      // 2) Re-enable meshes that live under the allowed link groups
      keep.forEach(name => {
        const link = robot.getObjectByName(name);
        if (!link) {
          console.warn(`[showOnlySpecifiedLinks] link "${name}" not found`);
          return;
        }
        link.traverse(o => {
          if (o.isMesh) o.visible = true;
        });
      });

      // Important: DO NOT set .visible=false on any parent links in the chain.
      // We only hide their meshes so children (e.g., link_6 ‚Üí carriages ‚Üí grippers)
      // still receive correct transforms from the kinematics.
    }

    setIKFromUrdf(ikRoot, robot);
    ikRoot.updateMatrixWorld(true);

    /* --- locate the end-effector link inside IK tree --- */
    let ee = null;
    
    ikRoot.traverse(child => {                        // Frame.traverse
      if ( child.name === 'ee_gripper_link' ) { ee = child; return true; }
    });

    /* --- create a translation-only Goal --- */
    const goal = new Goal();
    goal.setDoF(DOF.X, DOF.Y, DOF.Z, DOF.EX, DOF.EY, DOF.EZ);

    goal.makeClosure( ee );                          // link goal ‚Üî ee

    /* ---- sample the **visual** EE pose after matrices are fresh */
    const startPos  = new THREE.Vector3();
    const startQuat = new THREE.Quaternion();

    robot.updateMatrixWorld( true );                 // propagate world mats
    const eeVis = robot.getObjectByName( 'ee_gripper_link' );
    eeVis.getWorldPosition   ( startPos  );
    eeVis.getWorldQuaternion ( startQuat );

    goal.setPosition   ( startPos.x, startPos.y, startPos.z );
    goal.setQuaternion ( startQuat.x, startQuat.y, startQuat.z, startQuat.w );

    /* ===== Animate button + loop state ===== */
    // Backend-driven animation state
    const backendAnimState = {
      active: false,           // Whether backend animation is running
      streaming: false,        // Whether we're streaming frames
      user_id: null,          // Assigned animation slot
      last_frame_time: 0,     // For frame rate limiting
      frame_interval: 100     // 10 FPS (100ms between frames)
    };
    
    // Keep legacy animState for compatibility with other parts of code
    const animState = {
      enabled: false,
      t: 0,
      duration: 2000,     // ms start ‚Üí target
      lastTs: 0,
      phase: 'forward',   // 'forward' | 'hold'
      holdMs: 250,        // 0.25 s at goal
      holdElapsed: 0
    };

    let cancelAnimationIfRunning = () => {};

    // Reusable temporaries for interpolation (avoid per-frame allocations)
    const _interpPos  = new THREE.Vector3();
    const _interpQuat = new THREE.Quaternion();

    // --- temp for animation math ---
    const _segCurrEE = new THREE.Vector3();

    // Compute the *target* pose from current user params.
    // We purposely derive orientation from baseQuat + (roll,pitch,yaw)
    // instead of reusing currentQuat to avoid drift.
    function getTargetPose() {
      // Always return the latest interactive target (local-frame orientation)
      return { pos: targetPose.pos, quat: targetPose.quat };
    }

    // ===== Backend Animation Control =====
    
    async function startBackendAnimation() {
      try {
        // Get current joint positions from IK solver result
        const jointMap = {};
        Object.entries(robot.joints).forEach(([name, joint]) => {
          // joint.jointValue is an array with a single element, extract the numeric value
          const value = Array.isArray(joint.jointValue) && joint.jointValue.length > 0 
            ? joint.jointValue[0] 
            : (joint.jointValue || 0.0);
          console.log(`üîç Joint ${name}: jointValue =`, joint.jointValue, `‚Üí extracted: ${value} (${typeof value})`);
          jointMap[name] = value;
        });
        
        // Convert to array format expected by backend (7 joint values)
        const jointNames = ['joint_0', 'joint_1', 'joint_2', 'joint_3', 'joint_4', 'joint_5', 'left_carriage_joint'];
        const goalJoints = jointNames.map(name => {
          const value = jointMap[name] || 0.0;
          console.log(`üîç Goal joint ${name}: ${value} (type: ${typeof value})`);
          return value;
        });
        
        console.log('Starting backend animation with goal joints:', goalJoints);
        console.log('Goal joints types:', goalJoints.map(v => typeof v));
        
        const response = await apiFetch('/api/animation/start', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            goal_joints: goalJoints,
            duration: 3.0  // 3 second animation
          })
        });
        
        const result = await response.json();
        
        if (result.status === 'success') {
          backendAnimState.active = true;
          backendAnimState.user_id = result.user_id;
          backendAnimState.streaming = true;
          backendAnimState.last_frame_time = 0;
          
          console.log(`‚úì Animation started - assigned slot ${result.user_id}`);
          return true;
        } else {
          console.error('‚ùå Animation start failed:', result.message);
          alert(`Animation failed: ${result.message}`);
          return false;
        }
        
      } catch (error) {
        console.error('‚ùå Animation API error:', error);
        alert('Animation failed - server error');
        return false;
      }
    }
    
    async function stopBackendAnimation() {
      try {
        if (!backendAnimState.active) return;
        
        // Immediately update local state for instant feedback
        backendAnimState.active = false;
        backendAnimState.streaming = false;
        backendAnimState.user_id = null;
        
        console.log('‚úì Animation state updated immediately');
        
        // Send stop request to backend (but don't wait for response)
        const response = await apiFetch('/api/animation/stop', {
          method: 'POST'
        });
        
        const result = await response.json();
        
        if (result.status === 'success') {
          console.log('‚úì Backend animation stop confirmed');
        } else {
          console.error('‚ùå Backend animation stop failed:', result.message);
          // Backend failed, but we already updated UI - that's fine
        }
        
      } catch (error) {
        console.error('‚ùå Animation stop error:', error);
        // Backend failed, but we already updated UI - that's fine
      }
    }
    
    async function captureAnimationFrame() {
      try {
        if (!backendAnimState.streaming) return;
        
        const now = Date.now();
        if (now - backendAnimState.last_frame_time < backendAnimState.frame_interval) {
          return; // Rate limiting
        }
        
        const response = await apiFetch('/api/animation/frame');
        const result = await response.json();
        
        console.log('üé¨ Animation frame response:', result);
        
        if (result.status === 'success') {
          backendAnimState.last_frame_time = now;
          
          // Update camera views with new frames
          updateViewsWithAnimationFrames(result.result);
        } else {
          console.warn('‚ö†Ô∏è Frame capture failed:', result.message);
        }
        
      } catch (error) {
        console.error('‚ùå Frame capture error:', error);
      }
    }
    
    function updateViewsWithAnimationFrames(frameData) {
      // frameData contains paths to animation frame images
      // Update the existing camera views with new images
      console.log('üñºÔ∏è Updating views with frame data:', frameData);
      
      if (!frameData) {
        console.warn('‚ö†Ô∏è No frame data received');
        return;
      }
      
      // Map result keys to view names
      const frameToView = {
        'front': 'front',
        'left': 'left', 
        'right': 'right',
        'top': 'top'
      };
      
      for (const [frameKey, viewName] of Object.entries(frameToView)) {
        console.log(`üîç Checking frameKey: ${frameKey}, viewName: ${viewName}`);
        console.log(`üîç frameData has key: ${frameData.hasOwnProperty(frameKey)}`);
        console.log(`üîç views has view: ${views.has(viewName)}`);
        
        if (frameData[frameKey] && views.has(viewName)) {
          const view = views.get(viewName);
          console.log(`üé• Updating ${viewName} view with animation frame`);
          // Load the new image and update the texture
          updateViewTexture(view, frameData[frameKey]);
        } else if (frameData[frameKey]) {
          console.warn(`‚ö†Ô∏è View ${viewName} not found for frame ${frameKey}`);
        } else {
          console.warn(`‚ö†Ô∏è Frame data missing key ${frameKey}`);
        }
      }
    }
    
    async function updateViewTexture(view, imageData) {
      try {
        // For animation frames, we need to update the CSS background image
        // imageData should be a base64 data URL like "data:image/jpeg;base64,..."
        
        console.log(`üñºÔ∏è  updateViewTexture called for view:`, view.name);
        console.log(`üñºÔ∏è  Container element:`, view.container);
        console.log(`üñºÔ∏è  Base64 data length:`, imageData.length);
        console.log(`üñºÔ∏è  Base64 preview:`, imageData.substring(0, 50) + '...');
        
        // Update the container's background image to show the new animation frame
        if (view.container) {
          const oldBackground = view.container.style.background;
          view.container.style.background = `center / cover no-repeat url("${imageData}")`;
          console.log(`üñºÔ∏è  Old background:`, oldBackground);
          console.log(`üñºÔ∏è  New background set to:`, view.container.style.background.substring(0, 50) + '...');
          console.log(`‚úì Updated ${view.name} with animation frame`);
        } else {
          console.warn(`‚ö†Ô∏è View ${view.name} has no container to update`);
        }
        
      } catch (error) {
        console.error(`‚ùå Error updating ${view.name} texture:`, error);
      }
    }

    // Toggle animation ON/OFF - now uses backend
    // Toggle animation ON/OFF - now uses backend
    async function toggleAnimation() {
      if (backendAnimState.active) {
        // OPTIMIZATION: Immediately update UI for instant visual feedback
        // Don't wait for backend confirmation to make transition feel instant
        animateBtn.classList.remove('active');
        animState.enabled = false;
        animating = false;
        updateGripArrowVisibility();
        
        // IMPORTANT: Immediately show Three.js robot and stop streaming
        robotVisible = true;
        robot.visible = true;
        if (toggleRobotBtn) toggleRobotBtn.textContent = 'hide robot model';
        
        // Stop Isaac Sim frame streaming immediately
        backendAnimState.streaming = false;
        
        // Restore UI elements immediately  
        setPoseGizmosVisible(true);
        applyPostAnimationVisibility();
        setHUDHiddenForAnimation(false);
        
        console.log('‚úÖ Animation UI updated immediately - Three.js robot visible');
        
        // Backend cleanup in background (don't await to avoid lag)
        stopBackendAnimation().then(() => {
          console.log('‚úÖ Backend animation cleanup completed');
        }).catch(error => {
          console.error('‚ùå Backend animation cleanup failed:', error);
        });
        
        // Refresh views in background for updated static images (don't await)
        refreshViews().then(() => {
          console.log('‚úÖ Static views refreshed');
        }).catch(error => {
          console.error('‚ùå Static views refresh failed:', error);
        });
        
      } else {
        // Start backend animation
        const success = await startBackendAnimation();
        
        if (success) {
          // Update UI for animation mode
          animateBtn.classList.add('active');
          animState.enabled = false; // Disable frontend animation - only use backend
          animating = true;
          updateGripArrowVisibility();
          
          // Hide UI elements during animation
          setPoseGizmosVisible(false);
          setHUDHiddenForAnimation(true);
          
          // IMPORTANT: Hide Three.js robot and start Isaac Sim streaming
          robotVisible = false;
          robot.visible = false;
          if (toggleRobotBtn) toggleRobotBtn.textContent = 'show robot model';
          
          // Start Isaac Sim frame streaming
          backendAnimState.streaming = true;
          
          console.log('‚úÖ Animation started - hiding Three.js robot and streaming Isaac Sim');
        }
      }
    }


    /* ---------- semi-transparent alignment line -------------------- */
    const lineLen = 0.80;      // meters
    const lineRad = 0.002;     // thickness
    const lineOffX = - 0.01;
    // --- cache & helpers for fast updates (no per-frame allocs) ---
    const baseLineLen = lineLen; // baseline length for scaling helper lines
    const floorZ      = 0.0;      // ground plane (Z-up)
    const bottomPad   = 0.0005;   // tiny lift to avoid z-fighting
    const _eePosTmp   = new THREE.Vector3();

    /* ---------- two yellow drop lines from gripper finger tips ---------- */

    // If you want the lines to end at exactly z=0, keep this at 0.0.
    // If you see z-fighting flicker, bump it up slightly (e.g., 0.0005).
    const fingerBottomPad = 0.0;

    // Shared yellow material (semi-transparent)
    const fingerLineMat = new THREE.MeshBasicMaterial({
      color: 0xffcc00, transparent: true, opacity: 0.95
    });

    // Helper to build a vertical cylinder whose local Y maps to world Z (like the green line)
    function makeDownLine(material){
      const m = new THREE.Mesh(
        new THREE.CylinderGeometry(lineRad, lineRad, lineLen, 8, 1, true),
        material
      );
      m.rotation.x = Math.PI / 2;   // align cylinder Y ‚Üí world Z
      m.visible = false;
      scene.add(m);
      return m;
    }

    const leftFingerLine  = makeDownLine(fingerLineMat);
    const rightFingerLine = makeDownLine(fingerLineMat);

    // Cache references to the finger links in the URDF
    // (Rename here if your URDF uses different link names)
    const leftFingerLink  = robot.getObjectByName('gripper_left');
    const rightFingerLink = robot.getObjectByName('gripper_right');


    /* ---- XY cross at the target pose (keeps the same drag proxy) --------- */
    // === CROSS MARKER (visual only; keeps your existing drag proxy) =============

    // Use your existing Group that represents the goal/marker. If you do not have
    // one, create it and keep your existing drag "proxy" mesh as-is.
    const marker = new THREE.Group();

    // If you created a new one, ensure it's added and positioned at your initial target.
    if (!marker.parent) {
      marker.position.copy(startPos);        // <- replace with your initial
      marker.quaternion.copy(startQuat);    // <- replace with your initial
      scene.add(marker);
    }

    // Remove any old cross meshes if you had them:
    const oldCross = marker.getObjectByName('marker_cross');
    if (oldCross) oldCross.parent.remove(oldCross);

    // New cross: two thin bars along local X and Y; always-on-top over camera textures
    const CROSS_LEN   = 0.10;    // 10 cm total length
    const CROSS_THICK = 0.005;   // 5 mm thickness
    const crossMat = new THREE.MeshBasicMaterial({
      color: 0xff0000, transparent: true, opacity: 0.85, depthTest: false, depthWrite: false
    });

    const xBar = new THREE.Mesh(new THREE.BoxGeometry(CROSS_THICK, CROSS_THICK, CROSS_LEN), crossMat);
    const yBar = new THREE.Mesh(new THREE.BoxGeometry(CROSS_THICK, CROSS_LEN,  CROSS_THICK), crossMat);

    // IMPORTANT: Do not let the cross be pickable. Keep your existing invisible sphere/mesh as the
    // drag "hit area" (proxy).
    xBar.raycast = () => {};
    yBar.raycast = () => {};

    const crossGroup = new THREE.Group();
    crossGroup.name = 'marker_cross';
    crossGroup.renderOrder = 1001; // above wheels (999) and arrows (1000)
    crossGroup.add(xBar, yBar);
    marker.add(crossGroup);

    // Keep (or create) your pick proxy:
    let pickProxy = marker.getObjectByName('marker_pick_proxy');
    if (!pickProxy) {
      pickProxy = new THREE.Mesh(
        new THREE.SphereGeometry(0.04, 16, 16), // ~4 cm hit radius
        new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0, depthWrite: false })
      );
      pickProxy.name = 'marker_pick_proxy';
      marker.add(pickProxy);
    }

    // === ROTATION WHEELS (world-space radii; scale visually with distance) =====

    const rotationWheels = {};   // { roll:{group, segments:Mesh[]}, pitch:{...}, yaw:{...} }
    let rotationPickables = [];  // flat array of the segment meshes for raycasting

    // Opacity states for visual feedback
    const WHEEL_OPACITY = {
      idle:   { even: 0.44, odd: 0.24 },
      hover:  { even: 0.64, odd: 0.44 },
      active: { even: 0.84, odd: 0.64 },
    };

    // Build one ring ("striped annulus") in world units (meters)
    function makeWheel(axisName, colorHex, innerR = 0.085, outerR = 0.105, strips = 48) {
      const group = new THREE.Group();
      group.name = `wheel_${axisName}`;
      group.userData.axis = axisName;
      group.renderOrder = 999; // always on top

      const segments = [];
      const segAngle = (Math.PI * 2) / strips;
      const gap = segAngle * 0.08;
      const thetaLen = segAngle - gap;

      for (let i = 0; i < strips; i++) {
        const thetaStart = i * segAngle + gap * 0.5;
        const geom = new THREE.RingGeometry(innerR, outerR, 18, 1, thetaStart, thetaLen);
        const mat  = new THREE.MeshBasicMaterial({
          color: colorHex, transparent: true,
          opacity: (i % 2 === 0 ? WHEEL_OPACITY.idle.even : WHEEL_OPACITY.idle.odd),
          side: THREE.DoubleSide,
          depthTest: false
        });
        const seg = new THREE.Mesh(geom, mat);
        seg.userData.axis = axisName;
        group.add(seg);
        segments.push(seg);
      }

      return { group, segments };
    }

    function setWheelState(axis, state) {
      const w = rotationWheels[axis]; if (!w) return;
      const cfg = WHEEL_OPACITY[state] || WHEEL_OPACITY.idle;
      w.segments.forEach((seg, i) => {
        seg.material.opacity = (i % 2 === 0 ? cfg.even : cfg.odd);
        seg.material.needsUpdate = true;
      });
    }
    function resetAllWheelStates() {
      ['roll', 'pitch', 'yaw'].forEach(a => setWheelState(a, 'idle'));
    }

    // Build wheels for the controls you actually expose
    function buildRotationWheels() {
      // Clear any existing wheels first
      Object.values(rotationWheels).forEach(w => {
        if (w && w.group && w.group.parent) {
          w.group.parent.remove(w.group);
        }
      });
      
      // Reset the rotationWheels object
      Object.keys(rotationWheels).forEach(key => delete rotationWheels[key]);
      rotationPickables.length = 0;

      // Feel free to reuse these axis colors
      const colorFor = { roll: 0xff5b5b, pitch: 0x22cc88, yaw: 0x4f8cff };

      // Only create wheels for rotation axes that are actually enabled
      const rotationAxes = ['roll','pitch','yaw'].filter(axis => 
        activeControls && activeControls.includes(axis)
      );
      
      console.log('Building rotation wheels for axes:', rotationAxes);
      
      rotationAxes.forEach(axis => {
        const { group, segments } = makeWheel(axis, colorFor[axis]);
        scene.add(group);
        rotationWheels[axis] = { group, segments };
        rotationPickables.push(...segments);
        console.log(`Created wheel for ${axis} with ${segments.length} segments`);
      });

      resetAllWheelStates();
    }

    // === math helpers to align wheels to marker local axes ======================

    function localAxesWorld(q /* THREE.Quaternion */) {
      return {
        xW: new THREE.Vector3(1,0,0).applyQuaternion(q).normalize(),
        yW: new THREE.Vector3(0,1,0).applyQuaternion(q).normalize(),
        zW: new THREE.Vector3(0,0,1).applyQuaternion(q).normalize(),
      };
    }

    function planeBasisForAxis(axis /* 'roll'|'pitch'|'yaw' */, q) {
      const { xW, yW, zW } = localAxesWorld(q || marker.quaternion);
      if (axis === 'roll')   return { n: xW, u: yW, v: zW }; // rotate about local X ‚Üí YZ plane
      if (axis === 'pitch')  return { n: yW, u: zW, v: xW }; // rotate about local Y ‚Üí XZ plane
      /* yaw */              return { n: zW, u: xW, v: yW }; // rotate about local Z ‚Üí XY plane
    }

    function alignRingToNormal(group, n) {
      const from = new THREE.Vector3(0,0,1); // RingGeometry faces +Z by default
      const q = new THREE.Quaternion().setFromUnitVectors(from, n);
      group.quaternion.copy(q);
      group.updateMatrixWorld(true);
    }

    function angleOnPlaneFromPoint(p, center, u, v) {
      const r = p.clone().sub(center);
      return Math.atan2(r.dot(v), r.dot(u));
    }
    function normalizeAngle(a) {
      while (a >  Math.PI) a -= Math.PI * 2;
      while (a < -Math.PI) a += Math.PI * 2;
      return a;
    }

    // Build them once, after the marker exists:
    buildRotationWheels();

    function createGripHUDForView(view){
      const hud = document.createElement('div');
      hud.className = 'grip-hud';
      hud.setAttribute('role','group');
      hud.setAttribute('aria-label','Grip control');

      const badge = document.createElement('span');
      badge.className = 'badge free';
      badge.textContent = 'free';
      badge.setAttribute('aria-live','polite');

      const btn = document.createElement('button');
      btn.className = 'toggle';
      btn.setAttribute('aria-pressed','false');
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        if (hud.classList.contains('disabled')) return;
        onGripperChange(gripDir > 0 ? -1 : +1);
      });

      // No meter element anymore
      hud.append(badge, btn);

      view.container.appendChild(hud);
      // No meterFill in the stored object
      gripHUDs.push({ view, el: hud, badge, btn });

      // ‚ñ∂ NEW: expose on the view for the compositor
      view.hudGrip = { el: hud, badge, btn };

      updateGripHUDState();
      updateGripHUDInteractivity();
    }

    /* Update texts/colors based on gripDir + force classification */
    function updateGripHUDState(){
      const status = classifyGrip(lastGripForceN);
      const absF   = Math.abs(lastGripForceN || 0);
      const isOpen = gripDir > 0;

      gripHUDs.forEach(({ el, badge, btn }) => {
        badge.classList.remove('free','contact','grasped');
        badge.classList.add(status);
        badge.textContent = status;

        btn.textContent = isOpen ? 'Grasp' : 'Release';
        btn.classList.toggle('open',  isOpen);
        btn.classList.toggle('close', !isOpen);
        btn.setAttribute('aria-pressed', String(isOpen));

        el.title = status === 'grasped' ? 'Gripper is grasping' : 'Gripper is not grasping';
        btn.title = `Click to ${isOpen ? 'close' : 'open'} gripper`;
      });

      applyGripVisual(status, lastGripForceN);

      if (forceUI) {
        forceUI.hide();
      }
    }


    /* Enable/disable HUD with same gating rules as before */
    function updateGripHUDInteractivity(){
      const disabled = taskCompletedSelected || !slidersAtDefault();
      const hoverMsg = disabled
        ? (taskCompletedSelected
            ? 'Disabled: ‚ÄúTask Already Completed‚Äù is selected.'
            : 'Disabled: pose changed. Reset to default to change gripper.')
        : `Click to ${gripDir > 0 ? 'close' : 'open'} gripper`;

      gripHUDs.forEach(({ el, btn }) => {
        el.classList.toggle('disabled', disabled);
        btn.title = hoverMsg;
      });
    }

    function createPoseResetHUDForView(view){
      const btn = document.createElement('button');
      btn.className = 'pose-reset';
      btn.type = 'button';
      btn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="fill: currentColor;">
        <path d="M22.719 12A10.719 10.719 0 0 1 1.28 12h.838a9.916 9.916 0 1 0 1.373-5H8v1H2V2h1v4.2A10.71 10.71 0 0 1 22.719 12z"/>
      </svg>`; // reset SVG icon
      btn.title = 'Reset to starting position';
      btn.setAttribute('aria-label', 'Reset to starting position');

      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        resetToStartingPoseLight();
      });

      view.container.appendChild(btn);
      poseResetHUDs.push({ view, el: btn });

      // ‚ñ∂ NEW: expose on the view for the compositor
      view.hudResetEl = btn;
    }

    function createHomeHUDForView(view){
      const btn = document.createElement('button');
      btn.className = 'home-hud';
      btn.type = 'button';
      btn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 50 50" style="fill: currentColor;">
        <path d="M 24.962891 1.0546875 A 1.0001 1.0001 0 0 0 24.384766 1.2636719 L 1.3847656 19.210938 A 1.0005659 1.0005659 0 0 0 2.6152344 20.789062 L 4 19.708984 L 4 46 A 1.0001 1.0001 0 0 0 5 47 L 18.832031 47 A 1.0001 1.0001 0 0 0 19.158203 47 L 30.832031 47 A 1.0001 1.0001 0 0 0 31.158203 47 L 45 47 A 1.0001 1.0001 0 0 0 46 46 L 46 19.708984 L 47.384766 20.789062 A 1.0005657 1.0005657 0 1 0 48.615234 19.210938 L 41 13.269531 L 41 6 L 35 6 L 35 8.5859375 L 25.615234 1.2636719 A 1.0001 1.0001 0 0 0 24.962891 1.0546875 z M 25 3.3222656 L 44 18.148438 L 44 45 L 32 45 L 32 26 L 18 26 L 18 45 L 6 45 L 6 18.148438 L 25 3.3222656 z M 37 8 L 39 8 L 39 11.708984 L 37 10.146484 L 37 8 z M 20 28 L 30 28 L 30 45 L 20 45 L 20 28 z"></path>
      </svg>`; // home SVG icon
      btn.title = "Move to arm's home position";
      btn.setAttribute('aria-label', "Move to arm's home position");
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        applyHomePosition();
      });

      view.container.appendChild(btn);
      homeHUDs.push({ view, el: btn });

      // ‚ñ∂ NEW: expose on the view for the compositor
      view.hudHomeEl = btn;
    }

    const WHEEL_OUTER_RADIUS_M = 0.105; // keep in sync with makeWheel(... outerR=0.105 ...)

    // OLD: const HUD_MARGIN_PX = 20;
    // NEW (independent margins):
    const GRIP_HUD_MARGIN_PX  = 20;  // distance from wheel edge to GRIP HUD
    const RESET_HUD_MARGIN_PX = 0.1;   // distance from wheel edge to RESET HUD (closer)

    // Base geometry sizes you already use
    const WHEEL_BASE_OUTER_RADIUS_M = 0.105;  // same value you pass to makeWheel(.. outerR)
    const CROSS_BASE_LEN_M = 0.10;            // your CROSS_LEN

    // Target pixel sizes (tune to taste)
    // const TARGET_WHEEL_RADIUS_PX = 64;        // ‚Üê no longer used
    const TARGET_CROSS_LEN_PX    = 24;        // long arm of the red cross ~24 px

    const _hudTmpA = new THREE.Vector3();
    const _hudTmpB = new THREE.Vector3();
    const _hudTmpC = new THREE.Vector3(); // NEW: for screen-right computations
    const _hudTmpD = new THREE.Vector3(); // NEW: for projected positions

    function projectWorldToViewPx(view, worldVec3) {
      const cam  = view.camera;
      const rect = view.renderer.domElement.getBoundingClientRect();
      const ndc  = worldVec3.clone().project(cam);
      const visible = (ndc.z >= -1 && ndc.z <= 1);
      return {
        x: (ndc.x * 0.5 + 0.5) * rect.width,
        y: (-ndc.y * 0.5 + 0.5) * rect.height,
        visible
      };
    }

    // Camera-space depth (|z|). Three's camera looks down -Z, so use abs().
    function cameraDepth(view, worldPoint){
      const p = worldPoint.clone().applyMatrix4(view.camera.matrixWorldInverse);
      return Math.abs(p.z);
    }

    function pixelsPerMeterAt(view, worldPoint){
      const cam  = view.camera;
      const rect = view.renderer.domElement.getBoundingClientRect();
      const M = 0.10; // 10 cm sampling baseline

      const up    = new THREE.Vector3(0,1,0).applyQuaternion(cam.quaternion).normalize();
      const right = new THREE.Vector3(1,0,0).applyQuaternion(cam.quaternion).normalize();

      const p0 = worldPoint.clone();
      const p0N = p0.clone().project(cam);
      if (p0N.z < -1 || p0N.z > 1) return null;

      const x0 = (p0N.x * .5 + .5) * rect.width;
      const y0 = (-p0N.y * .5 + .5) * rect.height;

      const px = p0.clone().addScaledVector(right, M).project(cam);
      const py = p0.clone().addScaledVector(up,    M).project(cam);

      const x1 = (px.x * .5 + .5) * rect.width;
      const y1 = (-py.y * .5 + .5) * rect.height;

      const ppmX = Math.abs(x1 - x0) / M;
      const ppmY = Math.abs(y1 - y0) / M;
      return { mean: (ppmX + ppmY) * 0.5 };
    }



    function positionGripHUDs(){
      gripHUDs.forEach(({ view, el }) => {
        const cam  = view.camera;
        const rect = view.renderer.domElement.getBoundingClientRect();

        if (hudHiddenForAnimation) {
          el.style.setProperty('display', 'none', 'important');
          return;
        } else {
          el.style.removeProperty('display');
        }

        // project marker center to screen
        _hudTmpA.copy(marker.position).project(cam);
        if (_hudTmpA.z < -1 || _hudTmpA.z > 1) { el.style.display = 'none'; return; }
        el.style.display = 'block';

        const baseX = (_hudTmpA.x * 0.5 + 0.5) * rect.width;
        const baseY = (-_hudTmpA.y * 0.5 + 0.5) * rect.height;

        // --- compute px-per-meter along screen up/right (local to *this* view) ---
        const upWorld    = _hudTmpB.set(0,1,0).applyQuaternion(cam.quaternion).normalize();
        const rightWorld = _hudTmpC.set(1,0,0).applyQuaternion(cam.quaternion).normalize();
        const p0 = marker.position;
        const M  = 0.10; // sample baseline (meters)

        // Y scale: move a little along world "screen-up", project, measure Œîpx
        const p1y  = _hudTmpD.copy(p0).addScaledVector(upWorld, M);
        const sp1y = _hudTmpD.clone().project(cam);
        const py1  = (-sp1y.y * 0.5 + 0.5) * rect.height;
        const pxPerMeterY = Math.abs(py1 - baseY) / M || 0;

        // X scale: move a little along world "screen-right", project, measure Œîpx
        const p1x  = _hudTmpD.copy(p0).addScaledVector(rightWorld, M);
        const sp1x = _hudTmpD.clone().project(cam);
        const px1  = (sp1x.x * 0.5 + 0.5) * rect.width;
        const pxPerMeterX = Math.abs(px1 - baseX) / M || 0;

        // Fallback to mean px/m if either direction is degenerate (very rare)
        const ppmMean = pixelsPerMeterAt(view, marker.position)?.mean || 0;
        const effPxPerMeterX = pxPerMeterX || ppmMean || 0;
        const effPxPerMeterY = pxPerMeterY || ppmMean || 0;

        // --- NEW: wheel radius in pixels from actual projection (edge-aware offset) ---
        // Keep this in sync with makeWheel(... outerR = 0.105 ...)
        const wheelPxRadiusX = Math.max(0, effPxPerMeterX * WHEEL_OUTER_RADIUS_M);
        const wheelPxRadiusY = Math.max(0, effPxPerMeterY * WHEEL_OUTER_RADIUS_M);

        // Distance from the *edge* of the ring, not its center
        const offsetPxX = Math.round(wheelPxRadiusX + GRIP_HUD_MARGIN_PX); // right
        const offsetPxY = Math.round(wheelPxRadiusY + GRIP_HUD_MARGIN_PX); // up

        // position with a small screen-edge clamp
        const edge = 8;
        const x = Math.round(baseX + offsetPxX);   // move right from center by ringEdge + margin
        const y = Math.round(baseY - offsetPxY);   // move up    from center by ringEdge + margin

        el.style.left = `${Math.max(edge, Math.min(rect.width  - edge, x))}px`;
        el.style.top  = `${Math.max(edge, Math.min(rect.height - edge, y))}px`;
      });
    }

    // World-space local axes from the marker‚Äôs orientation
    function localAxesWorld() {
      const q = marker.quaternion;
      return {
        xW: new THREE.Vector3(1,0,0).applyQuaternion(q).normalize(),
        yW: new THREE.Vector3(0,1,0).applyQuaternion(q).normalize(),
        zW: new THREE.Vector3(0,0,1).applyQuaternion(q).normalize(),
      };
    }

    // For a given axis name, return plane normal n and in-plane orthonormal basis u,v
    function planeBasisForAxis(axis) {
      const { xW, yW, zW } = localAxesWorld();
      if (axis === 'roll')   return { n: xW, u: yW, v: zW }; // rotate about local X ‚Üí YZ plane
      if (axis === 'pitch')  return { n: yW, u: zW, v: xW }; // rotate about local Y ‚Üí XZ plane
      /* yaw */              return { n: zW, u: xW, v: yW }; // rotate about local Z ‚Üí XY plane
    }
    function alignRingToNormal(group, n) {
      const from = new THREE.Vector3(0,0,1); // RingGeometry faces +Z by default
      const q = new THREE.Quaternion().setFromUnitVectors(from, n);
      group.quaternion.copy(q);
      group.updateMatrixWorld(true);
    }

    function angleOnPlaneFromPoint(p, center, u, v) {
      const r = p.clone().sub(center);
      return Math.atan2(r.dot(v), r.dot(u));
    }
    function normalizeAngle(a) {
      while (a >  Math.PI) a -= Math.PI * 2;
      while (a < -Math.PI) a += Math.PI * 2;
      return a;
    }

    // --- helper to show/hide pose gizmos (red dot + rotation wheels) ---
    function setPoseGizmosVisible(visible) {
      if (marker) marker.visible = visible;
      Object.values(rotationWheels).forEach(w => {
        if (w && w.group) w.group.visible = visible;
      });
    }


    /* 2) build lil-GUI sliders ----------------------------------- */
    // ---- absolute hard limits (same for all users) ----
    const ABS_LIMITS = {
      x:     { min: 0.10,  max: 0.53  },
      y:     { min: -0.30, max: 0.30  },
      z:     { min: 0.005, max: 0.40  },
      roll:  { min: -1.00, max: 1.00  },
      pitch: { min: -0.60, max: 0.75  },
      yaw:   { min: -0.81, max: 0.81  },
    };

    const startEuler = new THREE.Euler().setFromQuaternion(startQuat, 'XYZ');
    // --- interactive target pose (driven by sliders/marker) ---
    const targetPose = {
      pos: startPos.clone(),
      quat: startQuat.clone()
    };
    const params = {
      x: startPos.x, y: startPos.y, z: startPos.z,
      // roll:  startEuler.x,
      // pitch: startEuler.y,
      // yaw:   startEuler.z
      roll:  0.0,
      pitch: 0.0,
      yaw:   0.0
    };

    // Keep last angles so we can apply *incremental* local rotations
    const prevAngles = {
      roll:  params.roll,
      pitch: params.pitch,
      yaw:   params.yaw
    };

    // Record the starting values once; used to detect "pose unchanged"
    const initialParams = {
      x: params.x, y: params.y, z: params.z,
      roll: params.roll, pitch: params.pitch, yaw: params.yaw
    };

    const lastGoodParams = { ...params };
    function recordLastGood(keys = poseAxes) {
      keys.forEach(k => { lastGoodParams[k] = params[k]; });
    }

    // Only check the controls that are present
    const poseAxes = ['x','y','z','roll','pitch','yaw'].filter(k => activeControls.includes(k));
    const EPS = 1e-6; // tolerance for float comparisons
    function approximatelyEqual(a,b,eps=EPS){ return Math.abs(a - b) <= eps; }
    function getChangedAxes(){ return poseAxes.filter(k => !approximatelyEqual(params[k], initialParams[k])); }
    function slidersAtDefault(){ return getChangedAxes().length === 0; }

    function updateGoal() {
      cancelAnimationIfRunning('pose changed');

      // 1) Absolute position from sliders/drag
      targetPose.pos.set(params.x, params.y, params.z);

      // 2) Orientation: compose *incremental* rotation in the gripper's local frame
      const dRoll  = params.roll  - prevAngles.roll;
      const dPitch = params.pitch - prevAngles.pitch;
      const dYaw   = params.yaw   - prevAngles.yaw;

      if (Math.abs(dRoll) > EPS || Math.abs(dPitch) > EPS || Math.abs(dYaw) > EPS) {
        const dQ = new THREE.Quaternion().setFromEuler(
          new THREE.Euler(dRoll, dPitch, dYaw, 'XYZ')
        );
        // local-frame: post-multiply onto the current target orientation
        targetPose.quat.multiply(dQ).normalize();

        prevAngles.roll  = params.roll;
        prevAngles.pitch = params.pitch;
        prevAngles.yaw   = params.yaw;
      }

      // 3) Marker always shows the desired target immediately
      marker.position.copy(targetPose.pos);
      marker.quaternion.copy(targetPose.quat);

      // 4) Push to IK only when NOT animating
      if (!animState.enabled) {
        goal.setPosition(targetPose.pos.x, targetPose.pos.y, targetPose.pos.z);
        goal.setQuaternion(
          targetPose.quat.x, targetPose.quat.y, targetPose.quat.z, targetPose.quat.w
        );
      }

      // Existing reveal/locking UI
      if (!slidersLocked) recordLastGood();
      updateGripperInteractivity();
    }



    // ---------- Drag helpers ----------
    const raycaster = new THREE.Raycaster();
    const ndc = new THREE.Vector2();

    function clampToSlider(axis, v){
      // Clamp to the effective slider range (span‚à©ABS_LIMITS) and also
      // to the absolute limits for extra safety.
      const r = sliderRanges[axis] || {};
      const abs = ABS_LIMITS[axis];
      let min = r.min ?? -Infinity;
      let max = r.max ?? +Infinity;
      if (abs) {
        min = Math.max(min, abs.min);
        max = Math.min(max, abs.max);
      }
      return Math.min(max, Math.max(min, v));
    }

    function updateSlidersDisplay(axes){
      axes.forEach(a => {
        sliderCtrls[a]?.updateDisplay();
        updateSliderDecor(a);
      });
     }

    // --- UI decoration: center tick + invalid shading + center detent glow ---
    function clamp01(x){ return Math.max(0, Math.min(1, x)); }
    function updateSliderDecor(axis){
      const ctrl = sliderCtrls[axis]; if (!ctrl) return;
      const input = ctrl.domElement.querySelector('input[type="range"]'); if (!input) return;
      const abs = ABS_LIMITS[axis]; if (!abs) return;
      const {min, max} = sliderRanges[axis];        // full centered track (center ¬± span)
      const center = sliderCenters[axis];
      const span = (max - min);
      if (span <= 0) return;

      // Positions along the track (0..100%)
      const pct = v => 100 * clamp01((v - min) / span);
      const absMinPct = pct(abs.min);
      const absMaxPct = pct(abs.max);
      const centerPct = 50; // by construction (center ¬± span)

      // Layered gradients: left OOB, right OOB, center tick, base
      const leftOOB  = absMinPct > 0
        ? `linear-gradient(to right, rgba(239,68,68,.26) 0%, rgba(239,68,68,.26) ${absMinPct}%, transparent ${absMinPct}%, transparent 100%)`
        : '';
      const rightOOB = absMaxPct < 100
        ? `linear-gradient(to right, transparent 0%, transparent ${absMaxPct}%, rgba(239,68,68,.26) ${absMaxPct}%, rgba(239,68,68,.26) 100%)`
        : '';
      const centerTick = `linear-gradient(to right,
        transparent calc(${centerPct}% - 1px),
        #3b82f6    calc(${centerPct}% - 1px),
        #3b82f6    calc(${centerPct}% + 1px),
        transparent calc(${centerPct}% + 1px)
      )`;
      const base = 'linear-gradient(to right, #d1d5db, #d1d5db)';
      input.style.background = [leftOOB, rightOOB, centerTick, base].filter(Boolean).join(',');

      // Snap-to-center detent (~2% of span) + visual glow
      const detent = 0.02 * span;
      const atCenter = Math.abs(params[axis] - center) <= detent;
      input.classList.toggle('at-center', atCenter);
    }

    // Single shared drag state
    const dragState = {
      active: false,
      mode: null,                // 'translate' | 'rotate'
      viewName: null,
      plane: new THREE.Plane(),
      axes: /** @type {('x'|'y'|'z')[]} */([]),          // for translation
      axis: /** @type {'roll'|'pitch'|'yaw'|null} */(null), // for rotation
      pointerId: null,

      // rotation-specific
      u: new THREE.Vector3(),
      v: new THREE.Vector3(),
      angle0: 0,
      param0: 0,
    };

    // Utility: which 2D plane to drag for translation in a given view
    const DRAG_SPECS = {
      front:       { axes: ['y','z'], normal: new THREE.Vector3(1,0,0) }, // lock X ‚Üí drag YZ
      left:        { axes: ['x','z'], normal: new THREE.Vector3(0,1,0) }, // lock Y ‚Üí drag XZ
      right:       { axes: ['x','z'], normal: new THREE.Vector3(0,1,0) },
      perspective: { axes: ['x','y'], normal: new THREE.Vector3(0,0,1) }, // lock Z ‚Üí drag XY
    };
    function specForView(name){ return DRAG_SPECS[name] || DRAG_SPECS.perspective; }

    // Helper used in both translate & rotate picking
    function setNDCFromPointerEvent(evt, renderer){
      const rect = renderer.domElement.getBoundingClientRect();
      ndc.x =  ( (evt.clientX - rect.left) / rect.width ) * 2 - 1;
      ndc.y = -( (evt.clientY - rect.top)  / rect.height) * 2 + 1;
    }

    // Clamp helpers (reuse your own ABS_LIMITS/sliderRanges if you have them)
    function clampAngleToLimits(axis, val) {
      return clampToSlider(axis, val);
    }
    function clampLinearToLimits(axis, val) {
      return clampToSlider(axis, val);
    }

    // Attach to each view/canvas
    function attachPoseGizmoHandlers(renderer, camera, viewName) {
      const el = renderer.domElement;

      function pickAll(evt) {
        setNDCFromPointerEvent(evt, renderer);
        raycaster.setFromCamera(ndc, camera);
        const targets = [
          ...rotationPickables,                            // wheel segments
          marker.getObjectByName('marker_pick_proxy'),     // drag proxy
          marker                                          // (fallback)
        ].filter(Boolean);
        return raycaster.intersectObjects(targets, true);
      }

      // Hover: cursor + wheel highlight
      el.addEventListener('pointermove', (evt) => {
        if (slidersLocked) {                // ‚Üê block hover affordances while locked
          el.style.cursor = 'not-allowed';
          return;
        }
        if (dragState.active) return;
        const hits = pickAll(evt);
        const wheelHit = hits.find(h => h.object?.userData?.axis);
        const dotHit   = hits.find(h => (h.object === marker) || (h.object?.name === 'marker_pick_proxy'));

        resetAllWheelStates();
        if (wheelHit) {
          setWheelState(wheelHit.object.userData.axis, 'hover');
          el.style.cursor = 'grab';
        } else if (dotHit) {
          el.style.cursor = 'grab';
        } else {
          el.style.cursor = 'default';
        }
      });

      // Press: start rotation or translation drag
      el.addEventListener('pointerdown', (evt) => {
        if (slidersLocked) return;
        // START recording - this drag will alter the pose
        maybeRecord('pose-drag');
        
        const hits = pickAll(evt);
        if (!hits.length) return;

        cancelAnimationIfRunning('drag start');

        const top = hits[0];
        const hitAxis = top.object?.userData?.axis || null;

        dragState.active    = true;
        dragState.viewName  = viewName;
        dragState.pointerId = evt.pointerId;
        el.setPointerCapture(dragState.pointerId);
        el.style.cursor = 'grabbing';

        // Update current view and gripper visibility
        currentViewName = viewName;
        updateGripArrowVisibility();

        if (hitAxis) {
          // ROTATION
          dragState.mode = 'rotate';
          dragState.axis = /** @type {'roll'|'pitch'|'yaw'} */(hitAxis);

          const { n, u, v } = planeBasisForAxis(dragState.axis, marker.quaternion);
          dragState.u.copy(u); dragState.v.copy(v);
          dragState.plane.setFromNormalAndCoplanarPoint(n, marker.position);

          const hitPt = new THREE.Vector3();
          raycaster.ray.intersectPlane(dragState.plane, hitPt);
          dragState.angle0 = angleOnPlaneFromPoint(hitPt, marker.position, dragState.u, dragState.v);
          dragState.param0 = params[dragState.axis];

          resetAllWheelStates();
          setWheelState(dragState.axis, 'active');
        } else {
          // TRANSLATION
          dragState.mode = 'translate';
          const spec = specForView(viewName);
          dragState.axes = spec.axes;
          dragState.plane.setFromNormalAndCoplanarPoint(spec.normal, marker.position);
        }

        evt.preventDefault();
      });

      // Dragging
      el.addEventListener('pointermove', (evt) => {
        if (!dragState.active || dragState.viewName !== viewName) return;

        setNDCFromPointerEvent(evt, renderer);
        raycaster.setFromCamera(ndc, camera);

        const hitPoint = new THREE.Vector3();
        if (!raycaster.ray.intersectPlane(dragState.plane, hitPoint)) return;

        if (dragState.mode === 'translate') {
          dragState.axes.forEach(axis => {
            const v = (axis === 'x') ? hitPoint.x : (axis === 'y') ? hitPoint.y : hitPoint.z;
            params[axis] = clampLinearToLimits(axis, v);
          });
          updateGoal(); // your function that copies params ‚Üí marker/goal
          // Update sliders display and UI state
          revealMinimalRobotFromPose();
          updateGripHUDInteractivity();
          dragState.axes.forEach(axis => {
            if (sliderCtrls[axis]) sliderCtrls[axis].updateDisplay();
          });
          updateSlidersDisplay(dragState.axes);
        } else if (dragState.mode === 'rotate' && dragState.axis) {
          const ang1 = angleOnPlaneFromPoint(hitPoint, marker.position, dragState.u, dragState.v);
          const dAng = normalizeAngle(ang1 - dragState.angle0);
          let newVal = dragState.param0 + dAng;
          newVal = clampAngleToLimits(dragState.axis, newVal);

          params[dragState.axis] = newVal;
          updateGoal();
          // Update slider display and UI state
          revealMinimalRobotFromPose();
          updateGripHUDInteractivity();
          if (sliderCtrls[dragState.axis]) sliderCtrls[dragState.axis].updateDisplay();
        }

        updateTaskCompletedAvailability();

        evt.preventDefault();
      });

      function endDrag(){
        if (!dragState.active) return;
        try { el.releasePointerCapture(dragState.pointerId); } catch(_) {}
        dragState.active   = false;
        const endedAxis    = dragState.axis;
        dragState.mode     = null;
        dragState.axis     = null;
        dragState.viewName = null;
        dragState.axes     = [];
        el.style.cursor    = 'default';

        resetAllWheelStates();
        if (endedAxis) setWheelState(endedAxis, 'hover');
      }

      // Track mouse position globally to re-evaluate hover after drag end
      el.addEventListener('pointermove', (e)=> { window._lastMouseX = e.clientX; window._lastMouseY = e.clientY; });

      el.addEventListener('pointerup',     endDrag);
      el.addEventListener('pointercancel', endDrag);
      el.addEventListener('pointerleave',  () => { if (dragState.active) endDrag(); });
    }

    /* ---------- camera-view buttons --------------------------- */

    /* ---------- camera-view buttons --------------------------- */
    function poseToMatrix(mat){
      return new THREE.Matrix4().set(
        mat[0][0], mat[0][1], mat[0][2], mat[0][3],
        mat[1][0], mat[1][1], mat[1][2], mat[1][3],
        mat[2][0], mat[2][1], mat[2][2], mat[2][3],
        mat[3][0], mat[3][1], mat[3][2], mat[3][3],
      );
    }

    function selectView(viewName) {
      // Remove selection from all views
      views.forEach(view => {
        view.container.classList.remove('selected');
      });
      
      // Select the new view
      const view = views.get(viewName);
      if (view) {
        currentViewName = viewName;
        
        // Update gripper arrow visibility based on selected view
        updateGripArrowVisibility();
      }
    }

    function initializeViews() {
      // Clear existing views
      views.clear();
      viewsGrid.innerHTML = '';
      
      // Get available camera poses and textures in the desired order
      const availableViews = [];
      
      // Define the desired view order: front (top-left), left (top-right), top (bottom-left), right (bottom-right)
      const viewOrder = ['front', 'left', 'top', 'right'];
      
      viewOrder.forEach(viewName => {
        const poseKey = viewName + '_pose';
        if (camPoses[poseKey] && viewTextures[viewName] && cameraModels[viewName]) {
          availableViews.push({
            name: viewName,
            poseKey,
            texture: viewTextures[viewName],
            imageSrc: state.views?.[viewName],
            model: cameraModels[viewName],
            pose: camPoses[poseKey]
          });
        }
      });
      
      console.log(`[DEBUG] availableViews:`, availableViews.map(v => v.name));
      
      if (availableViews.length === 0) return;
      
      // Setup grid layout
      setupViewportGrid(availableViews.length);
      
      // Create views
      availableViews.forEach((viewInfo, index) => {
        const view = createViewRenderer(
          viewInfo.name,
          viewInfo.model,
          viewInfo.texture,
          viewInfo.imageSrc
        );
        
        // Regular camera setup
        attachPoseGizmoHandlers(view.renderer, view.camera, view.name);
        // Create HUDs for this view
        createGripHUDForView(view);
        createPoseResetHUDForView(view);
        createHomeHUDForView(view);
        
        // Set up camera pose and projection
        updateViewCamera(view, viewInfo.pose);
        applyProjectionFromK(view);
        
        // For 3 views, hide the 4th grid position
        if (availableViews.length === 3 && index === 2) {
          view.container.style.gridColumn = '1 / -1';
          view.container.style.justifySelf = 'center';
        }
      });
      
      // Update sizes and select first view
      updateViewSizes();
      if (availableViews.length > 0) {
        currentViewName = availableViews[0].name;
        console.log(`[DEBUG] Initial currentViewName set to: "${currentViewName}"`);
        updateGripArrowVisibility(); // Update arrow visibility for initial view
      }
      
      // Initial placement of the example dock (if present) - delay to ensure DOM is ready
      setTimeout(() => updateExampleDockLayout(), 100);
    }

    const btnBar   = document.createElement('div');
    btnBar.style.position = 'fixed';
    btnBar.style.top = '8px';
    btnBar.style.left = '8px';
    btnBar.style.zIndex = 10;
    btnBar.style.display = 'flex';
    btnBar.style.gap = '4px';
    document.body.appendChild( btnBar );

    let taskCompletedSelected = false;
    let taskCompletedBtn = null;
    let verifyButtonUsed = false; // Track if Verify button has been clicked in this session

    /* ---------- confirm button (lower-right corner) ------------------- */

    // Initialize the multi-view system
    initializeViews();

    // Keep canvas sizes and per-view projection matrices in sync
    window.addEventListener('resize', () => {
      updateViewSizes();
      // Recompute projection for each view after its canvas size changes
      views.forEach(v => applyProjectionFromK(v));
    });

  /* ---------- confirm button (inside controls container) ------------------- */

    // Create confirm button to be added to controls container
    const confirmBtn = document.createElement('button');
    confirmBtn.textContent = 'Verify';
    confirmBtn.className = 'confirm-button';

    confirmBtn.onclick = async () => {
      // Check if button has already been used
      if (verifyButtonUsed) {
        console.log('‚ö†Ô∏è Verify button already used in this session');
        return;
      }

      // Mark button as used and disable it
      verifyButtonUsed = true;
      confirmBtn.disabled = true;
      confirmBtn.textContent = 'Submitted';

      // 0) Freeze any ongoing animation (unchanged)
      if (animState.enabled) {
        animState.enabled = false;
        animating = false;
        updateGripArrowVisibility();
        if (animateBtn) animateBtn.classList.remove('active');
        setPoseGizmosVisible(true);
        setGhostMode(false);
        applyPostAnimationVisibility();
      }

      // NEW: If "Task Already Completed" is selected, POST that and exit early.
      if (taskCompletedSelected) {
        try {
          const payload = {
            state_id: state.state_id,
            episode_id: state.episode_id,
            task_already_completed: true
          };
          if (RECORDING_MARKED_SAVED && LAST_RECORDING_ID) {
            payload.recording_id  = LAST_RECORDING_ID;
            payload.recording_ext = LAST_RECORDING_EXT;
          }
          
          const response = await apiFetch(`/api/task-already-completed`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });

          if (response.ok) {
            console.log('‚úÖ Task already completed response sent');
            // Immediate refresh to load next task
            window.location.replace(window.location.href.split('?')[0] + '?_=' + Date.now());
          } else {
            const errorData = await response.json().catch(() => ({}));
            console.error('‚ùå Failed to send task already completed response:', errorData);
            alert('Failed to submit response. Please try again.');
          }
        } catch (err) {
          console.error('‚ùå Failed to send task already completed response', err);
          alert('Failed to submit response. Please try again.');
        }
        return; // IMPORTANT: do NOT run the normal submit-goal flow.
      }

      // ===== Normal submit-goal flow (unchanged below) =====

      // 1) Use the intended goal pose
      const { pos: tgtPos, quat: tgtQuat } = getTargetPose();

      // 2) Snap the IK goal to that target and explicitly solve to it now
      goal.setPosition(tgtPos.x, tgtPos.y, tgtPos.z);
      goal.setQuaternion(tgtQuat.x, tgtQuat.y, tgtQuat.z, tgtQuat.w);

      setIKFromUrdf(ikRoot, robot);
      for (let i = 0; i < 25; i++) solver.solve();
      setUrdfFromIK(robot, ikRoot);

      // 3) Read joints
      const jointMap = {};
      Object.entries(robot.joints).forEach(([name, joint]) => {
        jointMap[name] = joint.jointValue;
      });

      // 4) Build ee_pose
      const eeEuler = new THREE.Euler().setFromQuaternion(tgtQuat, "XYZ");

      const poseResetToDefault = slidersAtDefault();
      const slidersChangedAxes = getChangedAxes();

      try {
        const payload = {
          joint_positions: jointMap,
          gripper: gripDir,
          ee_pose: { position: [tgtPos.x, tgtPos.y, tgtPos.z], rpy: [eeEuler.x, eeEuler.y, eeEuler.z] },
          state_id: state.state_id,
          episode_id: state.episode_id,
          pose_reset_to_default: poseResetToDefault,
          sliders_changed_axes: slidersChangedAxes
        };
        if (RECORDING_MARKED_SAVED && LAST_RECORDING_ID) {
          payload.recording_id  = LAST_RECORDING_ID;
          payload.recording_ext = LAST_RECORDING_EXT;
        }

        const response = await apiFetch(`/api/submit-goal`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });

        if (response.ok) {
          console.log('‚úÖ goal sent (final goal joints)');
          // Immediate refresh to load next task
          window.location.replace(window.location.href.split('?')[0] + '?_=' + Date.now());
        } else {
          console.error('‚ùå failed to send goal - server error:', response.status);
        }
      } catch (err) {
        console.error('‚ùå failed to send goal', err);
      }
    };



    // Animate toggle button (now sits to the LEFT of Confirm, same style but red)
    const animateBtn = document.createElement('button');
    animateBtn.className = 'animate-button';
    animateBtn.textContent = 'Animate';
    animateBtn.onclick = toggleAnimation;

    // Animation status indicator
    const animStatusIndicator = document.createElement('div');
    animStatusIndicator.className = 'animation-status';
    animStatusIndicator.style.cssText = `
      font-size: 11px;
      color: #666;
      margin-top: 4px;
      text-align: center;
      display: none;
    `;
    animStatusIndicator.textContent = 'Checking animation status...';

    // Add status checking
    let animationStatusTimer = null;
    
    async function checkAnimationStatus() {
      try {
        const response = await apiFetch('/api/animation/status');
        const status = await response.json();
        
        if (status.available && status.animation_initialized) {
          const slotsAvailable = status.available_slots;
          const maxSlots = status.max_users;
          
          if (slotsAvailable > 0) {
            animStatusIndicator.textContent = `‚úì Animation ready (${slotsAvailable}/${maxSlots} slots)`;
            animStatusIndicator.style.color = '#22c55e'; // green
            animateBtn.disabled = false;
          } else {
            animStatusIndicator.textContent = `‚è≥ Animation busy (0/${maxSlots} slots)`;
            animStatusIndicator.style.color = '#f59e0b'; // orange
            animateBtn.disabled = !backendAnimState.active; // Only disable if not our animation
          }
          
          animStatusIndicator.style.display = 'block';
        } else {
          animStatusIndicator.textContent = '‚ö†Ô∏è Animation unavailable';
          animStatusIndicator.style.color = '#ef4444'; // red
          animStatusIndicator.style.display = 'block';
          if (!backendAnimState.active) {
            animateBtn.disabled = true;
          }
        }
        
      } catch (error) {
        console.error('‚ùå Status check failed:', error);
        animStatusIndicator.textContent = '‚ö†Ô∏è Animation status unknown';
        animStatusIndicator.style.color = '#ef4444';
        animStatusIndicator.style.display = 'block';
      }
    }
    
    // Check status every 5 seconds
    function startStatusChecking() {
      checkAnimationStatus(); // Initial check
      animationStatusTimer = setInterval(checkAnimationStatus, 5000);
    }
    
    function stopStatusChecking() {
      if (animationStatusTimer) {
        clearInterval(animationStatusTimer);
        animationStatusTimer = null;
      }
    }
    
    // Start status checking after initial state loads
    setTimeout(startStatusChecking, 2000);

    // --- cancel helper + global listeners ---------------------------------
    cancelAnimationIfRunning = (reason = '') => {
      if (!animState.enabled && !backendAnimState.active) return;

      // OPTIMIZATION: Immediately stop backend animation and update UI
      if (backendAnimState.active) {
        // Immediate UI updates for instant feedback
        robotVisible = true;
        robot.visible = true;
        if (toggleRobotBtn) toggleRobotBtn.textContent = 'hide robot model';
        
        // Stop Isaac Sim frame streaming immediately
        backendAnimState.streaming = false;
        
        console.log('‚úÖ Animation cancelled immediately - showing Three.js robot');
        
        // Backend cleanup in background (don't await)
        stopBackendAnimation().catch(error => {
          console.error('‚ùå Backend animation cleanup failed:', error);
        });
        
        // Refresh views in background (don't await)
        refreshViews().catch(error => {
          console.error('‚ùå Static views refresh failed:', error);
        });
      }

      // Turn OFF animation (same as clicking "Animate" again to stop)
      animState.enabled = false;
      animateBtn.classList.remove('active');

      animating = false;
      updateGripArrowVisibility();

      // Snap the goal to the current target to avoid jumps
      const { pos, quat } = getTargetPose();
      goal.setPosition(pos.x, pos.y, pos.z);
      goal.setQuaternion(quat.x, quat.y, quat.z, quat.w);

      // Restore normal visuals
      setPoseGizmosVisible(true);
      applyPostAnimationVisibility();  // leaves ghosting ON
      setHUDHiddenForAnimation(false);

      if (reason) console.log('‚èπÔ∏è Animate cancelled:', reason);
    };

    // Stop animation if the user presses anywhere on the page
    // (ignore clicks on the Animate button itself so it can toggle ON/OFF normally)
    window.addEventListener('pointerdown', (e) => {
      const t = e.target;
      if (t === animateBtn || (animateBtn && animateBtn.contains && animateBtn.contains(t))) return;
      
      // Pause pulsing animation during interaction for performance
      if (exampleToggle && exampleToggle.classList.contains('never-activated')) {
        exampleToggle.classList.add('paused');
      }
      
      cancelAnimationIfRunning('pointerdown anywhere');
    }, { capture: true });
    
    // Resume pulsing animation when interaction ends
    window.addEventListener('pointerup', () => {
      if (exampleToggle && exampleToggle.classList.contains('never-activated')) {
        exampleToggle.classList.remove('paused');
      }
    }, { capture: true });

    // Reset button (lower-left): standalone like Confirm, same style but gray,
    // and identical behavior to the in-view HUD reset button.
    const resetBtn = document.createElement('button');
    resetBtn.className = 'reset-button';
    resetBtn.textContent = 'Reset';
    resetBtn.onclick = resetToStartingPoseLight;  // ‚Üê same behavior as the HUD reset

    function resetToStartingPoseLight() {
      // Stop any animation
      cancelAnimationIfRunning('pose reset');

      // Return pose to initial (does not touch gripper/TAC)
      params.x = initialParams.x; params.y = initialParams.y; params.z = initialParams.z;
      params.roll = initialParams.roll; params.pitch = initialParams.pitch; params.yaw = initialParams.yaw;

      prevAngles.roll = params.roll; prevAngles.pitch = params.pitch; prevAngles.yaw = params.yaw;

      targetPose.pos.copy(startPos);
      targetPose.quat.copy(startQuat);

      goal.setPosition(startPos.x, startPos.y, startPos.z);
      goal.setQuaternion(startQuat.x, startQuat.y, startQuat.z, startQuat.w);

      // Marker
      marker.position.copy(startPos);
      marker.quaternion.copy(startQuat);

      // Snap robot back to initial joints for visual consistency
      if (initialJointPositions) {
        for (const [name, val] of Object.entries(initialJointPositions)) {
          robot.setJointValue(name, val);
        }
        robot.updateMatrixWorld(true);
      }

      // Treat this like "no pose changes yet" but keep robot visible
      userHasAdjustedPose = false;
      revealMinimalRobotFromPose();

      // Refresh any UI/logic that depends on "at defaults"
      updateTaskCompletedAvailability();
      recomputeLocks();
      updateGripHUDInteractivity();
    }

    // --- NEW: applyHomePosition() ---
    // Sets joints to: [0, 60¬∞, 75¬∞, -60¬∞, 0¬∞, 0¬∞, 2¬∞] and aligns the IK goal/marker to match.
    function applyHomePosition() {
      // If animation is running, stop it so we can jump to a clean configuration
      cancelAnimationIfRunning('Home Pos');

      // Define your Home angles (in radians) using Math.PI
      const D2R = Math.PI / 180;
      const HOME_RAD = [0, 60, 75, -60, 0, 0, 2].map(d => d * D2R);

      // We'll map the angles onto the joint *order* provided by the server's
      // initialJointPositions object (same order used during reset).
      // This keeps the mapping robust without hardcoding joint names.
      const jointNames = Object.keys(initialJointPositions || {});
      const count = Math.min(jointNames.length, HOME_RAD.length);

      let applied = 0;
      for (let i = 0; i < count; i++) {
        const name = jointNames[i];
        const val  = HOME_RAD[i];
        robot.setJointValue(name, val);
        applied++;
      }

      robot.updateMatrixWorld(true);

      // Sample the EE pose for this joint configuration
      const p = new THREE.Vector3();
      const q = new THREE.Quaternion();
      eeVis.getWorldPosition(p);
      eeVis.getWorldQuaternion(q);

      // Update the live target/marker/goal so IK keeps the robot at this pose
      targetPose.pos.copy(p);
      targetPose.quat.copy(q);
      marker.position.copy(p);
      marker.quaternion.copy(q);
      goal.setPosition(p.x, p.y, p.z);
      goal.setQuaternion(q.x, q.y, q.z, q.w);

      // Keep the Cartesian params consistent (sliders are hidden, but state matters)
      params.x = p.x; params.y = p.y; params.z = p.z;
      params.roll = 0; params.pitch = 0; params.yaw = 0;
      prevAngles.roll = 0; prevAngles.pitch = 0; prevAngles.yaw = 0;

      // Make sure the robot is visible like after a pose change
      revealMinimalRobotFromPose();

      // Update UI/interlocks (Task Already Completed, gripper gating, etc.)
      updateTaskCompletedAvailability();
      recomputeLocks();
      updateGripHUDInteractivity();

      console.log(`Home Pos applied to ${applied} joint(s) using order:`, jointNames.slice(0, applied));
    }

    function positionPoseResetHUDs(){
      poseResetHUDs.forEach(({ view, el }) => {
        const cam  = view.camera;
        const rect = view.renderer.domElement.getBoundingClientRect();

        if (hudHiddenForAnimation) {
          el.style.setProperty('display', 'none', 'important');
          return;
        } else {
          el.style.removeProperty('display');
        }

        // Project marker center
        const c = marker.position.clone().project(cam);
        if (c.z < -1 || c.z > 1) { el.style.display = 'none'; return; }
        el.style.display = 'block';

        const baseX = (c.x * 0.5 + 0.5) * rect.width;
        const baseY = (-c.y * 0.5 + 0.5) * rect.height;

        // Estimate pixels-per-meter along screen up & right like the grip HUD
        const upWorld    = new THREE.Vector3(0,1,0).applyQuaternion(cam.quaternion).normalize();
        const rightWorld = new THREE.Vector3(1,0,0).applyQuaternion(cam.quaternion).normalize();
        const p0 = marker.position;
        const M  = 0.10; // sampling baseline in meters

        // Move a bit in world "screen-up" and "screen-right"
        const sp1y = p0.clone().addScaledVector(upWorld,    M).project(cam);
        const sp1x = p0.clone().addScaledVector(rightWorld, M).project(cam);

        const py1 = (-sp1y.y * 0.5 + 0.5) * rect.height;
        const px1 = ( sp1x.x * 0.5 + 0.5) * rect.width;

        const pxPerMeterY = Math.abs(py1 - baseY) / M || 0;
        const pxPerMeterX = Math.abs(px1 - baseX) / M || 0;

        // Wheel outer radius in pixels (keep in sync with makeWheel's outerR=0.105)
        const wheelPxRadiusX = Math.max(0, pxPerMeterX * WHEEL_OUTER_RADIUS_M);
        const wheelPxRadiusY = Math.max(0, pxPerMeterY * WHEEL_OUTER_RADIUS_M);

        // Lower-right from the *edge* of the ring by the fixed margin
        const offsetPxX = Math.round(wheelPxRadiusX + RESET_HUD_MARGIN_PX);
        const offsetPxY = Math.round(wheelPxRadiusY + RESET_HUD_MARGIN_PX);

        const edge = 8; // small screen-edge clamp
        const x = Math.round(baseX + offsetPxX);  // right
        const y = Math.round(baseY + offsetPxY);  // DOWN (note the +)

        el.style.left = `${Math.max(edge, Math.min(rect.width  - edge, x))}px`;
        el.style.top  = `${Math.max(edge, Math.min(rect.height - edge, y))}px`;
      });
    }

    function positionHomeHUDs(){
      homeHUDs.forEach(({ view, el }) => {
        const cam  = view.camera;
        const rect = view.renderer.domElement.getBoundingClientRect();

        if (hudHiddenForAnimation) {
          el.style.setProperty('display', 'none', 'important');
          return;
        } else {
          el.style.removeProperty('display');
        }

        // Project marker center
        const c = marker.position.clone().project(cam);
        if (c.z < -1 || c.z > 1) { el.style.display = 'none'; return; }
        el.style.display = 'block';

        const baseX = (c.x * 0.5 + 0.5) * rect.width;
        const baseY = (-c.y * 0.5 + 0.5) * rect.height;

        // Estimate pixels-per-meter along screen up & right (same as reset HUD)
        const upWorld    = new THREE.Vector3(0,1,0).applyQuaternion(cam.quaternion).normalize();
        const rightWorld = new THREE.Vector3(1,0,0).applyQuaternion(cam.quaternion).normalize();
        const p0 = marker.position;
        const M  = 0.10;

        const sp1y = p0.clone().addScaledVector(upWorld,    M).project(cam);
        const sp1x = p0.clone().addScaledVector(rightWorld, M).project(cam);

        const py1 = (-sp1y.y * 0.5 + 0.5) * rect.height;
        const px1 = ( sp1x.x * 0.5 + 0.5) * rect.width;

        const pxPerMeterY = Math.abs(py1 - baseY) / M || 0;
        const pxPerMeterX = Math.abs(px1 - baseX) / M || 0;

        // Use same ring radius & margin as reset HUD, mirrored horizontally
        const wheelPxRadiusX = Math.max(0, pxPerMeterX * WHEEL_OUTER_RADIUS_M);
        const wheelPxRadiusY = Math.max(0, pxPerMeterY * WHEEL_OUTER_RADIUS_M);

        const offsetPxX = Math.round(wheelPxRadiusX + RESET_HUD_MARGIN_PX); // left from edge
        const offsetPxY = Math.round(wheelPxRadiusY + RESET_HUD_MARGIN_PX); // down from edge

        const edge = 8;
        const x = Math.round(baseX - offsetPxX);  // ‚Üê LEFT
        const y = Math.round(baseY + offsetPxY);  // ‚Üê DOWN

        el.style.left = `${Math.max(edge, Math.min(rect.width  - edge, x))}px`;
        el.style.top  = `${Math.max(edge, Math.min(rect.height - edge, y))}px`;
      });
    }

    const spanDefs = [
      ['x',     0.20],   // meters
      ['y',     0.40],
      ['z',     0.20],
      ['roll',  1.0],   // radians
      ['pitch', 0.81],
      ['yaw',   0.81],
    ];

    // Keep references so dragging can clamp to slider ranges & update displays
    const sliderCtrls   = {};  // axis -> lil-gui controller
    const sliderCenters = {};  // axis -> center value
    const sliderRanges  = {};  // axis -> {min, max}

    setSlidersLocked(false);
    // Ensure marker/goal reflect params (and any implicit clamping from controller init)
    updateGoal();
    updateGripHUDInteractivity();

    // Add gripper buttons after sliders
    if (gripperButtonsContainer) {
      controlsContainer.appendChild(gripperButtonsContainer);
      updateGripperButtonStates(); // Set initial button states
    }

    // Evaluate initial interactivity (usually enabled because sliders = defaults)
    updateGripperInteractivity();

    // Add reset button to its own bar (lower-left, standalone like confirm)
    resetBar.appendChild(resetBtn);

    // Add confirm button at the bottom
    confirmBar.appendChild(confirmBtn);

    // Place Animate to the LEFT of Confirm
    confirmBar.insertBefore(animateBtn, confirmBtn);
    
    // Add animation status indicator below the animate button
    confirmBar.appendChild(animStatusIndicator);

    /* === NEW: keep buttons in sync with TAC / locks === */
    function reflectButtonInteractivity(){
      const tacOn = taskCompletedSelected === true;
      if (animateBtn) {
        animateBtn.disabled = tacOn;         // disable Animate when TAC is on
        if (tacOn) animateBtn.classList.remove('active');
      }
      // Reset stays enabled
    }

    // Patch recomputeLocks to also update the buttons
    (function patchRecomputeLocks(){
      const _recomputeLocks = recomputeLocks;
      recomputeLocks = function(){
        _recomputeLocks();
        reflectButtonInteractivity();
      };
      reflectButtonInteractivity(); // initialize once
    })();


    updateTaskCompletedAvailability();

    // Update layout based on number of active controls
    function updateControlsLayout() {
      // We‚Äôre not showing a right column anymore.
      controlsContainer.style.display = 'none';
      controlsWrapper.style.display = 'none';

      // Remove layout classing meant for slider columns.
      mount.classList.remove('single-slider', 'multiple-sliders');
    }


    updateControlsLayout();


    /* --- solver --- */
    const solver = new Solver(ikRoot);                // constructor takes root
    // (solver settings default to 5 iterations, etc.)

    /* --- animation loop --- */
    function animate(now) {
      requestAnimationFrame(animate);



      // If Animate is ON: forward (start‚Üítarget) ‚Üí hold at target ‚Üí restart.
      if (animState.enabled) {
        if (!animState.lastTs) animState.lastTs = now;
        const dt = Math.min(100, now - animState.lastTs); // clamp spikes
        animState.lastTs = now;

        // Always sample the *current* target from sliders/drags
        const { pos: tgtPos, quat: tgtQuat } = getTargetPose();

        if (animState.phase === 'forward') {
          animState.t += (dt / animState.duration);
          if (animState.t >= 1) {
            animState.t = 1;
            animState.phase = 'hold';
            animState.holdElapsed = 0;
          }
          _interpPos.copy(startPos).lerp(tgtPos, animState.t);
          _interpQuat.copy(startQuat).slerp(tgtQuat, animState.t);
          goal.setPosition  (_interpPos.x,  _interpPos.y,  _interpPos.z);
          goal.setQuaternion(_interpQuat.x, _interpQuat.y, _interpQuat.z, _interpQuat.w);
        } else { // 'hold'
          animState.holdElapsed += dt;
          // Stay exactly at the (live) goal during the hold window
          goal.setPosition  (tgtPos.x,  tgtPos.y,  tgtPos.z);
          goal.setQuaternion(tgtQuat.x, tgtQuat.y, tgtQuat.z, tgtQuat.w);
          if (animState.holdElapsed >= animState.holdMs) {
            // Teleport robot back to the *initial joint configuration*
            if (initialJointPositions) {
              for (const [name, val] of Object.entries(initialJointPositions)) {
                robot.setJointValue(name, val);
              }
              robot.updateMatrixWorld(true);
            }

            // Reset the IK goal to the original EE pose (start)
            goal.setPosition(startPos.x, startPos.y, startPos.z);
            goal.setQuaternion(startQuat.x, startQuat.y, startQuat.z, startQuat.w);

            // Begin a fresh forward pass
            animState.phase = 'forward';
            animState.t = 0;
            animState.holdElapsed = 0;
          }

        }
      }

      // Backend animation frame streaming
      if (backendAnimState.streaming) {
        captureAnimationFrame();
      }

      // Solve IK for this frame
      setIKFromUrdf(ikRoot, robot);
      solver.solve();
      setUrdfFromIK(robot, ikRoot);

      // ----- yellow drop lines from finger tips -----
      function updateFingerLine(link, lineMesh, localTipVec) {
        if (!link) { lineMesh.visible = false; return; }
        link.updateMatrixWorld(true);
        const tipWorld = localTipVec.clone().applyMatrix4(link.matrixWorld);
        const lenToFloor = tipWorld.z - (floorZ + fingerBottomPad);
        if (lenToFloor <= 0) { lineMesh.visible = false; return; }
        lineMesh.visible = true;
        lineMesh.scale.y = lenToFloor / baseLineLen;
        const midZ = (floorZ + fingerBottomPad) + 0.5 * lenToFloor;
        lineMesh.position.set(tipWorld.x, tipWorld.y, midZ);
      }
      updateFingerLine(leftFingerLink,  leftFingerLine,  fingerTipLocalLeft);
      updateFingerLine(rightFingerLink, rightFingerLine, fingerTipLocalRight);

      // ----- gripper arrows track the two finger links -----
      gripArrows.forEach(arrow => {
        const link = arrow.userData.targetLink;
        const originLocal = arrow.userData.originLocal;
        const dirLocal = arrow.userData.dirLocal;
        if (!link) return;
        link.updateMatrixWorld(true);
        const worldPos = originLocal.clone().applyMatrix4(link.matrixWorld);
        arrow.position.copy(worldPos);
        const worldDir = dirLocal.clone().transformDirection(link.matrixWorld);
        arrow.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), worldDir);
      });
      updateGripArrowVisibility();

      // ----- rotation wheels follow marker orientation -----
      (function updateWheels(){
        const pos = marker.position;
        const q = marker.quaternion;
        const xW = new THREE.Vector3(1,0,0).applyQuaternion(q).normalize();
        const yW = new THREE.Vector3(0,1,0).applyQuaternion(q).normalize();
        const zW = new THREE.Vector3(0,0,1).applyQuaternion(q).normalize();
        if (rotationWheels.roll) {
          rotationWheels.roll.group.position.copy(pos);
          alignRingToNormal(rotationWheels.roll.group, xW);
        }
        if (rotationWheels.pitch) {
          rotationWheels.pitch.group.position.copy(pos);
          alignRingToNormal(rotationWheels.pitch.group, yW);
        }
        if (rotationWheels.yaw) {
          rotationWheels.yaw.group.position.copy(pos);
          alignRingToNormal(rotationWheels.yaw.group, zW);
        }
      })();

      positionGripHUDs();
      positionPoseResetHUDs();
      positionHomeHUDs();

      // ----- render all views -----
      views.forEach(view => {
        // Render this view
        scene.background = null; // canvas stays transparent; camera is the CSS bg
        view.renderer.render(scene, view.camera);
      });
    }


    animate();
  },
  undefined, // progress callback (optional)
  error => {
    console.error('[ERROR] Failed to load URDF robot:', error);
    console.error('[ERROR] Check if the URDF file exists at: assets/trossen_arm_description/urdf/generated/wxai/wxai_base.urdf');
  }
);

// Stop recording on page hide to avoid orphaned sessions
window.addEventListener('pagehide', () => { 
  if (CanvasRecording.isActive()) CanvasRecording.stop(); 
});

</script>

<div id="recPreflight" aria-hidden="true">
  <div class="card">
    <div class="title">Share this tab to start recording</div>
    <div class="hint">
      When your browser prompts, choose <b>This Tab</b>. We'll hide the system cursor and draw a large
      high-contrast cursor so interactions are clear on video.
    </div>
  </div>
</div>
<div id="bigCursor" aria-hidden="true"><div class="ring"></div><div class="dot"></div></div>
<!-- The REC indicator is injected into #viewport via JS so it stays anchored on the card -->

</body></html>
